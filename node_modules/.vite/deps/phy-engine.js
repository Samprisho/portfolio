import {
  PMREMGenerator,
  ShaderChunk,
  WebGLRenderer
} from "./chunk-IHX3QWKG.js";
import {
  AddEquation,
  AdditiveAnimationBlendMode,
  AdditiveBlending,
  AmbientLight,
  AnimationClip,
  AnimationMixer,
  AnimationUtils,
  BackSide,
  Bone,
  Box2,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  CanvasTexture,
  CircleGeometry,
  ClampToEdgeWrapping,
  Color,
  ColorManagement,
  CompressedArrayTexture,
  CompressedCubeTexture,
  CompressedTexture,
  CubeCamera,
  Curve,
  CustomBlending,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  EquirectangularReflectionMapping,
  Euler,
  EventDispatcher,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  IcosahedronGeometry,
  ImageBitmapLoader,
  InstancedBufferAttribute,
  InstancedMesh,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  Layers,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  Loader,
  LoaderUtils,
  LoadingManager,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MultiplyBlending,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  NormalAnimationBlendMode,
  NormalBlending,
  NumberKeyframeTrack,
  Object3D,
  ObjectSpaceNormalMap,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGFormat,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  ReverseSubtractEquation,
  SRGBColorSpace,
  Scene,
  ShaderMaterial,
  ShadowMaterial,
  Shape,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  ShortType,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  Source,
  Sphere,
  SphereGeometry,
  SpotLight,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  SubtractEquation,
  SubtractiveBlending,
  Texture,
  TextureLoader,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  UVMapping,
  Uint16BufferAttribute,
  Uniform,
  UnsignedByteType,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  ZeroFactor
} from "./chunk-O4IN7IU6.js";
import {
  __publicField
} from "./chunk-V6TY7KAL.js";

// node_modules/phy-engine/build/Phy.module.js
var PI = Math.PI;
var torad$3 = PI / 180;
var todeg$1 = 180 / PI;
var EPSILON = Number.EPSILON;
var PI90 = PI * 0.5;
var M = {
  //-----------------------
  //  LIGHT
  //-----------------------
  luminousPowers: {
    "110000 lm (1000W)": 11e4,
    "3500 lm (300W)": 3500,
    "1700 lm (100W)": 1700,
    "800 lm (60W)": 800,
    "400 lm (40W)": 400,
    "180 lm (25W)": 180,
    "20 lm (4W)": 20,
    "Off": 0
  },
  // ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
  luminousIrradiances: {
    "0.0001 lx (Moonless Night)": 1e-4,
    "0.002 lx (Night Airglow)": 2e-3,
    "0.5 lx (Full Moon)": 0.5,
    "3.4 lx (City Twilight)": 3.4,
    "50 lx (Living Room)": 50,
    "100 lx (Very Overcast)": 100,
    "350 lx (Office Room)": 350,
    "400 lx (Sunrise/Sunset)": 400,
    "1000 lx (Overcast)": 1e3,
    "18000 lx (Daylight)": 18e3,
    "50000 lx (Direct Sun)": 5e4
  },
  exposure: (v) => Math.pow(v, 5),
  //Candela is default three light intensity
  candelaToLumens: (v) => v * 4 * Math.PI,
  lumensToCandela: (v) => v / (4 * Math.PI),
  //-----------------------
  //  MATH
  //-----------------------
  todeg: todeg$1,
  torad: torad$3,
  toFixed: (x2, n2 = 3) => x2.toFixed(n2) * 1,
  toRound: (x2, n2 = 3) => Math.trunc(x2),
  clamp: (v, min = 0, max2 = 1) => {
    v = v < min ? min : v;
    v = v > max2 ? max2 : v;
    return v;
  },
  clampA: (v, min, max2) => Math.max(min, Math.min(max2, v)),
  lerp: (x2, y, t2) => (1 - t2) * x2 + t2 * y,
  damp: (x2, y, lambda, dt2) => M.lerp(x2, y, 1 - Math.exp(-lambda * dt2)),
  nearAngle: (s1, s2, deg = false) => s2 + Math.atan2(Math.sin(s1 - s2), Math.cos(s1 - s2)) * (deg ? todeg$1 : 1),
  unwrapDeg: (r) => r - Math.floor((r + 180) / 360) * 360,
  //unwrapRad: ( r ) => (r - (Math.floor((r + Math.PI)/(2*Math.PI)))*2*Math.PI),
  unwrapRad: (r) => Math.atan2(Math.sin(r), Math.cos(r)),
  nearEquals: (a, b, t2) => Math.abs(a - b) <= t2 ? true : false,
  autoSize: (s = [1, 1, 1], type = "box") => {
    if (s.length === 1) s[1] = s[0];
    let radius = s[0];
    let height = s[1];
    if (type === "sphere") s = [radius, radius, radius];
    if (type === "cylinder" || type === "wheel" || type === "capsule") s = [radius, height, radius];
    if (type === "cone" || type === "pyramid") s = [radius, height, radius];
    if (s.length === 2) s[2] = s[0];
    return s;
  },
  shuffle: (array) => {
    let shuffled = array.map((value) => ({ value, sort: Math.random() })).sort((a, b) => a.sort - b.sort).map(({ value }) => value);
    return shuffled;
  },
  /*distance: ( a, b = { x:0, y:0, z:0 } ) => { // rotation array in degree
  
          const dx = a.x ? a.x - b.x : 0
          const dy = a.y ? a.y - b.y : 0
          const dz = a.z ? a.z - b.z : 0
          return Math.sqrt( dx * dx + dy * dy + dz * dz );
  
      },*/
  //-----------------------
  //  RANDOM
  //-----------------------
  randomSign: () => Math.random() < 0.5 ? -1 : 1,
  randSpread: (range) => range * (0.5 - Math.random()),
  rand: (low = 0, high = 1) => low + Math.random() * (high - low),
  randInt: (low, high) => low + Math.floor(Math.random() * (high - low + 1)),
  randIntUnic: (low, high, num) => {
    var arr = [];
    while (arr.length < num) {
      var r = M.randInt(low, high);
      if (arr.indexOf(r) === -1) arr.push(r);
    }
    return arr;
  },
  //-----------------------
  //  EXTRA
  //-----------------------
  fromTransform: (p1, q1, p2, q2 = [0, 0, 0, 1], inv = false) => {
    let m1 = M.composeMatrixArray(p1, q1);
    let m2 = M.composeMatrixArray(p2, q2);
    if (inv) m1 = M.invertMatrixArray(m1);
    m1 = M.multiplyMatrixArray(m1, m2);
    return [m1[12], m1[13], m1[14]];
  },
  fromTransformToQ: (p2, q, inv = false) => {
    let m2 = M.composeMatrixArray(p2, q);
    let res = M.decomposeFullMatrixArray(m2);
    let q1 = res.q;
    if (inv) q1 = M.quatInvert(q1);
    return q1;
  },
  //-----------------------
  //  MATRIX
  //-----------------------
  composeMatrixArray: (p2, q, s = [1, 1, 1]) => {
    const x2 = q[0], y = q[1], z = q[2], w = q[3];
    const x22 = x2 + x2, y2 = y + y, z2 = z + z;
    const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x22, wy = w * y2, wz = w * z2;
    const sx = s[0], sy = s[1], sz = s[2];
    return [
      (1 - (yy + zz)) * sx,
      (xy + wz) * sx,
      (xz - wy) * sx,
      0,
      (xy - wz) * sy,
      (1 - (xx + zz)) * sy,
      (yz + wx) * sy,
      0,
      (xz + wy) * sz,
      (yz - wx) * sz,
      (1 - (xx + yy)) * sz,
      0,
      p2[0],
      p2[1],
      p2[2],
      1
    ];
  },
  multiplyMatrixArray: (a, b) => {
    const ae = a;
    const be = b;
    const te = [];
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return te;
  },
  invertMatrixArray: (m2) => {
    const te = m2, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return te;
  },
  matrixArrayDeterminant: (m2) => {
    const te = m2;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  decomposeMatrixArray: (m2) => {
    return [
      m2[12],
      m2[13],
      m2[14]
    ];
  },
  decomposeFullMatrixArray: (m2) => {
    const te = m2;
    let sx = M.lengthArray([te[0], te[1], te[2]]);
    const sy = M.lengthArray([te[4], te[5], te[6]]);
    const sz = M.lengthArray([te[8], te[9], te[10]]);
    const det = M.matrixArrayDeterminant(m2);
    if (det < 0) sx = -sx;
    let m1 = [...m2];
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    m1[0] *= invSX;
    m1[1] *= invSX;
    m1[2] *= invSX;
    m1[4] *= invSY;
    m1[5] *= invSY;
    m1[6] *= invSY;
    m1[8] *= invSZ;
    m1[9] *= invSZ;
    m1[10] *= invSZ;
    let q = M.quatFromRotationMatrix(m1);
    return {
      p: [m2[12], m2[13], m2[14]],
      q,
      s: [sx, sy, sz]
    };
  },
  // for physx substep 
  applyTransformArray: (v, p2, q, s = [1, 1, 1]) => {
    const e = M.composeMatrixArray(p2, q, s);
    const x2 = v[0], y = v[1], z = v[2];
    const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);
    return [
      (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w,
      (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w,
      (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w
    ];
  },
  slerpQuatArray: (a, b, t2) => {
    if (t2 === 0) return a;
    if (t2 === 1) return b;
    let r = [...a];
    const x2 = a[0], y = a[1], z = a[2], w = a[3];
    const qx = b[0], qy = b[1], qz = b[2], qw = b[3];
    let cosHalfTheta = w * qw + x2 * qx + y * qy + z * qz;
    if (cosHalfTheta < 0) {
      r = [-qx, -qy, -qz, -qw];
      cosHalfTheta = -cosHalfTheta;
    } else {
      r = [...b];
    }
    if (cosHalfTheta >= 1) return a;
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= EPSILON) {
      const s = 1 - t2;
      r[3] = s * w + t2 * r[3];
      r[0] = s * x2 + t2 * r[0];
      r[1] = s * y + t2 * r[1];
      r[2] = s * z + t2 * r[2];
      return M.quatNomalize(r);
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    r[3] = w * ratioA + r[3] * ratioB;
    r[0] = x2 * ratioA + r[0] * ratioB;
    r[1] = y * ratioA + r[1] * ratioB;
    r[2] = z * ratioA + r[2] * ratioB;
    return r;
  },
  //-----------------------
  //  QUAT
  //-----------------------
  toLocalQuatArray: (rot = [0, 0, 0], b) => {
    let q1 = M.quatFromEuler(rot);
    let q2 = M.quatInvert(b.quaternion.toArray());
    return M.quatMultiply(q2, q1);
  },
  quatFromRotationMatrix: (m2) => {
    let q = [0, 0, 0, 1];
    const te = m2, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      q[3] = 0.25 / s;
      q[0] = (m32 - m23) * s;
      q[1] = (m13 - m31) * s;
      q[2] = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      q[3] = (m32 - m23) / s;
      q[0] = 0.25 * s;
      q[1] = (m12 + m21) / s;
      q[2] = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      q[3] = (m13 - m31) / s;
      q[0] = (m12 + m21) / s;
      q[1] = 0.25 * s;
      q[2] = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      q[3] = (m21 - m12) / s;
      q[0] = (m13 + m31) / s;
      q[1] = (m23 + m32) / s;
      q[2] = 0.25 * s;
    }
    return q;
  },
  quatFromEuler: (r = [0, 0, 0], isDeg = true) => {
    const cos = Math.cos;
    const sin = Math.sin;
    const n2 = isDeg ? torad$3 : 1;
    const x2 = r[0] * n2 * 0.5, y = r[1] * n2 * 0.5, z = r[2] * n2 * 0.5;
    const c1 = cos(x2), c2 = cos(y), c3 = cos(z);
    const s1 = sin(x2), s2 = sin(y), s3 = sin(z);
    return [
      s1 * c2 * c3 + c1 * s2 * s3,
      c1 * s2 * c3 - s1 * c2 * s3,
      c1 * c2 * s3 + s1 * s2 * c3,
      c1 * c2 * c3 - s1 * s2 * s3
    ];
  },
  quatFromAxis: (r = [0, 0, 0], angle, isDeg = true) => {
    const n2 = isDeg ? torad$3 : 1;
    const halfAngle = angle * 0.5 * n2, s = Math.sin(halfAngle);
    return [
      r[0] * s,
      r[1] * s,
      r[2] * s,
      Math.cos(halfAngle)
    ];
  },
  quatNomalize: (q) => {
    let l = M.lengthArray(q);
    if (l === 0) {
      return [0, 0, 0, 1];
    } else {
      l = 1 / l;
      return M.scaleArray(q, l, 4);
    }
  },
  quatInvert: (q) => {
    return [-q[0], -q[1], -q[2], q[3]];
  },
  quatMultiply: (a, b) => {
    const qax = a[0], qay = a[1], qaz = a[2], qaw = a[3];
    const qbx = b[0], qby = b[1], qbz = b[2], qbw = b[3];
    return [
      qax * qbw + qaw * qbx + qay * qbz - qaz * qby,
      qay * qbw + qaw * qby + qaz * qbx - qax * qbz,
      qaz * qbw + qaw * qbz + qax * qby - qay * qbx,
      qaw * qbw - qax * qbx - qay * qby - qaz * qbz
    ];
  },
  quatToAxis: (q) => {
    let w = 2 * Math.acos(q[3]);
    const s = Math.sqrt(1 - q[3] * q[3]);
    if (s < 1e-4) {
      return [1, 0, 0];
    } else {
      return [q[0] / s, q[1] / s, q[2] / s, w];
    }
  },
  eulerFromMatrix: (te) => {
    const m11 = te[0], m12 = te[4], m13 = te[8];
    te[1];
    const m22 = te[5], m23 = te[9];
    te[2];
    const m32 = te[6], m33 = te[10];
    let ar = [0, 0, 0];
    ar[1] = Math.asin(M.clamp(m13, -1, 1));
    if (Math.abs(m13) < 0.9999999) {
      ar[0] = Math.atan2(-m23, m33);
      ar[2] = Math.atan2(-m12, m11);
    } else {
      ar[0] = Math.atan2(m32, m22);
      ar[2] = 0;
    }
    return ar;
  },
  angleTo: (a, b) => {
    return 2 * Math.acos(Math.abs(M.clamp(M.dotArray(a, b), -1, 1)));
  },
  //-----------------------
  //  ARRAY
  //-----------------------
  getSize: (r) => r.byteLength * 1e-3 + "kb",
  // Creates a vector normal (perpendicular) to the current Vector3
  perpendicularArray: (v) => {
    const radius = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    let theta = Math.acos(v[1] / radius);
    const phi = Math.atan2(v[2], v[0]);
    if (theta > PI90) theta -= PI90;
    else theta += PI90;
    const x2 = radius * Math.sin(theta) * Math.cos(phi);
    const y = radius * Math.cos(theta);
    const z = radius * Math.sin(theta) * Math.sin(phi);
    return [x2, y, z];
  },
  crossArray: (a, b) => {
    const ax = a[0], ay = a[1], az = a[2];
    const bx = b[0], by = b[1], bz = b[2];
    let x2 = ay * bz - az * by;
    let y = az * bx - ax * bz;
    let z = ax * by - ay * bx;
    return [x2, y, z];
  },
  applyQuaternion: (v, q) => {
    const vx = v[0], vy = v[1], vz = v[2];
    const qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    let x2 = vx + qw * tx + qy * tz - qz * ty;
    let y = vy + qw * ty + qz * tx - qx * tz;
    let z = vz + qw * tz + qx * ty - qy * tx;
    return [x2, y, z];
  },
  nullArray: (a, n2, i) => {
    let j = 0;
    while (i--) j += a[n2 + i];
    return j;
  },
  equalArray: (a, b) => {
    let i = a.length;
    while (i--) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  },
  lerpArray: (a, b, t2) => {
    if (t2 === 0) return a;
    if (t2 === 1) return b;
    let i = a.length;
    let r = [];
    while (i--) {
      r[i] = a[i];
      r[i] += (b[i] - r[i]) * t2;
    }
    return r;
  },
  zeroArray: (a, n2 = 0, i) => {
    i = i ?? a.length;
    while (i--) a[n2 + i] = 0;
    return a;
  },
  lengthArray: (r) => {
    let i = r.length, l = 0;
    while (i--) l += r[i] * r[i];
    return Math.sqrt(l);
  },
  dotArray: (a, b) => {
    let i = a.length, r = 0;
    while (i--) r += a[i] * b[i];
    return r;
  },
  addArray: (a, b, i) => {
    i = i ?? a.length;
    let r = [];
    while (i--) r[i] = a[i] + b[i];
    return r;
  },
  subArray: (a, b, i) => {
    i = i ?? a.length;
    let r = [];
    while (i--) r[i] = a[i] - b[i];
    return r;
  },
  mulArray: (a, b, i) => {
    let ar = b instanceof Array;
    if (!ar) {
      return a.map((x2) => x2 * b);
    } else {
      let r = [];
      i = i ?? a.length;
      while (i--) r[i] = a[i] * b[i];
      return r;
    }
  },
  divArray: (r, s, i) => M.mulArray(r, 1 / s, i),
  scaleArray: (r, s, i) => M.mulArray(r, s, i),
  fillArray: (a, b, n2 = 0, i) => {
    i = i ?? a.length;
    while (i--) b[n2 + i] = a[i];
  },
  copyArray: (a, b) => {
    [...b];
  },
  cloneArray: (a) => [...a],
  distanceArray: (a, b = [0, 0, 0]) => M.lengthArray(M.subArray(a, b)),
  normalizeArray: (a) => M.divArray(a, M.lengthArray(a) || 1),
  normalArray: (a, b = [0, 0, 0]) => M.normalizeArray(M.subArray(b, a)),
  //-----------------------
  //  VOLUME
  //-----------------------
  getVolume: (type, size, vertex = null) => {
    let volume = 1;
    let s = size;
    switch (type) {
      case "sphere":
        volume = 4 * Math.PI * s[0] * s[0] * s[0] / 3;
        break;
      case "cone":
        volume = Math.PI * s[0] * (s[1] * 0.5) * 2;
        break;
      case "box":
        volume = 8 * (s[0] * 0.5) * (s[1] * 0.5) * (s[2] * 0.5);
        break;
      case "cylinder":
        volume = Math.PI * s[0] * s[0] * (s[1] * 0.5) * 2;
        break;
      case "capsule":
        volume = 4 * Math.PI * s[0] * s[0] * s[0] / 3 + Math.PI * s[0] * s[0] * (s[1] * 0.5) * 2;
        break;
      case "convex":
      case "mesh":
        volume = M.getConvexVolume(vertex);
        break;
    }
    return volume;
  },
  getConvexVolume: (v) => {
    let i = v.length / 3, n2;
    let min = [0, 0, 0];
    let max2 = [0, 0, 0];
    while (i--) {
      n2 = i * 3;
      if (v[n2] < min[0]) min[0] = v[n2];
      else if (v[n2] > max2[0]) max2[0] = v[n2];
      if (v[n2 + 1] < min[1]) min[1] = v[n2 + 1];
      else if (v[n2 + 1] > max2[1]) max2[1] = v[n2 + 1];
      if (v[n2 + 2] < min[2]) min[2] = v[n2 + 2];
      else if (v[n2 + 2] > max2[2]) max2[2] = v[n2 + 2];
    }
    let s = [max2[0] - min[0], max2[1] - min[1], max2[2] - min[2]];
    return 8 * (s[0] * 0.5) * (s[1] * 0.5) * (s[2] * 0.5);
  },
  massFromDensity: (density, volume) => density * volume,
  densityFromMass: (mass, volume) => mass / volume,
  // GEOMETRY
  toNonIndexed: (g2) => !g2.index ? g2 : g2.clone().toNonIndexed(),
  getIndex: (g2, noIndex) => {
    if (!g2.index || noIndex) return null;
    return g2.index.array || null;
  },
  getVertex: (g2, noIndex) => {
    let c = g2.attributes.position.array;
    if (noIndex && g2.index) {
      g2 = g2.clone().toNonIndexed();
      c = g2.attributes.position.array;
    }
    return c;
  },
  getNormal: (g2) => {
    let c = g2.attributes.normal.array;
    return c;
  },
  getFaces: (g2) => {
    let faces = [];
    if (g2.index) {
      let index = g2.getIndex();
      for (let i = 0; i < index.count; i += 3) {
        faces.push([index.getX(i), index.getX(i + 1), index.getX(i + 2)]);
      }
    } else {
      let lng = g2.getAttribute("position").count;
      for (let i = 0; i < lng; i += 3) {
        faces.push([i, i + 1, i + 2]);
      }
    }
    return faces;
  },
  reduce: (x2) => {
  },
  barycentric: (simplex, point) => {
  },
  solve: (simplex, point) => {
  }
};
var MathTool = M;
var Max = {
  body: 4e3,
  joint: 1e3,
  contact: 4e3,
  ray: 100,
  character: 100,
  vehicle: 50,
  solver: 20
};
var Num = {
  bodyFull: 14,
  body: 8,
  joint: 16,
  contact: 1,
  ray: 11,
  character: 16,
  vehicle: 72,
  //max 8 wheels
  solver: 128
};
var getArray = function(engine, full = false) {
  const ArPos = {};
  let counts = {
    body: Max.body * (full ? Num.bodyFull : Num.body),
    joint: Max.joint * Num.joint,
    ray: Max.ray * Num.ray,
    contact: Max.contact * Num.contact,
    character: Max.character * Num.character
  };
  if (engine === "PHYSX" || engine === "AMMO") {
    counts["vehicle"] = Max.vehicle * Num.vehicle;
  }
  if (engine === "PHYSX") {
    counts["solver"] = Max.solver * Num.solver;
  }
  if (engine === "HAVOK" || engine === "RAPIER" || engine === "JOLT") {
    Num.joint = 0;
  }
  let prev = 0;
  for (let m2 in counts) {
    ArPos[m2] = prev;
    prev += counts[m2];
  }
  ArPos["total"] = prev;
  return ArPos;
};
var getType = function(o) {
  switch (o.type) {
    case "plane":
    case "box":
    case "sphere":
    case "highSphere":
    case "customSphere":
    case "cylinder":
    case "stair":
    case "particle":
    case "cone":
    case "capsule":
    case "mesh":
    case "convex":
    case "compound":
    case "null":
      if (!o.mass && !o.density && !o.kinematic) return "solid";
      else return "body";
    case "fixe":
    case "generic":
    case "universal":
    case "dof":
    case "d6":
    case "hinge":
    case "revolute":
    case "prismatic":
    case "cylindrical":
    case "slider":
    case "spherical":
    case "ragdoll":
    case "distance":
      return "joint";
    default:
      return o.type;
  }
};
var map = /* @__PURE__ */ new Map();
var root = {
  debug: false,
  Ar: null,
  ArPos: {},
  garbage: [],
  //AR:null,
  viewSize: null,
  engine: "OIMO",
  motor: null,
  scene: null,
  scenePlus: null,
  //threeScene : null,
  post: null,
  //up:null,
  //update:null,
  //change:null,
  jointVisible: false,
  delta: 0,
  add: null,
  remove: null,
  items: null,
  tmpMesh: [],
  instanceMesh: {},
  tmpTex: [],
  //tmpMat : [],
  //hideMaterial: null,
  //lineMaterial: null,
  mouseDown: false,
  flow: {
    stamp: 0,
    current: "",
    key: [],
    tmp: [],
    add: [],
    remove: []
  },
  reflow: {
    ray: [],
    stat: { fps: 0 },
    point: {}
  },
  extraMaterial: () => {
  },
  disposeTmp: () => {
    let i, j, m2;
    for (i in root.tmpMesh) {
      m2 = root.tmpMesh[i];
      if (m2.children) {
        for (j in m2.children) root.disposeMesh(m2.children[j]);
      }
      root.disposeMesh(m2);
      if (m2.parent) m2.parent.remove(m2);
    }
    root.tmpMesh = [];
    for (i in root.tmpTex) root.tmpTex[i].dispose();
  },
  disposeMesh: (m2) => {
    if (m2.geometry) m2.geometry.dispose();
    if (m2.dispose) m2.dispose();
  }
};
var Utils = {
  byName: (name) => {
    if (!map.has(name)) return null;
    return map.get(name);
  },
  add: (b, parent) => {
    if (b.type !== "contact" && !b.isInstance && b.isObject3D) {
      if (!parent) {
        if (b.isButton) {
          root.scene.add(b);
        } else {
          switch (b.type) {
            case "terrain":
            case "solid":
            case "joint":
            case "ray":
            case "articulation":
              root.scenePlus.add(b);
              break;
            default:
              root.scene.add(b);
              break;
          }
        }
      } else {
        parent.add(b);
      }
    }
    if (b.isInstance && b.refName !== b.name) map.set(b.refName, b);
    map.set(b.name, b);
  },
  remove: (b) => {
    if (b.dispose) b.dispose();
    if (b.parent) b.parent.remove(b);
    if (b.isInstance) {
      if (b.refName !== b.name) map.delete(b.refName);
      b.instance.remove(b.id);
    }
    map.delete(b.name);
  },
  noRay: (b) => {
    if (b.isObject3D) {
      b.raycast = () => {
        return;
      };
      b.traverse((child) => {
        if (child.isObject3D) child.raycast = () => {
          return;
        };
      });
    }
  },
  morph: (obj, name, value) => {
    if (!obj.morphTargetInfluences) return;
    if (obj.morphTargetDictionary[name] === void 0) return;
    obj.morphTargetInfluences[obj.morphTargetDictionary[name]] = value;
  },
  toLocal: (v, obj, isAxe = false) => {
    if (!isAxe) v.sub(obj.position);
    let q = obj.quaternion;
    v.applyQuaternion({ x: -q._x, y: -q._y, z: -q._z, w: q._w });
    return v;
  },
  quatLocal: (q, obj) => {
    if (obj.isObject3D) obj.updateWorldMatrix(true, false);
    let q1 = new Quaternion().fromArray(q);
    let q2 = obj.quaternion.clone().invert();
    q1.premultiply(q2);
    return q1.normalize().toArray();
  },
  axisLocal: (v, obj) => {
    if (obj.isObject3D) obj.updateWorldMatrix(true, false);
    let m3 = new Matrix3().setFromMatrix4(obj.matrixWorld);
    let vv = new Vector3().fromArray(v).applyMatrix3(m3);
    return vv.toArray();
  },
  quatToAngular: (qb, qa) => {
    qa[0] *= -1;
    qa[1] *= -1;
    qa[2] *= -1;
    let x2 = qa[0] * qb[3] + qa[3] * qb[0] + qa[1] * qb[2] - qa[2] * qb[1];
    let y = qa[1] * qb[3] + qa[3] * qb[1] + qa[2] * qb[0] - qa[0] * qb[2];
    let z = qa[2] * qb[3] + qa[3] * qb[2] + qa[0] * qb[1] - qa[1] * qb[0];
    let w = qa[3] * qb[3] - qa[0] * qb[0] - qa[1] * qb[1] - qa[2] * qb[2];
    let angle = 2 * Math.acos(w), ax;
    let s = Math.sqrt(1 - w * w);
    if (s < 1e-3) {
      ax = [0, 0, 0];
    } else {
      ax = [x2 / s, y / s, z / s];
    }
    const v = new Vector3().fromArray(ax);
    const timeDiff = 1;
    v.multiplyScalar(angle / timeDiff);
  },
  /* matrixToAxix: ( m ) => {
  
      	let p = new Vector3(1,0,0).transformDirection( m )
      	return p.toArray()
  
      },*/
  refAxis: (m2, axe) => {
    let zAxis = new Vector3().fromArray(axe);
    let xAxis = new Vector3(1, 0, 0);
    let yAxis = new Vector3(0, 1, 0);
    if (Math.abs(axe[1]) > 0.9999) {
      yAxis.copy(xAxis).cross(zAxis).normalize();
    } else {
      xAxis.copy(zAxis).cross(yAxis).normalize();
      yAxis.copy(xAxis).cross(zAxis).normalize();
    }
    m2.makeBasis(xAxis, yAxis, zAxis);
  }
};
var CircleHelper = class extends LineSegments {
  constructor(box, color = 16776960) {
    let size = 0.6;
    const indices = new Uint16Array([
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      0,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      6,
      12,
      13,
      13,
      14,
      14,
      15,
      15,
      16,
      16,
      17,
      17,
      12,
      18,
      19,
      20,
      21,
      22,
      23
    ]);
    const positions = [
      0.5,
      0,
      0,
      0.25,
      0.433,
      0,
      -0.25,
      0.433,
      0,
      -0.5,
      0,
      0,
      -0.25,
      -0.433,
      0,
      0.25,
      -0.433,
      0,
      0.5,
      0,
      0,
      0.25,
      0,
      0.433,
      -0.25,
      0,
      0.433,
      -0.5,
      0,
      0,
      -0.25,
      0,
      -0.433,
      0.25,
      0,
      -0.433,
      0,
      0.5,
      0,
      0,
      0.25,
      0.433,
      0,
      -0.25,
      0.433,
      0,
      -0.5,
      0,
      0,
      -0.25,
      -0.433,
      0,
      0.25,
      -0.433,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    super(geometry, new LineBasicMaterial({ color, depthTest: false, depthWrite: false, toneMapped: false, transparent: true }));
    this.box = box;
    this.type = "CircleHelper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var geoN = 0;
var geo = {};
var Geo = {
  unic: (g2) => {
    geo["geo" + geoN++] = g2;
  },
  set: (g2) => {
    geo[g2.name] = g2;
  },
  get: (name, o = {}) => {
    if (!geo[name]) {
      let g2;
      switch (name) {
        case "plane":
          g2 = new PlaneGeometry(1, 1);
          g2.rotateX(-Math.PI * 0.5);
          break;
        case "box":
          g2 = new BoxGeometry(1, 1, 1);
          break;
        case "sphere":
          g2 = new SphereGeometry(1, 16, 12);
          break;
        case "cylinder":
          g2 = new CylinderGeometry(1, 1, 1, 16);
          break;
        //case 'wheel':    g = new CylinderGeometry( 1, 1, 1 , 16 ); g.rotateX( -Math.PI * 0.5 ); break
        case "cone":
          g2 = new CylinderGeometry(1e-3, 1, 1, 16);
          break;
        //case 'joint':    g = new Box3Helper().geometry; g.scale( 0.05,0.05,0.05 ); break
        case "particle":
          g2 = new SphereGeometry(1, 8, 6);
          break;
        case "joint":
          g2 = new CircleHelper().geometry;
          break;
        default:
          return null;
      }
      geo[name] = g2;
    }
    return geo[name];
  },
  dispose: () => {
    for (let n2 in geo) geo[n2].dispose();
    geo = {};
    geoN = 0;
  }
};
var CarbonTexture = class {
  constructor(normal, c1 = "rgb(69,69,69)", c2 = "rgb(39,39,39)") {
    let s = 128;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = s;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = c1;
    ctx.fillRect(0, 0, s, s);
    if (!normal) {
      ctx.beginPath();
      ctx.fillStyle = c2;
      ctx.rect(0, 0, 32, 64);
      ctx.rect(32, 32, 32, 64);
      ctx.rect(64, 64, 32, 64);
      ctx.rect(96, 96, 32, 64);
      ctx.rect(96, -32, 32, 64);
      ctx.fill();
    } else {
      let i, j, n2, d;
      let pos = [[0, 0], [32, 32], [64, 64], [96, 96], [96, -32]];
      let deg = [[0, 64], [32, 96], [64, 128], [96, 160], [-32, 32]];
      let f1 = normal ? "rgb(128,128,255)" : c1;
      let f2 = normal ? "rgb(160,100,255)" : c2;
      let f3 = normal ? "rgba(100,160,255, 0.5)" : "rgba(0,0,0, 0.1)";
      ctx.strokeStyle = f3;
      ctx.lineWidth = 1;
      for (i = 0; i < 5; i++) {
        d = ctx.createLinearGradient(0, deg[i][0], 0, deg[i][1]);
        d.addColorStop(0, f2);
        d.addColorStop(1, f1);
        ctx.beginPath();
        ctx.fillStyle = d;
        ctx.rect(pos[i][0], pos[i][1], 32, 64);
        ctx.fill();
        for (let j2 = 0; j2 < 8; j2++) {
          n2 = (Math.random() - 0.5) * 2;
          ctx.beginPath();
          ctx.moveTo(pos[i][0] + n2 + 2 + j2 * 4, pos[i][1]);
          ctx.lineTo(pos[i][0] + n2 + 2 + j2 * 4, pos[i][1] + 64);
          ctx.stroke();
        }
      }
      pos = [[32, 0], [64, 32], [96, 64], [-32, 64], [0, 96]];
      deg = [[32, 96], [64, 128], [96, 160], [-32, 32], [0, 64]];
      for (i = 0; i < 5; i++) {
        d = ctx.createLinearGradient(deg[i][0], 0, deg[i][1], 0);
        d.addColorStop(0, f1);
        d.addColorStop(1, f2);
        ctx.beginPath();
        ctx.fillStyle = d;
        ctx.rect(pos[i][0], pos[i][1], 64, 32);
        ctx.fill();
        for (j = 0; j < 8; j++) {
          n2 = (Math.random() - 0.5) * 2;
          ctx.beginPath();
          ctx.moveTo(pos[i][0], pos[i][1] + n2 + 2 + j * 4);
          ctx.lineTo(pos[i][0] + 64, pos[i][1] + n2 + 2 + j * 4);
          ctx.stroke();
        }
      }
    }
    const texture = new CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = RepeatWrapping;
    texture.repeat.x = texture.repeat.y = 60;
    if (!normal) texture.colorSpace = SRGBColorSpace;
    return texture;
  }
};
var MeshSssMaterial = class extends MeshPhysicalMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": "",
      "SUBSURFACE": "",
      "USE_UV": ""
    };
    this.extra = {};
    this.addParametre("sssMap", null);
    this.addParametre("sssColor", new Color(0, 0, 0));
    this.addParametre("sssAmbient", 0.5);
    this.addParametre("sssDistortion", 0.6);
    this.addParametre("sssAttenuation", 0.1);
    this.addParametre("sssPower", 1);
    this.addParametre("sssScale", 6);
    this.setValues(parameters);
    let self2 = this;
    self2.onBeforeCompile = function(shader) {
      for (let name in self2.extra) {
        shader.uniforms[name] = { value: self2.extra[name] };
      }
      shader.fragmentShader = shader.fragmentShader.replace("#include <common>", shaderChange.common);
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <lights_fragment_begin>",
        self2.replaceAll(
          ShaderChunk["lights_fragment_begin"],
          "RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );",
          shaderChange.light
        )
      );
      self2.userData.shader = shader;
    };
  }
  addParametre(name, value) {
    this.extra[name] = value;
    Object.defineProperty(this, name, {
      get: () => this.extra[name],
      set: (v) => {
        this.extra[name] = v;
        if (this.userData.shader) this.userData.shader.uniforms[name].value = this.extra[name];
      }
    });
  }
  replaceAll(string, find, replace) {
    return string.split(find).join(replace);
  }
  /*customProgramCacheKey(){
  
  		return self
  
  	} */
  /*onBeforeCompile( shader ){
  
  		for(let name in this.extra ) {
  			shader.uniforms[ name ] = { value: this.extra[name] };
  		}
  
  		shader.fragmentShader = shader.fragmentShader.replace( '#include <common>', shaderChange.common );
  		shader.fragmentShader = shader.fragmentShader.replace( '#include <lights_fragment_begin>', 
  			this.replaceAll(
  				THREE.ShaderChunk[ 'lights_fragment_begin' ],
  				'RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );',
  				shaderChange.light
  			)
  		);
  
  		this.userData.shader = shader;
  
  	}*/
};
var shaderChange = {
  common: (
    /* glsl */
    `
	#include <common>
	uniform sampler2D sssMap;
	uniform float sssPower;
	uniform float sssScale;
	uniform float sssDistortion;
	uniform float sssAmbient;
	uniform float sssAttenuation;
	uniform vec3 sssColor;

	void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {
		vec3 thickness = sssColor * texture2D(sssMap, uv).r;
		vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * sssDistortion));
		float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), sssPower) * sssScale;
		vec3 scatteringIllu = (scatteringDot + sssAmbient) * thickness;
		reflectedLight.directDiffuse += scatteringIllu * sssAttenuation * directLight.color;
	}
	`
  ),
  light: (
    /* glsl */
    `
	RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	#if defined( SUBSURFACE ) && defined( USE_UV )
		RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);
	#endif
	`
  )
};
var shaderFunctions = (
  /* glsl */
  `

mat4 brightnessMatrix( float brightness )
{
    return mat4( 1, 0, 0, 0,
                 0, 1, 0, 0,
                 0, 0, 1, 0,
                 brightness, brightness, brightness, 1 );
}

mat4 contrastMatrix( float contrast )
{
    float t = ( 1.0 - contrast ) / 2.0;
    
    return mat4( contrast, 0, 0, 0,
                 0, contrast, 0, 0,
                 0, 0, contrast, 0,
                 t, t, t, 1 );

}

mat4 saturationMatrix( float saturation )
{
    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );
    
    float oneMinusSat = 1.0 - saturation;
    
    vec3 red = vec3( luminance.x * oneMinusSat );
    red+= vec3( saturation, 0, 0 );
    
    vec3 green = vec3( luminance.y * oneMinusSat );
    green += vec3( 0, saturation, 0 );
    
    vec3 blue = vec3( luminance.z * oneMinusSat );
    blue += vec3( 0, 0, saturation );
    
    return mat4( red,     0,
                 green,   0,
                 blue,    0,
                 0, 0, 0, 1 );
}
//fragColor = brightnessMatrix( brightness ) *
//                contrastMatrix( contrast ) * 
//                saturationMatrix( saturation ) *
//                color;

// source: https://timseverien.com/posts/2020-06-19-colour-correction-with-webgl/
vec3 adjustContrast(vec3 color, float value) {
    const vec3 zero = vec3(0.);
    vec3 cc = color-0.5;
    return max(zero, 0.5 + value * (cc));
}

// source: https://gist.github.com/yiwenl/745bfea7f04c456e0101
vec3 hsv2rgb(vec3 c){
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// source: https://gist.github.com/yiwenl/745bfea7f04c456e0101
vec3 rgb2hsv(vec3 rgb) {
    float Cmax = max(rgb.r, max(rgb.g, rgb.b));
    float Cmin = min(rgb.r, min(rgb.g, rgb.b));
    float delta = Cmax - Cmin;
    vec3 hsv = vec3(0., 0., Cmax);
    if (Cmax > Cmin) {
        hsv.y = delta / Cmax;
        if (rgb.r == Cmax)
            hsv.x = (rgb.g - rgb.b) / delta;
        else {
            if (rgb.g == Cmax)
                hsv.x = 2. + (rgb.b - rgb.r) / delta;
            else
                hsv.x = 4. + (rgb.r - rgb.g) / delta;
        }
        hsv.x = fract(hsv.x / 6.);
    }
    return hsv;
}
`
);
var aoCode = (
  /* glsl */
  `
float aoMapClr = 1.;

#ifdef USE_AOMAP
    aoMapClr = (texture2D(aoMap, vAoMapUv).r - 1.0) * aoMapIntensity + 1.0;
#else
    #ifdef USE_LIGHTMAP

        float lightMapIntensityCorrect = lightMapIntensity;
        if(useLegacyLights) lightMapIntensityCorrect = lightMapIntensity / PI;
        vec3 lightMapVec = (texture2D(lightMap, vLightMapUv).rgb - vec3(1.)) * (lightMapIntensityCorrect) + vec3(1.);
        
        const vec3 luminanceWeight = vec3(0.2126, 0.7152, 0.0722);

        // grayscale the lightmap
        aoMapClr = dot(lightMapVec.rgb, luminanceWeight);
    #endif
#endif

if(aoMapGamma != 1.) aoMapClr = pow(aoMapClr, 1. / aoMapGamma);

// clamp
aoMapClr = min(1., aoMapClr);
`
);
var aomap_fragment = (
  /* glsl */
  `
#ifdef USE_AOMAP

    // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
    if(!enableESL) {

        float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
        reflectedLight.indirectDiffuse *= ambientOcclusion;

        #if defined( USE_CLEARCOAT ) 
            clearcoatSpecularIndirect *= ambientOcclusion;
        #endif

        #if defined( USE_SHEEN ) 
            sheenSpecularIndirect *= ambientOcclusion;
        #endif

        #if defined( USE_ENVMAP ) && defined( STANDARD )

            float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );

            reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

        #endif
    }

#endif
`
);
var envBasicCode = (
  /* glsl */
  `
envMapColor.rgb *= aoMapClr;

vec3 origEnvMapColor = vec3(envMapColor.rgb);

float origAoMapClr = aoMapClr;

#ifndef DISABLE_SMOOTHING
    // calculate smoothing
    float smoothingRoughnessInfluence = max(0.75 - roughness, 0.);
    float smoothingAoInfluence = (1. - aoMapClr) * 0.75;

    float totalSmoothing = 0.3 + smoothingPower + (1. - smoothingPower) * smoothingRoughnessInfluence - smoothingAoInfluence;
    vec3 smoothing = vec3(max(totalSmoothing, 0.));

    envMapColor.rgb = pow(envMapColor.rgb, smoothing);
#endif

envMapColor.rgb += pow(envMapColor.rgb, vec3(envPower)) * (aoPower * 0.2);

float aoMapPower = pow(aoMapClr + aoSmoothing * (0.5 - aoMapClr), aoPower);
if(aoMapPower > 1.) aoMapPower = 1.;
`
);
var getIBLIrradiance_replace = (
  /* glsl */
  `

if(enableESL){
    ${envBasicCode}

    envMapColor.rgb *= irradianceColor;

    #ifndef DISABLE_SMOOTHING
        envMapColor.rgb = pow(envMapColor.rgb, smoothing);
    #endif

    float origAoMapClrPow = origAoMapClr * origAoMapClr;

    vec3 hemisphereInfluence = aoMapClr * mix(
        irradianceColor,
        hemisphereColor,
        1. - origAoMapClrPow
    ) * envMapColor.rgb * envMapIntensity * 0.125;

    envMapColor.rgb = mix(envMapColor.rgb, hemisphereColor, 1. - origAoMapClrPow);

    vec3 env = irradianceIntensity * envMapColor.rgb * envMapIntensity * aoMapPower + hemisphereInfluence;

    if(sunIntensity != 0.){
        env += irradianceIntensity * sunIntensity * irradianceColor * origEnvMapColor * envMapIntensity * pow(aoMapClr, 16.);
    }

     return env;
} else {
    return PI * envMapColor.rgb * envMapIntensity;
}
`
);
var getIBLRadiance_replace = (
  /* glsl */
  `

if(enableESL) {
    ${envBasicCode}

    #ifndef DISABLE_SMOOTHING

        envMapColor.rgb *= radianceColor;
        envMapColor.rgb = pow(envMapColor.rgb, smoothing);

    #endif

    vec3 env = envMapColor.rgb * envMapIntensity * 0.125 * (aoMapPower * radianceIntensity + aoMapClr * radianceColor);

    if(sunIntensity != 0.){
        env += radianceIntensity * sunIntensity * irradianceColor * origEnvMapColor * envMapIntensity * pow(aoMapClr, 16.);
    }

    return env;

} else {
    return envMapColor.rgb * envMapIntensity;
}
`
);
var new_map_fragment = (
  /* glsl */
  `
#ifdef USE_MAP

   vec4 sampledDiffuseColor = texture2D( map, vMapUv );

   #ifdef DECODE_VIDEO_TEXTURE

        // use inline sRGB decode until browsers properly support SRGB8_ALPHA8 with video textures (#26516)

        sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
    
    #endif

if(enableESL) {
    #ifdef USE_LIGHTMAP
        float lightMapIntensityCorrect = lightMapIntensity;
        if(useLegacyLights) lightMapIntensityCorrect = lightMapIntensity / PI;
        vec3 lightMapClr = (texture2D(lightMap, vLightMapUv).rgb - vec3(1.)) * (lightMapIntensityCorrect) + vec3(1.);
    #else
        vec3 lightMapClr = vec3(1.);
    #endif

    if(lightMapGamma != 1.) lightMapClr = pow(lightMapClr, vec3(1. / lightMapGamma));

    if(lightMapContrast != 1.) lightMapClr = adjustContrast(lightMapClr, lightMapContrast);

    // clamp
    lightMapClr = min(lightMapClr, vec3(1.));

    // source: Chapter 16 of OpenGL Shading Language
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    vec3 intensity = vec3(dot(lightMapClr, W));
    lightMapClr = mix(intensity, lightMapClr, lightMapSaturation);

    if(mapContrast != 1.) sampledDiffuseColor = vec4(adjustContrast(sampledDiffuseColor.rgb, mapContrast), sampledDiffuseColor.a);
    //sampledDiffuseColor = clamp(sampledDiffuseColor, 0.0,1.0);
    //if(mapContrast != 1.) sampledDiffuseColor *= contrastMatrix( mapContrast );
    //if(mapContrast != 1.) sampledDiffuseColor *= saturationMatrix( mapContrast );

    vec3 lightMapHsv = rgb2hsv(lightMapClr);
    float saturation = lightMapHsv.y;

    float mixVal = saturation;
    
    float value = pow(lightMapHsv.z, 0.05);
    float darkness = 1. - value;

     lightMapHsv.y = mix(lightMapHsv.y, lightMapHsv.y * 5., darkness * 1.75);
    
    lightMapHsv = hsv2rgb(lightMapHsv);

    // blend the lightmap color towards the diffuse color the more light this spot receives
    lightMapHsv = mix(lightMapHsv, lightMapHsv * normalize(sampledDiffuseColor.rgb) * length(sampledDiffuseColor.rgb), value);

    mixVal += darkness * 0.2;
    
    lightMapClr = pow(
        mix(lightMapClr, lightMapHsv, mixVal),
        vec3(1.25)
    );

    float lightnessFactor = pow(lightMapHsv.z, 0.1);

    diffuseColor *= lightnessFactor * sampledDiffuseColor * vec4(lightMapClr, 1.0);
    diffuseColor.a = 1.0;

} else {
    diffuseColor *= sampledDiffuseColor;
}
#endif
`
);
ShaderChunk.map_fragment.replace("diffuseColor *= sampledDiffuseColor;", new_map_fragment);
var lights_pars_begin = ShaderChunk.lights_pars_begin.replace(
  "vec3 irradiance = ambientLightColor;",
  /* glsl */
  `
    vec3 irradiance = vec3(0.0);
    if(enableESL) {
        ${aoCode}
        aoMapClr *= aoMapClr;
        irradiance = mix( ambientLightColor, aoColor * 15.0 * ((aoMapClr - 1.0) * 0.28 + 1.0), 1.0 - aoMapClr );
    } else {
        irradiance = ambientLightColor;
    }
    `
);
var lights_fragment_maps = ShaderChunk.lights_fragment_maps.replace("irradiance += lightMapIrradiance;", "if(!enableESL) irradiance += lightMapIrradiance;");
var toFloat32 = (number) => {
  let float32 = Math.fround(number).toString();
  if (!float32.includes(".")) float32 += ".";
  return float32;
};
var toVec3 = (color) => {
  return "vec3(" + toFloat32(color.r) + ", " + toFloat32(color.g) + ", " + toFloat32(color.b) + ")";
};
function EnhanceLighting(shader, {
  enableESL = true,
  useLegacyLights = false,
  aoColor = new Color(0),
  hemisphereColor = new Color(16777215),
  irradianceColor = new Color(16777215),
  radianceColor = new Color(16777215),
  aoPower = 1,
  aoSmoothing = 0,
  aoMapGamma = 1,
  lightMapGamma = 1,
  lightMapSaturation = 1,
  envPower = 1,
  roughnessPower = 1,
  sunIntensity = 0,
  mapContrast = 1,
  lightMapContrast = 1,
  smoothingPower = 0.25,
  irradianceIntensity = Math.PI,
  radianceIntensity = 1,
  hardcodeValues = false
} = {}) {
  if (shader.defines && shader.fragmentShader.includes("#define ENHANCE_SHADER_LIGHTING")) return;
  if (shader.defines === void 0) shader.defines = {};
  shader.defines.ENHANCE_SHADER_LIGHTING = "";
  if (hardcodeValues) {
    shader.fragmentShader = shader.fragmentShader.replace(
      "uniform float opacity;",
      /* glsl */
      `
            uniform float opacity;
            
            const vec3 aoColor = ${toVec3(aoColor)};
            const vec3 hemisphereColor = ${toVec3(hemisphereColor)};
            const vec3 irradianceColor = ${toVec3(irradianceColor)};
            const vec3 radianceColor = ${toVec3(radianceColor)};

            const float aoPower = ${toFloat32(aoPower)};
            const float aoSmoothing = ${toFloat32(aoSmoothing)};
            const float aoMapGamma = ${toFloat32(aoMapGamma)};
            const float lightMapGamma = ${toFloat32(lightMapGamma)};
            const float lightMapSaturation = ${toFloat32(lightMapSaturation)};
            const float envPower = ${toFloat32(envPower)};
            const float roughnessPower = ${toFloat32(roughnessPower)};
            const float sunIntensity = ${toFloat32(sunIntensity)};
            const float mapContrast = ${toFloat32(mapContrast)};
            const float lightMapContrast = ${toFloat32(lightMapContrast)};
            const float smoothingPower = ${toFloat32(smoothingPower)};
            const float irradianceIntensity = ${toFloat32(irradianceIntensity)};
            const float radianceIntensity = ${toFloat32(radianceIntensity)};
            `
    );
  } else {
    shader.uniforms.aoColor = { value: aoColor };
    shader.uniforms.hemisphereColor = { value: hemisphereColor };
    shader.uniforms.irradianceColor = { value: irradianceColor };
    shader.uniforms.radianceColor = { value: radianceColor };
    shader.uniforms.enableESL = { value: enableESL };
    shader.uniforms.useLegacyLights = { value: useLegacyLights };
    shader.uniforms.aoPower = { value: aoPower };
    shader.uniforms.aoSmoothing = { value: aoSmoothing };
    shader.uniforms.lightMapGamma = { value: lightMapGamma };
    shader.uniforms.lightMapSaturation = { value: lightMapSaturation };
    shader.uniforms.aoMapGamma = { value: aoMapGamma };
    shader.uniforms.envPower = { value: envPower };
    shader.uniforms.smoothingPower = { value: smoothingPower };
    shader.uniforms.roughnessPower = { value: roughnessPower };
    shader.uniforms.sunIntensity = { value: sunIntensity };
    shader.uniforms.mapContrast = { value: mapContrast };
    shader.uniforms.lightMapContrast = { value: lightMapContrast };
    shader.uniforms.irradianceIntensity = { value: irradianceIntensity };
    shader.uniforms.radianceIntensity = { value: radianceIntensity };
    shader.fragmentShader = shader.fragmentShader.replace(
      "uniform float opacity;",
      /* glsl */
      `
            uniform float opacity;
            
            uniform vec3 aoColor;
            uniform vec3 hemisphereColor;
            uniform vec3 irradianceColor;
            uniform vec3 radianceColor;

            uniform bool enableESL;
            uniform bool useLegacyLights;

            uniform float aoPower;
            uniform float aoSmoothing;
            uniform float aoMapGamma;
            uniform float lightMapGamma;
            uniform float lightMapSaturation;
            uniform float envPower;
            uniform float roughnessPower;
            uniform float sunIntensity;
            uniform float mapContrast;
            uniform float lightMapContrast;
            uniform float smoothingPower;
            uniform float irradianceIntensity;
            uniform float radianceIntensity;

            #define ENHANCE_SHADER_LIGHTING
            ${shaderFunctions}
            `
    );
  }
  shader.fragmentShader = shader.fragmentShader.replace(
    "main() {",
    `
            main() {
            ${aoCode}
            `
  ).replace("#include <aomap_fragment>", aomap_fragment).replace("#include <lights_pars_begin>", lights_pars_begin).replace("#include <lights_fragment_maps>", lights_fragment_maps).replace("#include <map_fragment>", new_map_fragment).replace("#include <envmap_physical_pars_fragment>", ShaderChunk.envmap_physical_pars_fragment).replace(
    "getIBLIrradiance( const in vec3 normal )",
    "getIBLIrradiance( const in vec3 normal, float aoMapClr )"
  ).replace(
    "getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness )",
    "getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, float aoMapClr )"
  ).replace("return PI * envMapColor.rgb * envMapIntensity;", getIBLIrradiance_replace).replace("return envMapColor.rgb * envMapIntensity;", getIBLRadiance_replace).replace(
    "#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )",
    /* glsl */
    `
            //#include <aomap_fragment>
            #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
            `
  ).replace(
    "iblIrradiance += getIBLIrradiance( geometryNormal );",
    "iblIrradiance += getIBLIrradiance( geometryNormal, aoMapClr );"
  ).replace(
    "radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );",
    "radiance += getIBLRadiance( geometryViewDir, geometryNormal, pow(material.roughness, enableESL ? roughnessPower : 1.0), aoMapClr );"
  ).replace(
    "clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );",
    "clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, pow(material.clearcoatRoughness, enableESL ? roughnessPower : 1.0), aoMapClr );"
  );
}
var FakeGlowMaterial = class extends ShaderMaterial {
  /**
   * Create a FakeGlowMaterial.
   *
   * @param {Object} parameters - The parameters to configure the material.
   * @param {number} [parameters.falloff=0.1] - The falloff factor for the glow effect.
   * @param {number} [parameters.glowInternalRadius=6.0] - The internal radius for the glow effect.
   * @param {Color} [parameters.glowColor=new Color('#00d5ff')] - The color of the glow effect.
   * @param {number} [parameters.glowSharpness=0.5] - The sharpness of the glow effect.
   * @param {number} [parameters.opacity=1.0] - The opacity of the hologram.
   * @param {number} [parameters.side=THREE.FrontSide] - The rendering side. Use `THREE.FrontSide`, `THREE.BackSide`, or `THREE.DoubleSide`.
   * @param {boolean} [parameters.depthTest=false] - Enable or disable depth testing.
   */
  constructor(parameters = {}) {
    super();
    this.vertexShader = /*GLSL */
    `
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * viewMatrix * modelPosition;
        vec4 modelNormal = modelMatrix * vec4(normal, 0.0);
        vPosition = modelPosition.xyz;
        vNormal = modelNormal.xyz;

      }
    `;
    this.fragmentShader = /*GLSL */
    `
      uniform vec3 glowColor;
      uniform float falloff;
      uniform float glowSharpness;
      uniform float glowInternalRadius;
      uniform float opacity;

      varying vec3 vPosition;
      varying vec3 vNormal;

      void main()
      {
        // Normal
        vec3 normal = normalize(vNormal);
        if(!gl_FrontFacing)
            normal *= - 1.0;
        vec3 viewDirection = normalize(cameraPosition - vPosition);
        float fresnel = dot(viewDirection, normal);
        fresnel = pow(fresnel, glowInternalRadius + 0.1);
        float falloff = smoothstep(0., falloff, fresnel);
        float fakeGlow = fresnel;
        fakeGlow += fresnel * glowSharpness;
        fakeGlow *= falloff;
        gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., opacity));

        #include <tonemapping_fragment>
        #include <colorspace_fragment>
      } 
      `;
    this.uniforms = {
      /**
       * The opacity for the glow effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      opacity: new Uniform(parameters.opacity !== void 0 ? parameters.opacity : 1),
      /**
       * The strength of the glowInternalRadius.
       * @type {Uniform<number>}
       * @default 6.0
       */
      glowInternalRadius: new Uniform(parameters.glowInternalRadius !== void 0 ? parameters.glowInternalRadius : -2),
      //6.0
      /**
       * The glowSharpness.
       * @type {Uniform<number>}
       * @default 0.5
       */
      glowSharpness: new Uniform(parameters.glowSharpness !== void 0 ? parameters.glowSharpness : 0),
      //0.5
      /**
       * The falloff.
       * @type {Uniform<number>}
       * @default 0.1
       */
      falloff: new Uniform(parameters.falloff !== void 0 ? parameters.falloff : 0),
      //0.1
      /**
       * The color of the glow.
       * @type {Uniform<Color>}
       * @default new Color(#00d5ff)
       */
      glowColor: new Uniform(parameters.glowColor !== void 0 ? new Color(parameters.glowColor) : new Color("#202020"))
    };
    this.setValues(parameters);
    this.blending = parameters.blendMode !== void 0 ? parameters.blendMode : AdditiveBlending;
    this.transparent = true;
    this.side = parameters.side !== void 0 ? parameters.side : FrontSide;
    this.polygonOffset = true;
    this.polygonOffsetFactor = -1;
    this.polygonOffsetUnits = 1;
    this.premultipliedAlpha = true;
  }
};
var mat = {};
var TmpMat = [];
var matExtra = {
  //clearcoat:1.0,
  //clearcoatRoughness:0.1,
  metalness: 0,
  roughness: 0.2
  //normalScale: new Vector2(0.25,0.25),
};
var RealismLightOption = {
  enableESL: true,
  exposure: 1,
  envMapIntensity: 1,
  aoColor: new Color(0),
  hemisphereColor: new Color(16777215),
  irradianceColor: new Color(16777215),
  radianceColor: new Color(16777215),
  aoPower: 9.7,
  //6,
  aoSmoothing: 0.26,
  aoMapGamma: 0.89,
  lightMapGamma: 0.9,
  //1,
  lightMapSaturation: 1,
  envPower: 1,
  //2
  roughnessPower: 1,
  //1.45,
  sunIntensity: 0,
  mapContrast: 1,
  //0.93,
  lightMapContrast: 1.03,
  smoothingPower: 0.76,
  irradianceIntensity: 6.59,
  radianceIntensity: 4.62,
  hardcodeValues: false
};
var Colors = {
  body: new Color(15724500),
  sleep: new Color(10469309),
  //0xBFBFBD
  solid: new Color(7105128),
  base: new Color(13224135),
  black: new Color(2236962),
  gold: new Color(0.944, 0.776, 0.373),
  gold2: new Color(0.998, 0.981, 0.751),
  copper: new Color(0.96467984, 0.37626296, 0.25818297),
  carPaint: new Color(0.1037792, 0.59212029, 0.85064936),
  clay: new Color(0.604, 0.584, 0.497),
  concrete: new Color(11119017)
};
var ThreeVariable = {
  No: NoBlending,
  Normal: NormalBlending,
  Additive: AdditiveBlending,
  Subtractive: SubtractiveBlending,
  Multiply: MultiplyBlending,
  Eadd: AddEquation,
  Esub: SubtractEquation,
  Erev: ReverseSubtractEquation,
  Emin: MinEquation,
  Emaw: MaxEquation,
  Fzero: ZeroFactor,
  Fone: OneFactor,
  Fcolor: SrcColorFactor,
  Fcolorm: OneMinusSrcColorFactor,
  Falpha: SrcAlphaFactor,
  Falpham: OneMinusSrcAlphaFactor,
  Fdstalpha: DstAlphaFactor,
  Fdstalpham: OneMinusDstAlphaFactor,
  Fdstcolor: DstColorFactor,
  Fdstcolorm: OneMinusDstColorFactor,
  Falphasaturate: SrcAlphaSaturateFactor,
  // ! not for destination
  Front: FrontSide,
  Back: BackSide,
  Double: DoubleSide
};
var addRenderMode = () => {
  let s = ShaderChunk.common;
  s = s.replace("#define EPSILON 1e-6", `
		#define EPSILON 1e-6
		uniform int renderMode;
		uniform int depthPacking;
		varying vec2 vZW;
    `);
  ShaderChunk.common = s;
  ShaderChunk.clipping_planes_vertex = `
        #if NUM_CLIPPING_PLANES > 0
            vClipPosition = - mvPosition.xyz;
        #endif
        vZW = gl_Position.zw;
    `;
  s = ShaderChunk.dithering_fragment;
  s = s.replace("#endif", `
		#endif

        #ifdef STANDARD

        if( renderMode == 1 ){ // depth render
            float fz = 0.5 * vZW[0] / vZW[1] + 0.5;
            fz=pow(fz, 10.0);
            gl_FragColor = depthPacking == 1 ? packDepthToRGBA( fz ) : vec4( vec3( 1.0 - fz ), opacity );
        }
        if( renderMode == 2 ) gl_FragColor = vec4(  packNormalToRGB( normal ), opacity );// normal render
        //if( renderMode == 3 ) gl_FragColor = vec4(  shadowColor, opacity );// normal render

        #else

        if( renderMode != 0 ) discard;

        #endif
    `);
  ShaderChunk.dithering_fragment = s;
};
var Mat = {
  renderMode: { value: 0 },
  depthPacking: { value: 0 },
  isRealism: false,
  realismOption: {},
  envMapIntensity: 1,
  changeRenderMode: (n2) => {
    Mat.renderMode.value = n2;
  },
  initExtandShader: () => {
    addRenderMode();
  },
  useRealLight: (o) => {
    Mat.isRealism = true;
    for (let c in o) {
      if (c.search("Color") !== -1) {
        if (!o[c].isColor) {
          RealismLightOption[c].set(o[c]);
          delete o[c];
        }
      }
    }
    Mat.realismOption = { ...RealismLightOption, ...o };
  },
  setColor: (o) => {
    if (!Mat.isRealism) return;
    RealismLightOption.aoColor.set(o.minLuma).convertLinearToSRGB();
    RealismLightOption.hemisphereColor.set(o.maxLuma).convertLinearToSRGB();
    RealismLightOption.irradianceColor.set(o.sun).convertLinearToSRGB();
    RealismLightOption.radianceColor.set(o.vibrant).convertLinearToSRGB();
  },
  set: (m2, direct, beforeCompile = null) => {
    if (!beforeCompile) beforeCompile = m2.onBeforeCompile;
    if (!direct) Mat.extendShader(m2, beforeCompile);
    mat[m2.name] = m2;
  },
  extendShader: (m2, beforeCompile = null) => {
    if (Mat.isRealism) {
      m2.onBeforeCompile = function(shader) {
        shader.uniforms.renderMode = Mat.renderMode;
        shader.uniforms.depthPacking = Mat.depthPacking;
        EnhanceLighting(shader, Mat.realismOption);
        m2.userData.isRealism = true;
        m2.userData.shader = shader;
        if (beforeCompile) beforeCompile(shader);
      };
    } else {
      m2.onBeforeCompile = function(shader) {
        shader.uniforms.renderMode = Mat.renderMode;
        shader.uniforms.depthPacking = Mat.depthPacking;
        if (beforeCompile) beforeCompile(shader);
        m2.userData.shader = shader;
      };
    }
  },
  addToTmp: (m2) => {
    TmpMat.push(m2);
  },
  create: (o) => {
    let m2, beforeCompile = null;
    if (o.isMaterial) {
      m2 = o;
    } else {
      let type = o.type !== void 0 ? o.type : "Standard";
      if (o.type) delete o.type;
      beforeCompile = o.beforeCompile || null;
      if (o.beforeCompile) delete o.beforeCompile;
      if (o.thickness || o.sheen || o.clearcoat || o.transmission || o.specularColor) type = "Physical";
      if (o.normalScale) {
        if (!o.normalScale.isVector2) o.normalScale = new Vector2().fromArray(o.normalScale);
      }
      if (o.side) o.side = Mat.findValue(o.side);
      if (o.shadowSide) o.shadowSide = Mat.findValue(o.shadowSide);
      if (o.blending) o.blending = Mat.findValue(o.blending);
      if (o.blendEquation) o.blendEquation = Mat.findValue(o.blendEquation);
      if (o.blendEquationAlpha) o.blendEquationAlpha = Mat.findValue(o.blendEquationAlpha);
      if (o.blendSrc) o.blendSrc = Mat.findValue(o.blendSrc);
      if (o.blendDst) o.blendDst = Mat.findValue(o.blendDst);
      if (o.blendDstAlpha) o.blendDstAlpha = Mat.findValue(o.blendDstAlpha);
      if (o.blendSrcAlpha) o.blendSrcAlpha = Mat.findValue(o.blendSrcAlpha);
      if (o.clearcoatNormalScale) {
        if (!o.clearcoatNormalScale.isVector2) o.clearcoatNormalScale = new Vector2().fromArray(o.clearcoatNormalScale);
      }
      type = type.toLowerCase();
      switch (type) {
        case "physical":
          m2 = new MeshPhysicalMaterial(o);
          m2.defines = {
            "STANDARD": "",
            "PHYSICAL": "",
            "USE_UV": "",
            "USE_SPECULAR": ""
          };
          break;
        case "phong":
          m2 = new MeshPhongMaterial(o);
          break;
        case "lambert":
          m2 = new MeshLambertMaterial(o);
          break;
        case "basic":
          m2 = new MeshBasicMaterial(o);
          break;
        case "line":
          m2 = new LineBasicMaterial(o);
          break;
        case "toon":
          m2 = new MeshToonMaterial(o);
          break;
        case "shadow":
          m2 = new ShadowMaterial(o);
          break;
        case "sss":
          m2 = new MeshSssMaterial(o);
          break;
        default:
          m2 = new MeshStandardMaterial(o);
          break;
      }
      Mat.upEnvmapIntensity(m2);
    }
    if (mat[m2.name]) return null;
    Mat.set(m2, false, beforeCompile);
    return m2;
  },
  findValue: (v) => v === "string" ? ThreeVariable[v.charAt(0).toUpperCase() + v.slice(1)] : v,
  addToMat: (o) => {
    if (Mat.isRealism) {
      for (let m2 in o) {
        o[m2].shadowSide = DoubleSide;
        o[m2].onBeforeCompile = function(shader) {
          EnhanceLighting(shader, Mat.realismOption);
          o[m2].userData.isRealism = true;
          o[m2].userData.shader = shader;
        };
      }
    }
    mat = { ...mat, ...o };
  },
  changeType: () => {
  },
  directIntensity: (v) => {
  },
  setEnvmapIntensity: (v) => {
  },
  upEnvmapIntensity: (m2) => {
  },
  getList: () => {
    let l = { ...mat };
    const ignor = ["line", "debug", "hide", "svg"];
    let i = ignor.length;
    while (i--) delete l[ignor[i]];
    return l;
  },
  get: (name) => {
    if (!mat[name]) {
      switch (name) {
        case "body":
          Mat.create({ name: "body", color: Colors.body, ...matExtra });
          break;
        //case 'body':   m = new MeshStandardMaterial({ color:Colors.body, ...matExtra }); break//0xFFF1D2
        case "sleep":
          Mat.create({ name: "sleep", color: Colors.sleep, ...matExtra });
          break;
        //0x46B1C9
        case "solid":
          Mat.create({ name: "solid", color: Colors.solid, metalness: 0.1, roughness: 0.8 });
          break;
        case "clay":
          Mat.create({ name: "clay", color: Colors.clay, metalness: 0, roughness: 0.9 });
          break;
        case "base":
          Mat.create({ name: "base", color: Colors.base, ...matExtra });
          break;
        case "concrete":
          Mat.create({ name: "concrete", color: Colors.concrete, metalness: 0, roughness: 0.9 });
          break;
        case "black":
          Mat.create({ name: "black", color: Colors.black, metalness: 0, roughness: 0.25 });
          break;
        // metal
        case "chrome":
          Mat.create({ name: "chrome", color: 13421772, metalness: 1, roughness: 0.075 });
          break;
        case "silver":
          Mat.create({ name: "silver", color: 11184810, metalness: 0.8, roughness: 0.22 });
          break;
        case "gold":
          Mat.create({ name: "gold", color: Colors.gold, specularColor: Colors.gold2, metalness: 1, roughness: 0.02 });
          break;
        case "copper":
          Mat.create({ name: "copper", color: Colors.copper, metalness: 1, roughness: 0.25, clearcoat: 1, clearcoatRoughness: 0.2 });
          break;
        case "carPaint":
          Mat.create({ name: "carPaint", color: Colors.carPaint, metalness: 0, anisotropy: new Vector2(0.5, 0.5), roughness: 0.4, clearcoat: 1, clearcoatRoughness: 0 });
          break;
        //case 'simple': m = Mat.create({ name:'simple', color:0x808080, metalness: 0, roughness: 1 }); break
        case "carbon":
          Mat.create({ name: "carbon", map: new CarbonTexture(), normalMap: new CarbonTexture(true), clearcoat: 1, clearcoatRoughness: 0.1, roughness: 0.5 });
          break;
        case "cloth":
          Mat.create({ name: "cloth", color: 8391119, roughness: 0.5, sheenColor: 13335807, sheen: 1, sheenRoughness: 0.2 });
          break;
        //case 'clear':  m = new MeshStandardMaterial({ color:0xFFFFFF, metalness: 0.5, roughness: 0 }); break
        //case 'wood':   m = Mat.create({ name:'wood', color:0xe8c2a1, metalness: 0, roughness: 1 }); break
        //case 'hero':   m = new MeshStandardMaterial({ color:0x00FF88, ...matExtra }); break
        case "skinny":
          Mat.create({ name: "skinny", color: 14724201, ...matExtra });
          break;
        case "glass":
          Mat.create({ name: "glass", color: 16777215, transparent: true, roughness: 0.02, metalness: 0, side: DoubleSide, alphaToCoverage: true, premultipliedAlpha: true, transmission: 1, clearcoat: 1, thickness: 0.01 });
          break;
        case "glassX":
          Mat.create({ name: "glassX", color: 15658734, transparent: false, opacity: 1, roughness: 0.03, metalness: 0, side: DoubleSide, transmission: 1, clearcoat: 1, clearcoatRoughness: 0, thickness: 0.02, ior: 1.52, shadowSide: 1, reflectivity: 0.5, iridescence: 0 });
          break;
        case "plexi":
          Mat.create({ name: "plexi", blending: AdditiveBlending, color: 65793, transparent: true, opacity: 0.7, reflectivity: 0.3, metalness: 0.6, roughness: 0.1, clearcoat: 0.2, clearcoatRoughness: 0.02, side: DoubleSide, alphaToCoverage: true, premultipliedAlpha: true });
          break;
        case "plexi2":
          Mat.create({ name: "plexi2", blending: AdditiveBlending, color: 65793, transparent: false, opacity: 0.7, reflectivity: 0.3, metalness: 0.6, roughness: 0.1, clearcoat: 0.2, clearcoatRoughness: 0.02, side: DoubleSide, alphaToCoverage: false, premultipliedAlpha: true });
          break;
        case "glass2":
          Mat.create({ name: "glass2", color: 15658734, transparent: true, roughness: 0, alphaToCoverage: true, opacity: 0.3 });
          break;
        case "glass3":
          Mat.create({ name: "glass3", color: 0, transparent: true, roughness: 0, alphaToCoverage: true, opacity: 0.4 });
          break;
        case "glass_red":
          Mat.create({ name: "glass_red", color: 16711680, transparent: true, roughness: 0, alphaToCoverage: true, opacity: 0.8 });
          break;
        case "car":
          Mat.create({ name: "car", color: 3158064, metalness: 1, roughness: 0.5, clearcoat: 1, clearcoatRoughness: 0.03, sheen: 0.5 });
          break;
        case "carGlass":
          Mat.create({ name: "carGlass", color: 16777215, metalness: 0, roughness: 0, transmission: 1, ior: 1.52 });
          break;
        case "outline":
          if (!mat["outline"]) mat["outline"] = outliner;
          mat["outline"];
          break;
        case "debug":
          Mat.create({ name: "debug", type: "Basic", color: 15953986, wireframe: true, toneMapped: false, transparent: true, opacity: 0.5 });
          break;
        //case 'debug': m = Mat.create({ name:'debug', color:0xF37042, wireframe:true, toneMapped: false, transparent:true, opacity:0.5 }); break
        //case 'debug2': m = Mat.create({ name:'debug2', type:'Basic', color:0x00FFFF, wireframe:true, toneMapped: false }); break
        //case 'debug3':  m = Mat.create({ name:'debug3', type:'Basic', color:0x000000, wireframe:true, transparent:true, opacity:0.1, toneMapped: false }); break
        //case 'shadows': m = Mat.create({ name:'shadows', type:'Basic', transparent:true, opacity:0.01 }); break
        //case 'simple': m = Mat.create({ name:'simple', type:'basic'  }); break
        case "shadow":
          Mat.create({ name: "shadow", type: "shadow", color: 0, opacity: 0.5 });
          break;
        case "bones":
          Mat.create({ name: "bones", color: 16639958, wireframe: true });
          break;
        case "bones2":
          Mat.create({ name: "bones2", type: "basic", color: 14664872, transparent: true, opacity: 0.5, depthTest: true, depthWrite: false, alphaToCoverage: true });
          break;
        case "button":
          Mat.create({ name: "button", color: 16728139, ...matExtra });
          break;
        //case 'hide': m = new MeshBasicMaterial({ visible:false }); break
        case "line":
          Mat.create({ name: "line", type: "line", vertexColors: true, toneMapped: false });
          break;
        case "liner":
          Mat.create({ name: "liner", type: "line", vertexColors: true, toneMapped: false, depthTest: true, depthWrite: true, alphaToCoverage: true });
          break;
        case "hide":
          Mat.create({ name: "hide", type: "basic", visible: false });
          break;
        case "particle":
          Mat.create({ name: "particle", type: "basic", toneMapped: false, color: 65280 });
          break;
        case "svg":
          Mat.create({ name: "svg", type: "basic", toneMapped: false, vertexColors: true, transparent: false, side: DoubleSide });
          break;
      }
    }
    return mat[name];
  },
  dispose: () => {
    Mat.isRealism = false;
    for (let m2 in mat) {
      mat[m2].dispose();
      delete mat[m2];
    }
    let i = TmpMat.length;
    while (i--) {
      TmpMat[i].dispose();
    }
    TmpMat = [];
  },
  upShader: () => {
    let option = Mat.realismOption;
    for (let name in mat) {
      const m2 = mat[name];
      const shader = m2.userData.shader;
      for (let o in option) {
        if (shader) {
          if (shader.uniforms[o] !== void 0) shader.uniforms[o].value = option[o];
        }
        if (m2[o]) m2[o] = option[o];
      }
    }
  }
};
var outliner = new FakeGlowMaterial();
var Timer = class {
  constructor(framerate = -1) {
    this.perf = window.performance;
    this.time = { now: 0, delta: 0, then: 0, interval: 0, tmp: 0, n: 0, dt: 0 };
    this.fps = 0;
    this.delta = 0;
    this.elapsedTime = 0;
    this.unlimited = false;
    this.setFramerate(framerate);
    this.force = false;
  }
  up(stamp) {
    let t2 = this.time;
    if (this.unlimited) this.force = true;
    t2.now = stamp !== void 0 ? stamp : this.now();
    t2.delta = t2.now - t2.then;
    if (this.force) {
      t2.delta = t2.interval;
      this.force = false;
    }
    if (t2.delta >= t2.interval || this.unlimited) {
      t2.then = this.unlimited ? t2.now : t2.now - t2.delta % t2.interval;
      this.delta = t2.interval * 1e-3;
      this.elapsedTime += this.delta;
      return true;
    }
    return false;
  }
  setFramerate(framerate) {
    this.elapsedTime = 0;
    this.framerate = framerate;
    this.unlimited = this.framerate < 0;
    this.time.interval = 1e3 / framerate;
    if (framerate === 60) this.time.interval = 16.67;
  }
  static now() {
    return this.perf ? this.perf.now() : Date.now();
  }
  static format_time(time) {
    if (time > 1e3) return time / 1e3 + " sec";
    return time + " ms";
  }
};
var User = class {
  // key map
  // 0 : axe L | left:right  -1>1
  // 1 : axe L | top:down    -1>1
  // 2 : axe R | left:right  -1>1
  // 3 : axe R | top:down    -1>1
  // 4 : bouton A             0-1  jump / space
  // 5 : bouton B             0-1  roulade / shift ctrl
  // 6 : bouton X             0-1  arme principale / E
  // 7 : bouton Y             0-1  arme secondaire
  // 8 : gachette L up        0-1  
  // 9 : gachette R up        0-1
  // 10 : gachette L down     0>1
  // 11 : gachette R down     0>1
  // 12 : bouton setup        0-1
  // 13 : bouton menu         0-1
  // 14 : axe button left     0-1
  // 15 : axe button right    0-1
  // 16 : Xcross axe top      0-1
  // 17 : Xcross axe down     0-1
  // 18 : Xcross axe left     0-1
  // 19 : Xcross axe right    0-1
  // 20 : Keyboard or Gamepad    0-1
  constructor() {
    this.key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.key2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.gamepad = new Gamepad(this.key);
    this.useGamepad = false;
    this.sameAxis = true;
    document.addEventListener("keydown", (function(e) {
      this.keyDown(e);
    }).bind(this), false);
    document.addEventListener("keyup", (function(e) {
      this.keyUp(e);
    }).bind(this), false);
  }
  setKey(i, v) {
    this.key[i] = v;
  }
  update() {
    this.gamepad.update();
    if (this.gamepad.ready) {
      if (!this.useGamepad) this.useGamepad = true;
      this.gamepad.getValue(0);
    }
    if (this.sameAxis) {
      this.key[2] = this.key[0];
      this.key[3] = this.key[1];
    }
    return this.key;
  }
  keyDown(e) {
    var key = this.key;
    var key2 = this.key2;
    e = e || window.event;
    if (this.sameAxis) {
      switch (e.which) {
        // axe L
        case 65:
        case 81:
        case 37:
          key[0] = -1;
          key2[0] = 1;
          break;
        //key[0]<=-1 ? -1:key[0]-= 0.1; break; // left, A, Q
        case 68:
        case 39:
          key[0] = 1;
          key2[1] = 1;
          break;
        // right, D
        case 87:
        case 90:
        case 38:
          key[1] = -1;
          break;
        // up, W, Z
        case 83:
        case 40:
          key[1] = 1;
          break;
        // down, S
        case 32:
          key[4] = 1;
          break;
        // space
        case 17:
        case 67:
          key[5] = 1;
          break;
        // ctrl, C
        case 69:
          key[6] = 1;
          break;
        // E
        case 16:
          key[7] = 1;
          break;
      }
    } else {
      switch (e.which) {
        // axe L
        case 65:
        case 81:
          key[0] = -1;
          key2[0] = 1;
          break;
        //key[0]<=-1 ? -1:key[0]-= 0.1; break; // left, A, Q
        case 68:
          key[0] = 1;
          key2[1] = 1;
          break;
        // right, D
        case 87:
        case 90:
          key[1] = -1;
          break;
        // up, W, Z
        case 83:
          key[1] = 1;
          break;
        // down, S
        // axe R
        case 37:
          key[2] = -1;
          key2[0] = 1;
          break;
        // left
        case 39:
          key[2] = 1;
          key2[1] = 1;
          break;
        // right
        case 38:
          key[3] = -1;
          break;
        // up
        case 40:
          key[3] = 1;
          break;
        // down
        case 32:
          key[4] = 1;
          break;
        // space
        case 17:
        case 67:
          key[5] = 1;
          break;
        // ctrl, C
        case 69:
          key[6] = 1;
          break;
        // E
        case 16:
          key[7] = 1;
          break;
      }
    }
    this.gamepad.reset();
  }
  keyUp(e) {
    var key = this.key;
    var key2 = this.key2;
    e = e || window.event;
    if (this.sameAxis) {
      switch (e.which) {
        // axe L
        case 65:
        case 81:
        case 37:
          key[0] = key[0] < 0 ? 0 : key[0];
          key2[0] = 0;
          break;
        // left, A, Q
        case 68:
        case 39:
          key[0] = key[0] > 0 ? 0 : key[0];
          key2[1] = 0;
          break;
        // right, D
        case 87:
        case 90:
        case 38:
          key[1] = key[1] < 0 ? 0 : key[1];
          break;
        // up, W, Z
        case 83:
        case 40:
          key[1] = key[1] > 0 ? 0 : key[1];
          break;
        // down, S
        case 32:
          key[4] = 0;
          break;
        // space
        case 17:
        case 67:
          key[5] = 0;
          break;
        // ctrl, C
        case 69:
          key[6] = 0;
          break;
        // E
        case 16:
          key[7] = 0;
          break;
      }
    } else {
      switch (e.which) {
        // axe L
        case 65:
        case 81:
          key[0] = key[0] < 0 ? 0 : key[0];
          key2[0] = 0;
          break;
        // left, A, Q
        case 68:
          key[0] = key[0] > 0 ? 0 : key[0];
          key2[1] = 0;
          break;
        // right, D
        case 87:
        case 90:
          key[1] = key[1] < 0 ? 0 : key[1];
          break;
        // up, W, Z
        case 83:
          key[1] = key[1] > 0 ? 0 : key[1];
          break;
        // down, S
        // axe R
        case 37:
          key[2] = key[2] < 0 ? 0 : key[2];
          key2[0] = 0;
          break;
        // left
        case 39:
          key[2] = key[2] > 0 ? 0 : key[2];
          key2[1] = 0;
          break;
        // right
        case 38:
          key[3] = key[3] < 0 ? 0 : key[3];
          break;
        // up
        case 40:
          key[3] = key[3] > 0 ? 0 : key[3];
          break;
        // down
        case 32:
          key[4] = 0;
          break;
        // space
        case 17:
        case 67:
          key[5] = 0;
          break;
        // ctrl, C
        case 69:
          key[6] = 0;
          break;
        // E
        case 16:
          key[7] = 0;
          break;
      }
    }
  }
};
var Gamepad = class {
  constructor(key) {
    this.values = [];
    this.ready = 0;
    this.key = key;
  }
  update() {
    var i, j, k, l, v, pad;
    var fix = this.fix;
    var gamepads = navigator.getGamepads();
    for (i = 0; i < gamepads.length; i++) {
      pad = gamepads[i];
      if (pad) {
        k = pad.axes.length;
        l = pad.buttons.length;
        if (l) {
          if (!this.values[i]) this.values[i] = [];
          for (j = 0; j < k; j++) {
            v = fix(pad.axes[j], 0.08);
            if (this.ready == 0 && v !== 0) this.ready = 1;
            this.values[i][j] = v;
          }
          for (j = 0; j < l; j++) {
            v = fix(pad.buttons[j].value);
            if (this.ready == 0 && v !== 0) this.ready = 1;
            this.values[i][k + j] = v;
          }
        } else {
          if (this.values[i]) this.values[i] = null;
        }
      }
    }
  }
  getValue(n2) {
    var i = 19, v;
    while (i--) {
      v = this.values[n2][i];
      if (this.ready == 0 && v !== 0) this.ready = 1;
      this.key[i] = v;
    }
  }
  reset() {
    this.ready = 0;
  }
  fix(v, dead) {
    let n2 = Number(v.toString().substring(0, 5));
    if (dead && n2 < dead && n2 > -dead) n2 = 0;
    return n2;
  }
};
var Item = class {
  constructor() {
    this.id = 0;
    this.list = [];
    this.type = "item";
    this.Utils = null;
  }
  reset() {
    let i = this.list.length;
    while (i--) this.dispose(this.list[i]);
    this.list = [];
    this.id = 0;
  }
  ///
  byName(name) {
    return this.Utils.byName(name);
  }
  setName(o = {}) {
    let name = o.name !== void 0 ? o.name : this.type + this.id++;
    o.id = this.remove(name, true);
    o.name = name;
    return name;
  }
  addToWorld(b, id = -1) {
    this.Utils.add(b);
    if (id !== -1) this.list[id] = b;
    else this.list.push(b);
  }
  remove(name, remplace) {
    let b = this.byName(name);
    if (!b) return -1;
    return this.clear(b, remplace);
  }
  clear(b, remplace) {
    let n2 = this.list.indexOf(b);
    if (n2 !== -1 && !remplace) this.list.splice(n2, 1);
    else this.list[n2] = null;
    this.dispose(b);
    return n2;
  }
  dispose(b) {
    if (b !== null) this.Utils.remove(b);
  }
  add(o = {}) {
  }
  set(o = {}) {
  }
  step(AR, N) {
  }
  // ARRAY MATH TOOL
  /*
      vecZero ( ar, n, i ) { while ( i-- ) ar[n+i] = 0; }
  
      fillArray ( ar, ar2, n, i ) { 
  
      	n = n || 0;
      	i = i ?? ar.length;
      	while( i-- ) ar2[n+i] = ar[i];
  
      }
  
      arLength ( ar ) { 
  
      	let v = Math.sqrt( ar[0] * ar[0] + ar[1] * ar[1] + ar[2] * ar[2] );
      	if( v < 0.001 ) v = 0;
      	return v;
  
      }
  
      multiplyScalar ( ar, v, i ) { 
  
      	i = i ?? ar.length;
      	while(i--) ar[i] *= v;
  
      }
  
      divideScalar ( ar, v, i ) {
  
      	this.multiplyScalar( ar, 1/v, i );
  
      }*/
};
var Ray = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "ray";
    this.iType = "ray";
  }
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    let i = this.list.length, r, n2;
    while (i--) {
      r = this.list[i];
      n2 = N + i * Num.ray;
      r.update(AR, n2, root.reflow.ray[i] || null);
    }
  }
  add(o = {}) {
    this.setName(o);
    let r = new ExtraRay(o);
    r.visible = o.visible !== void 0 ? o.visible : true;
    this.addToWorld(r, o.id);
    if (o.parent) {
      if (typeof o.parent !== "string") o.parent = o.parent.name;
    }
    if (o.callback) delete o.callback;
    root.post({ m: "add", o });
    return r;
  }
  set(o = {}, r = null) {
    if (r === null) r = this.byName(o.name);
    if (r === null) return;
    r.setRay(o);
  }
};
var ExtraRay = class extends Line {
  constructor(o = {}) {
    super(new BufferGeometry(), Mat.get("line"));
    this.isRay = true;
    this.data = {
      hit: false,
      body: "",
      point: [0, 0, 0],
      normal: [0, 0, 0],
      distance: 0,
      angle: 0,
      parent: null
    };
    this.type = "ray";
    this.name = o.name;
    this.parentMesh = null;
    if (o.parent) {
      this.parentMesh = typeof o.parent === "string" ? Utils.byName(o.parent) : o.parent;
      this.data.parent = this.parentMesh;
    }
    this.callback = o.callback || null;
    this.c0 = [0.1, 0.1, 0.3];
    this.c1 = [0.1, 0.4, 0.6];
    this.c2 = [1, 0.1, 0.1];
    this.c3 = [0.1, 1, 0.1];
    this.begin = new Vector3();
    this.end = new Vector3(0, 1, 0);
    this.tmp = new Vector3();
    this.vnormal = new Vector3();
    this.vv1 = new Vector3();
    this.vv2 = new Vector3();
    this.fullDistance = 0;
    this.setRay(o);
    const positions = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    const colors = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.vertices = this.geometry.attributes.position;
    this.colors = this.geometry.attributes.color;
    this.local = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.matrixAutoUpdate = false;
    this.frustumCulled = false;
  }
  setRay(o) {
    if (o.begin) this.begin.fromArray(o.begin);
    if (o.end) this.end.fromArray(o.end);
    this.fullDistance = this.begin.distanceTo(this.end);
  }
  update(r, n2 = 0, body = null) {
    this.data.hit = r[n2] !== 0 ? true : false;
    this.data.body = body ? body : "";
    this.data.distance = r[n2 + 1];
    if (this.data.hit) {
      this.local[0] = r[n2 + 2];
      this.local[1] = r[n2 + 3];
      this.local[2] = r[n2 + 4];
      this.tmp.fromArray(r, n2 + 5);
      this.vnormal.fromArray(r, n2 + 8);
      this.data.point = this.tmp.toArray();
      this.data.normal = this.vnormal.toArray();
      this.tmp.toArray(this.local, 3);
      this.vv1.fromArray(this.local).sub(this.tmp).normalize();
      this.tmp.addScaledVector(this.vnormal, this.fullDistance - this.data.distance);
      this.tmp.toArray(this.local, 6);
      this.data.angle = Math.floor(MathTool.angleTo(this.vv1.toArray(), this.data.normal) * todeg$1);
    } else {
      if (this.parentMesh) {
        const mtx = this.parentMesh.matrixWorld;
        this.tmp.copy(this.begin).applyMatrix4(mtx).toArray(this.local, 0);
        this.tmp.copy(this.end).applyMatrix4(mtx);
        this.tmp.toArray(this.local, 3);
        this.tmp.toArray(this.local, 6);
      } else {
        this.begin.toArray(this.local, 0);
        this.end.toArray(this.local, 3);
        this.end.toArray(this.local, 6);
      }
    }
    this.updateGeometry();
    this.updateMatrix();
    if (this.callback) this.callback(this.data);
  }
  dispose() {
    this.callback = null;
    this.parentMesh = null;
    this.data = {};
    this.geometry.dispose();
  }
  raycast() {
    return;
  }
  updateGeometry() {
    if (!this.visible) return;
    let v = this.vertices.array;
    let c = this.colors.array;
    let l = this.local;
    let hit = this.data.hit;
    let c1 = hit ? this.c2 : this.c1;
    let c2 = hit ? this.c3 : this.c1;
    c[3] = c1[0];
    c[4] = c1[1];
    c[5] = c1[2];
    c[6] = c2[0];
    c[7] = c2[1];
    c[8] = c2[2];
    v[0] = l[0];
    v[1] = l[1];
    v[2] = l[2];
    v[3] = l[3];
    v[4] = l[4];
    v[5] = l[5];
    v[6] = l[6];
    v[7] = l[7];
    v[8] = l[8];
    this.vertices.needsUpdate = true;
    this.colors.needsUpdate = true;
  }
};
var _object3DId = 0;
var _v1$2 = new Vector3();
var _q1 = new Quaternion();
var _m1 = new Matrix4();
var _target = new Vector3();
var _position = new Vector3();
var _scale = new Vector3();
var _quaternion = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Basic3D = class extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = MathUtils.generateUUID();
    this.isRay = true;
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.name = "";
    this.type = "Object3D";
    this.children = [];
    this.parent = null;
    this.position = new Vector3();
    this.quaternion = new Quaternion();
    this.tmpRotation = new Euler();
    this.scale = new Vector3(1, 1, 1);
    this.isKinematic = false;
    this.matrixAutoUpdate = false;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.isVisible = true;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
    this.mass = 0;
    this.density = 0;
    this.inertia = new Vector3(1, 1, 1);
    this.shapetype = "box";
    this.size = [1, 1, 1];
    this.velocity = new Vector3();
    this.angular = new Vector3();
    this.defMat = false;
    this.actif = false;
    this.auto = false;
    this.sleep = false;
    this.mesh = null;
    this.meshSize = 1;
    this.linked = [];
    this.isOver = false;
    this.overMaterial = null;
  }
  // ADD
  clearOutLine() {
    if (!this.overMaterial) return;
    if (!this.outline) return;
    this.remove(this.outline);
    this.outline = null;
  }
  addOutLine() {
    if (!this.overMaterial) return;
    if (!this.children[0].isMesh) return;
    let s = 0.01;
    this.outline = new Mesh().copy(this.children[0]);
    this.outline.name = "outline";
    this.outline.material = this.overMaterial;
    if (this.overMaterial.uniforms.power) this.overMaterial.uniforms.power.value = s / this.meshSize;
    this.outline.matrixAutoUpdate = false;
    this.outline.receiveShadow = false;
    this.outline.castShadow = false;
    this.outline.raycast = () => false;
    this.add(this.outline);
  }
  over(b) {
    if (b && !this.isOver) {
      this.isOver = true;
      this.addOutLine();
    }
    if (!b && this.isOver) {
      this.isOver = false;
      this.clearOutLine();
    }
  }
  select(b) {
  }
  dispose() {
    this.clearOutLine();
    this.traverse(function(node) {
      if (node.isMesh && node.unic) node.geometry.dispose();
    });
    this.children = [];
  }
  /*set size( value ){
  		this._size.fromArray( value )
  	}
  
  	get size(){
  		return this._size.toArray()
  	}*/
  set receiveShadow(value) {
    this.traverse(function(node) {
      if (node.isMesh) node.receiveShadow = value;
    });
  }
  get receiveShadow() {
    if (this.children[0]) return this.children[0].receiveShadow;
    else return false;
  }
  set castShadow(value) {
    this.traverse(function(node) {
      if (node.isMesh) node.castShadow = value;
    });
  }
  get castShadow() {
    if (this.children[0]) return this.children[0].castShadow;
    else return false;
  }
  set material(value) {
    this.traverse(function(node) {
      if (node.isMesh) {
        if (node.name !== "outline") node.material = value;
      }
    });
  }
  get material() {
    this.children;
    if (this.children[0]) return this.children[0].material;
    else return null;
  }
  set rotation(v) {
    this.tmpRotation = v;
    quaternion.setFromEuler(this.tmpRotation, false);
  }
  get rotation() {
    return this.tmpRotation.setFromQuaternion(this.quaternion, void 0, false);
  }
  //////
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$2.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
  }
  lookAt(x2, y, z) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1.lookAt(_position, _target, this.up);
    } else {
      _m1.lookAt(_target, _position, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1);
    if (parent) {
      _m1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    const children = this.children;
    let i = children.length;
    while (i--) {
      const object = children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    const children = this.children;
    let i = children.length;
    while (i--) {
      const child = children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  setRaycast(v) {
    if (v !== void 0) this.isRay = v;
    if (!this.isRay) {
      let i = this.children.length;
      while (i--) {
        let j = this.children[i].children.length;
        while (j--) this.children[i].children[j].raycast = () => {
        };
        this.children[i].raycast = () => {
        };
      }
    }
  }
  // direct raycast avoid recursive !!
  raycast(raycaster, intersects) {
    if (!this.isRay) return;
    const children = this.children;
    let i = children.length;
    while (i--) {
      if (children[i].layers.test(raycaster.layers)) {
        children[i].raycast(raycaster, intersects);
      }
    }
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    let i = children.length;
    while (i--) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    let i = children.length;
    while (i--) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  /*setTransform( p, q, s ) {
  
  		this.position.fromArray( p )
  		this.quaternion.fromArray( q )
  
  		this.matrix.copy( m );
  		this.matrix.decompose( this.position, this.quaternion, this.scale );
  		this.matrixWorldNeedsUpdate = true;
  
  	}
  
  	setColor( color ) {
  
  		if( this.isInstance ){
  		    this.instance.setColorAt( this.instanceId, color );
  		}
  		
  	}
  
  	updateMatrix() {
  
  		this.matrix.compose( this.position, this.quaternion, this.scale );
  	    this.matrixWorldNeedsUpdate = true;
  
  		if( this.isInstance ) {
  			this.instance.setTransformAt( this.instanceId, this.position.toArray(), this.quaternion.toArray(), this.size )
  			return;
  		} else {
  			
  		}
  
  		
  
  		//if( this.isInstance ) this.instance.setMatrixAt( this.instanceId, this.matrix );
  		//else this.matrixWorldNeedsUpdate = true;
  
  	}*/
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    let i = children.length;
    while (i--) {
      children[i].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      let i = children.length;
      while (i--) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  }
};
var Instance = class extends InstancedMesh {
  constructor(geometry, material, count = 0) {
    super(geometry, material, count);
    this.matrixAutoUpdate = false;
    this.tmpMatrix = new Matrix4();
    this.tmpQuat = new Quaternion();
    this.instanceUv = null;
    this.instanceColor = null;
    this.needSphereUp = false;
    this.isRay = true;
    this.overMaterial = null;
    this.currentOver = -1;
    this.isOver = false;
    this.tmpElement = [];
  }
  clearOutLine() {
    if (!this.overMaterial) return;
    if (!this.outline) return;
    this.parent.remove(this.outline);
    this.outline = null;
    this.currentOver = -1;
  }
  addOutLine(obj) {
    if (!this.overMaterial) return;
    this.outline = new Mesh(this.geometry, this.overMaterial);
    if (this.overMaterial.uniforms.power) this.overMaterial.uniforms.power.value = 0.01;
    this.outline.matrixAutoUpdate = false;
    this.tmpMatrix.fromArray(this.instanceMatrix.array, obj.id * 16);
    this.outline.matrix.copy(this.tmpMatrix);
    this.outline.matrixWorldNeedsUpdate = true;
    this.parent.add(this.outline);
    this.currentOver = obj.id;
  }
  over(b) {
    if (b && !this.instance.isOver) {
      this.instance.isOver = true;
      this.instance.addOutLine(this);
    }
    if (!b && this.instance.isOver) {
      this.instance.isOver = false;
      this.instance.clearOutLine();
    }
  }
  getInfo(index) {
    this.tmpMatrix.fromArray(this.instanceMatrix.array, index * 16);
    let pos = { x: 0, y: 0, z: 0 };
    let scale = { x: 0, y: 0, z: 0 };
    this.tmpMatrix.decompose(pos, this.tmpQuat, scale);
    return {
      pos: [pos.x, pos.y, pos.z],
      quat: this.tmpQuat.toArray(),
      scale: [scale.x, scale.y, scale.z]
      //worldMatrix:this.tmpMatrix.toArray(),
    };
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    if (color.isColor) color = color.toArray();
    let id = index * 3;
    this.instanceColor.array[id] = color[0];
    this.instanceColor.array[id + 1] = color[1];
    this.instanceColor.array[id + 2] = color[2];
  }
  /*setUvAt( index, uv ) {
  
          if ( this.instanceUv === null ) this.instanceUv = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 2 ), 2 );
          
          if( uv.isVector2 ) uv = uv.toArray()
          let id = index * 2
          this.instanceUv.array[id] = uv[0]
          this.instanceUv.array[id +1] = uv[1]
  
      }*/
  add(bref, position = [0, 0, 0], rotation = [0, 0, 0, 1], scale = [1, 1, 1], color = null, uv = null) {
    if (rotation.length === 3) rotation = this.tmpQuat.setFromEuler({ _x: rotation[0], _y: rotation[1], _z: rotation[2], _order: "XYZ" }, false).toArray();
    if (color) {
      if (color.isColor) color = color.toArray();
      if (this.instanceColor === null) this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    this.expand(position, rotation, scale, color, uv);
    this.tmpElement.push(bref);
  }
  slice(ar, begin, end) {
    let target = new Float32Array(end - begin);
    for (let i = 0; i < begin + end; ++i) {
      target[i] = ar[begin + i];
    }
    return target;
  }
  remove(id) {
    if (!this.count) return;
    this.tmpElement.splice(id, 1);
    let old = [...this.instanceMatrix.array];
    old.splice(id * 16, 16);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(old), 16);
    if (this.instanceColor !== null) {
      old = [...this.instanceColor.array];
      old.splice(id * 3, 3);
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(old), 3);
    }
    if (this.instanceUv !== null) {
      old = [...this.instanceUv.array];
      old.splice(id * 2, 2);
      this.instanceUv = new InstancedBufferAttribute(new Float32Array(old), 2);
    }
    this.count--;
    this.reDistribute();
  }
  reDistribute() {
    let i = this.count;
    while (i--) this.tmpElement[i].id = i;
  }
  getByName(index) {
    return this.tmpElement[index].name;
  }
  getBodyList() {
    let bodyNames = [];
    let i = this.count;
    while (i--) bodyNames.push(this.tmpElement[i].name);
    return bodyNames;
  }
  expand(p2, q, s, c = [1, 1, 1], uv) {
    let old = this.instanceMatrix !== null ? this.instanceMatrix.array : [];
    this.tmpMatrix.compose({ x: p2[0], y: p2[1], z: p2[2] }, { _x: q[0], _y: q[1], _z: q[2], _w: q[3] }, { x: s[0], y: s[1], z: s[2] });
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array([...old, ...this.tmpMatrix.toArray()]), 16);
    if (this.instanceColor !== null) {
      old = this.instanceColor.array;
      this.instanceColor = new InstancedBufferAttribute(new Float32Array([...old, ...c]), 3);
    }
    this.count++;
  }
  setTransformAt(index, p2, q, s) {
    this.tmpMatrix.compose({ x: p2[0], y: p2[1], z: p2[2] }, { _x: q[0], _y: q[1], _z: q[2], _w: q[3] }, { x: s[0], y: s[1], z: s[2] });
    this.tmpMatrix.toArray(this.instanceMatrix.array, index * 16);
    this.needSphereUp = true;
    if (!this.outline) return;
    if (this.currentOver === index) {
      this.outline.matrix.copy(this.tmpMatrix);
      this.outline.matrixWorldNeedsUpdate = true;
    }
  }
  dispose() {
    this.clearOutLine();
    this.parent.remove(this);
    this.geometry.dispose();
    this.instanceColor = null;
    this.count = 0;
    this.tmpElement = [];
    this.dispatchEvent({ type: "dispose" });
  }
  setRaycast(v) {
    if (v !== void 0) this.isRay = v;
  }
  raycast(raycaster, intersects) {
    if (!this.isRay) return;
    super.raycast(raycaster, intersects);
  }
  update() {
    if (this.needSphereUp) this.computeBoundingSphere();
    if (this.instanceMatrix) this.instanceMatrix.needsUpdate = true;
    if (this.instanceColor) this.instanceColor.needsUpdate = true;
    this.needSphereUp = false;
  }
};
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0) attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0) morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0) break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (TypedArray === void 0) TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0) itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0) normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1) gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.count * itemSize;
  }
  const array = new TypedArray(arrayLength);
  const result = new BufferAttribute(array, itemSize, normalized);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      const tupleOffset = offset / itemSize;
      for (let j = 0, l = attribute.count; j < l; j++) {
        for (let c = 0; c < itemSize; c++) {
          const value = attribute.getComponent(j, c);
          result.setComponent(j + tupleOffset, c, value);
        }
      }
    } else {
      array.set(attribute.array, offset);
    }
    offset += attribute.count * itemSize;
  }
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
function mergeVertices(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry.attributes);
  const tmpAttributes = {};
  const tmpMorphAttributes = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let i = 0, l = attributeNames.length; i < l; i++) {
    const name = attributeNames[i];
    const attr = geometry.attributes[name];
    tmpAttributes[name] = new BufferAttribute(
      new attr.array.constructor(attr.count * attr.itemSize),
      attr.itemSize,
      attr.normalized
    );
    const morphAttr = geometry.morphAttributes[name];
    if (morphAttr) {
      tmpMorphAttributes[name] = new BufferAttribute(
        new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize),
        morphAttr.itemSize,
        morphAttr.normalized
      );
    }
  }
  const halfTolerance = tolerance * 0.5;
  const exponent = Math.log10(1 / tolerance);
  const hashMultiplier = Math.pow(10, exponent);
  const hashAdditive = halfTolerance * hashMultiplier;
  for (let i = 0; i < vertexCount; i++) {
    const index = indices ? indices.getX(i) : i;
    let hash = "";
    for (let j = 0, l = attributeNames.length; j < l; j++) {
      const name = attributeNames[j];
      const attribute = geometry.getAttribute(name);
      const itemSize = attribute.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;
      }
    }
    if (hash in hashToIndex) {
      newIndices.push(hashToIndex[hash]);
    } else {
      for (let j = 0, l = attributeNames.length; j < l; j++) {
        const name = attributeNames[j];
        const attribute = geometry.getAttribute(name);
        const morphAttr = geometry.morphAttributes[name];
        const itemSize = attribute.itemSize;
        const newarray = tmpAttributes[name];
        const newMorphArrays = tmpMorphAttributes[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          const setterFunc = setters[k];
          newarray[setterFunc](nextIndex, attribute[getterFunc](index));
          if (morphAttr) {
            for (let m2 = 0, ml = morphAttr.length; m2 < ml; m2++) {
              newMorphArrays[m2][setterFunc](nextIndex, morphAttr[m2][getterFunc](index));
            }
          }
        }
      }
      hashToIndex[hash] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry.clone();
  for (const name in geometry.attributes) {
    const tmpAttribute = tmpAttributes[name];
    result.setAttribute(name, new BufferAttribute(
      tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize),
      tmpAttribute.itemSize,
      tmpAttribute.normalized
    ));
    if (!(name in tmpMorphAttributes)) continue;
    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {
      const tmpMorphAttribute = tmpMorphAttributes[name][j];
      result.morphAttributes[name][j] = new BufferAttribute(
        tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize),
        tmpMorphAttribute.itemSize,
        tmpMorphAttribute.normalized
      );
    }
  }
  result.setIndex(newIndices);
  return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
var SphereBox = class extends BufferGeometry {
  constructor(radius = 1, widthSegs = 10, heightSegs = 10, depthSegs = 10, roundness = 1) {
    super();
    this.type = "SphereBox";
    this.name = "SphereBox_" + radius + "_" + widthSegs + "_" + heightSegs + "_" + depthSegs + "_" + roundness;
    radius = radius || 1;
    widthSegs = Math.floor(widthSegs);
    heightSegs = Math.floor(heightSegs);
    depthSegs = Math.floor(depthSegs);
    let g2 = new BoxGeometry(1, 1, 1, widthSegs, heightSegs, depthSegs), v = new Vector3(), r = new Vector3(), n2;
    let ar = g2.attributes.position.array;
    let nm = g2.attributes.normal.array;
    for (let i = 0, l = g2.attributes.position.count; i < l; i++) {
      n2 = i * 3;
      v.set(ar[n2], ar[n2 + 1], ar[n2 + 2]);
      r.copy(v).normalize();
      v.lerp(r, roundness).multiplyScalar(radius);
      ar[n2] = v.x;
      ar[n2 + 1] = v.y;
      ar[n2 + 2] = v.z;
      v.normalize();
      nm[n2] = v.x;
      nm[n2 + 1] = v.y;
      nm[n2 + 2] = v.z;
    }
    this.copy(g2);
  }
};
var Capsule = class extends BufferGeometry {
  constructor(radius = 1, height = 1, radialSegs = 12, heightSegs = 1) {
    super();
    this.type = "CapsuleGeometry";
    let pi = Math.PI;
    let th = radius * 2 + height;
    let sy = radius / th;
    let hy = 1 - 2 * sy;
    radialSegs = Math.floor(radialSegs);
    heightSegs = Math.floor(heightSegs);
    let sHeight = Math.floor(radialSegs * 0.5);
    let o0 = Math.PI * 2;
    let o1 = Math.PI * 0.5;
    let m0 = new CylinderGeometry(radius, radius, height, radialSegs, heightSegs, true);
    scaleUV(m0, 0, sy, 1, hy);
    let m1 = new SphereGeometry(radius, radialSegs, sHeight, 0, o0, 0, o1);
    scaleUV(m1, 0, 1 - sy, 1, sy);
    let m2 = new SphereGeometry(radius, radialSegs, sHeight, 0, o0, o1, o1);
    scaleUV(m2, 0, 0, 1, sy);
    let mtx0 = new Matrix4().makeRotationY(-pi * 0.5);
    let mtx1 = new Matrix4().makeTranslation(0, height * 0.5, 0);
    let mtx2 = new Matrix4().makeTranslation(0, -height * 0.5, 0);
    m0.applyMatrix4(mtx0);
    m1.applyMatrix4(mtx1);
    m2.applyMatrix4(mtx2);
    let g2 = mergeVertices(mergeGeometries([m0, m1, m2]));
    this.copy(g2);
  }
};
var TorusGeometryFix = class extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "TorusGeometryFix";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();
    let j, i;
    for (j = 0; j <= radialSegments; j++) {
      for (i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * thetaLength + thetaStart;
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (j = 1; j <= radialSegments; j++) {
      for (i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var ChamferCyl = class extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, filet = 0.01, radialSegs = 12, heightSegs = 1, filetSegs = 2) {
    super();
    this.type = "ChamferCyl";
    radialSegs = Math.floor(radialSegs);
    heightSegs = Math.floor(heightSegs);
    filetSegs = Math.floor(filetSegs);
    let mr = new Matrix4();
    let mt = new Matrix4();
    let pi = Math.PI;
    let p90 = pi * 0.5;
    let twoPi = pi * 2;
    let start = 0;
    let th = height;
    let sy = filet / th;
    let hy = 1 - 2 * sy;
    let mid = new CylinderGeometry(radiusTop, radiusBottom, height - filet * 2, radialSegs, heightSegs, true, start);
    mr.makeRotationY(p90);
    mid.applyMatrix4(mr);
    scaleUV(mid, 0, sy, 1, hy);
    let c1 = new TorusGeometryFix(radiusTop - filet, filet, filetSegs, radialSegs, twoPi, 0, p90);
    let c2 = new CircleGeometry(radiusTop - filet, radialSegs);
    mt.makeTranslation(0, 0, filet);
    c2.applyMatrix4(mt);
    scaleUV(c1, 0, 1 - sy, 1, sy);
    let top = mergeGeometries([c1, c2]);
    mr.makeTranslation(0, 0, height * 0.5 - filet);
    mt.makeRotationX(-p90);
    top.applyMatrix4(mt.multiply(mr));
    c1 = new TorusGeometryFix(radiusBottom - filet, filet, filetSegs, radialSegs, twoPi, 0, p90);
    c2 = new CircleGeometry(radiusBottom - filet, radialSegs);
    mt.makeTranslation(0, 0, filet);
    c2.applyMatrix4(mt);
    scaleUV(c1, 0, 1 - sy, 1, sy, true);
    let low = mergeGeometries([c1, c2]);
    mr.makeTranslation(0, 0, height * 0.5 - filet);
    mt.makeRotationX(p90);
    low.applyMatrix4(mt.multiply(mr));
    let g2 = mergeVertices(mergeGeometries([top, mid, low]));
    this.copy(g2);
  }
};
var ChamferBox = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, filet = 0.01, widthSegs = 1, heightSegs = 1, depthSegs = 1, filetSegs = 2) {
    super();
    this.type = "ChamferBox";
    widthSegs = Math.floor(widthSegs);
    heightSegs = Math.floor(heightSegs);
    depthSegs = Math.floor(depthSegs);
    filetSegs = Math.floor(filetSegs);
    let pi = Math.PI;
    let p90 = pi * 0.5;
    let twoFilet = filet * 2;
    let midWidth = width * 0.5;
    let midHeight = height * 0.5;
    let midDepth = depth * 0.5;
    let mr = new Matrix4();
    let mt = new Matrix4();
    let mp = new Matrix4();
    let tw = width;
    let sw = filet / tw;
    let vw = 1 - 2 * sw;
    let th = height;
    let sh = filet / th;
    let vh = 1 - 2 * sw;
    let td2 = depth;
    let sd = filet / td2;
    let vd = 1 - 2 * sd;
    let f = new PlaneGeometry(width - twoFilet, height - twoFilet, widthSegs, heightSegs);
    let c1 = new CylinderGeometry(filet, filet, width - twoFilet, filetSegs, widthSegs, true, 0, p90);
    let c2 = new CylinderGeometry(filet, filet, height - twoFilet, filetSegs, heightSegs, true, 0, p90);
    let s1 = new SphereGeometryFix(filet, filetSegs, filetSegs, 0, p90, 0, -p90);
    let s2 = new SphereGeometryFix(filet, filetSegs, filetSegs, 0, p90, 0, -p90);
    scaleUV(f, -sw, sh, vw, vh);
    scaleUV(c1, 0, sw, sh, vw);
    mt.makeTranslation(0, midHeight - filet, 0);
    mr.makeRotationX(p90);
    s1.applyMatrix4(mt.multiply(mr));
    mt.makeTranslation(0, -midHeight + filet, 0);
    mr.makeRotationX(p90);
    mp.makeRotationY(-p90);
    s2.applyMatrix4(mt.multiply(mr).multiply(mp));
    let tra = mergeGeometries([c2, s1, s2]);
    let trc = tra.clone();
    mt.makeTranslation(midWidth - filet, 0, -filet);
    tra.applyMatrix4(mt);
    mt.makeTranslation(-midWidth + filet, 0, -filet);
    mr.makeRotationZ(pi);
    trc.applyMatrix4(mt.multiply(mr));
    let c3 = c1.clone();
    mr.makeRotationZ(p90);
    mt.makeTranslation(0, midHeight - filet, -filet);
    c1.applyMatrix4(mt.multiply(mr));
    mt.makeTranslation(0, -midHeight + filet, -filet);
    mr.makeRotationZ(-p90);
    c3.applyMatrix4(mt.multiply(mr));
    let rf = mergeGeometries([c1, c3, f, tra, trc]);
    let rg = rf.clone();
    mt.makeTranslation(0, 0, midDepth);
    rf.applyMatrix4(mt);
    mt.makeTranslation(0, 0, -midDepth);
    mr.makeRotationY(pi);
    rg.applyMatrix4(mt.multiply(mr));
    f = new PlaneGeometry(depth - twoFilet, height - twoFilet, depthSegs, heightSegs);
    c1 = new CylinderGeometry(filet, filet, depth - twoFilet, filetSegs, depthSegs, true, 0, p90);
    c3 = c1.clone();
    scaleUV(f, -sd, sh, vd, vh);
    mt.makeTranslation(0, -(midHeight - filet), -filet, 0);
    mr.makeRotationZ(-p90);
    c1.applyMatrix4(mt.multiply(mr));
    mt.makeTranslation(0, midHeight - filet, -filet, 0);
    mr.makeRotationZ(p90);
    c3.applyMatrix4(mt.multiply(mr));
    let rr = mergeGeometries([c1, c3, f]);
    let rb = rr.clone();
    mt.makeTranslation(-midWidth, 0, 0);
    mr.makeRotationY(-p90);
    rr.applyMatrix4(mt.multiply(mr));
    mt.makeTranslation(midWidth, 0, 0);
    mr.makeRotationY(p90);
    rb.applyMatrix4(mt.multiply(mr));
    f = new PlaneGeometry(width - twoFilet, depth - twoFilet, widthSegs, depthSegs);
    scaleUV(f, -sw, sd, vw, vd);
    let f2 = f.clone();
    mt.makeTranslation(0, midHeight, 0);
    mr.makeRotationX(-p90);
    f.applyMatrix4(mt.multiply(mr));
    mt.makeTranslation(0, -midHeight, 0);
    mr.makeRotationX(p90);
    f2.applyMatrix4(mt.multiply(mr));
    let g2 = mergeVertices(mergeGeometries([rf, rg, rr, rb, f, f2]));
    createUV(g2, "box");
    this.copy(g2);
  }
};
var SphereGeometryFix = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometryFix";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
function scaleUV(geometry, x2 = 0, y = 0, dx = 1, dy = 1, reverse) {
  let uv = geometry.attributes.uv;
  let ar = uv.array;
  let i = uv.count, n2 = 0;
  while (i--) {
    n2 = i * 2;
    ar[n2] = ar[n2] * dx - x2;
    ar[n2 + 1] = ar[n2 + 1] * dy + y;
    if (reverse) {
      ar[n2] = 1 - ar[n2];
      ar[n2 + 1] = 1 - ar[n2 + 1];
    }
  }
}
function createUV(geometry, type = "sphere", boxSize, pos = [0, 0, 0], quat = [0, 0, 0, 1], transformMatrix) {
  if (transformMatrix === void 0) transformMatrix = new Matrix4();
  transformMatrix.compose({ x: pos[0], y: pos[1], z: pos[2] }, { _x: quat[0], _y: quat[1], _z: quat[2], _w: quat[3] }, { x: 1, y: 1, z: 1 });
  if (boxSize === void 0) {
    if (!geometry.boundingBox) geometry.computeBoundingBox();
    let bbox = geometry.boundingBox;
    boxSize = Math.max(bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y, bbox.max.z - bbox.min.z);
  }
  let uvBbox = new Box3(new Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new Vector3(boxSize / 2, boxSize / 2, boxSize / 2));
  let coords = [];
  coords.length = 2 * geometry.attributes.position.count;
  if (geometry.attributes.uv === void 0) geometry.setAttribute("uv", new Float32BufferAttribute(coords, 2));
  let makeSphereUVs = function(v02, v12, v22) {
    v02.applyMatrix4(transformMatrix);
    v12.applyMatrix4(transformMatrix);
    v22.applyMatrix4(transformMatrix);
    let invTwoPi = 1 / (2 * Math.PI);
    let invPi = 1 / Math.PI;
    v02.normalize();
    v12.normalize();
    v22.normalize();
    return {
      uv0: new Vector2(0.5 - Math.atan(v02.z, -v02.x) * invTwoPi, 0.5 - Math.asin(v02.y) * invPi),
      uv1: new Vector2(0.5 - Math.atan(v12.z, -v12.x) * invTwoPi, 0.5 - Math.asin(v12.y) * invPi),
      uv2: new Vector2(0.5 - Math.atan(v22.z, -v22.x) * invTwoPi, 0.5 - Math.asin(v22.y) * invPi)
    };
  };
  let makeCubeUVs = function(v02, v12, v22) {
    v02.applyMatrix4(transformMatrix);
    v12.applyMatrix4(transformMatrix);
    v22.applyMatrix4(transformMatrix);
    let n2 = new Vector3();
    n2.crossVectors(v12.clone().sub(v02), v12.clone().sub(v22)).normalize();
    if (n2.x < 0 || n2.y < 0 || n2.z < 0) ;
    n2.x = Math.abs(n2.x);
    n2.y = Math.abs(n2.y);
    n2.z = Math.abs(n2.z);
    let uv0 = new Vector2();
    let uv1 = new Vector2();
    let uv2 = new Vector2();
    let max2 = 1 / boxSize;
    if (n2.y > n2.x && n2.y > n2.z) {
      uv0.set(v02.x - uvBbox.min.x, uvBbox.max.z - v02.z).multiplyScalar(max2);
      uv1.set(v12.x - uvBbox.min.x, uvBbox.max.z - v12.z).multiplyScalar(max2);
      uv2.set(v22.x - uvBbox.min.x, uvBbox.max.z - v22.z).multiplyScalar(max2);
    } else if (n2.x > n2.y && n2.x > n2.z) {
      uv0.set(v02.z - uvBbox.min.z, v02.y - uvBbox.min.y).multiplyScalar(max2);
      uv1.set(v12.z - uvBbox.min.z, v12.y - uvBbox.min.y).multiplyScalar(max2);
      uv2.set(v22.z - uvBbox.min.z, v22.y - uvBbox.min.y).multiplyScalar(max2);
    } else if (n2.z > n2.y && n2.z > n2.x) {
      uv0.set(v02.x - uvBbox.min.x, v02.y - uvBbox.min.y).multiplyScalar(max2);
      uv1.set(v12.x - uvBbox.min.x, v12.y - uvBbox.min.y).multiplyScalar(max2);
      uv2.set(v22.x - uvBbox.min.x, v22.y - uvBbox.min.y).multiplyScalar(max2);
    }
    return { uv0, uv1, uv2 };
  };
  let i, id0, id1, id2, uvs;
  let v0 = new Vector3();
  let v1 = new Vector3();
  let v2 = new Vector3();
  new Vector3();
  new Vector3();
  new Vector3();
  const positionAttribute = geometry.getAttribute("position");
  geometry.getAttribute("normal");
  if (geometry.index) {
    for (i = 0; i < geometry.index.count; i += 3) {
      id0 = geometry.index.getX(i + 0);
      id1 = geometry.index.getX(i + 1);
      id2 = geometry.index.getX(i + 2);
      v0.fromBufferAttribute(positionAttribute, id0);
      v1.fromBufferAttribute(positionAttribute, id1);
      v2.fromBufferAttribute(positionAttribute, id2);
      if (type === "sphere") uvs = makeSphereUVs(v0, v1, v2);
      else uvs = makeCubeUVs(v0, v1, v2);
      coords[2 * id0] = uvs.uv0.x;
      coords[2 * id0 + 1] = uvs.uv0.y;
      coords[2 * id1] = uvs.uv1.x;
      coords[2 * id1 + 1] = uvs.uv1.y;
      coords[2 * id2] = uvs.uv2.x;
      coords[2 * id2 + 1] = uvs.uv2.y;
    }
  } else {
    for (i = 0; i < positionAttribute.count; i += 3) {
      v0.fromBufferAttribute(positionAttribute, i + 0);
      v1.fromBufferAttribute(positionAttribute, i + 1);
      v2.fromBufferAttribute(positionAttribute, i + 2);
      if (type === "sphere") uvs = makeSphereUVs(v0, v1, v2);
      else uvs = makeCubeUVs(v0, v1, v2);
      let idx0 = i;
      let idx1 = i + 1;
      let idx2 = i + 2;
      coords[2 * idx0] = uvs.uv0.x;
      coords[2 * idx0 + 1] = uvs.uv0.y;
      coords[2 * idx1] = uvs.uv1.x;
      coords[2 * idx1 + 1] = uvs.uv1.y;
      coords[2 * idx2] = uvs.uv2.x;
      coords[2 * idx2 + 1] = uvs.uv2.y;
    }
  }
  geometry.attributes.uv.array = new Float32Array(coords);
  geometry.attributes.uv.needsUpdate = true;
}
var Visible = 0;
var Deleted = 1;
var _v1$1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i = 0, l = points.length; i < l; i++) {
        this.vertices.push(new VertexNode(points[i]));
      }
      this.compute();
    }
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry = node.geometry;
      if (geometry !== void 0) {
        const attribute = geometry.attributes.position;
        if (attribute !== void 0) {
          for (let i = 0, l = attribute.count; i < l; i++) {
            const point = new Vector3();
            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
            points.push(point);
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      if (face.distanceToPoint(point) > this.tolerance) return false;
    }
    return true;
  }
  intersectRay(ray, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      const vN = face.distanceToPoint(ray.origin);
      const vD = face.normal.dot(ray.direction);
      if (vN > 0 && vD >= 0) return null;
      const t2 = vD !== 0 ? -vN / vD : 0;
      if (t2 <= 0) continue;
      if (vD > 0) {
        tFar = Math.min(t2, tFar);
      } else {
        tNear = Math.max(t2, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray.at(tNear, target);
    } else {
      ray.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray) {
    return this.intersectRay(ray, _v1$1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance = absorbingFace.distanceToPoint(vertex.point);
          if (distance > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i = 0; i < newFaces.length; i++) {
          const face = newFaces[i];
          if (face.mark === Visible) {
            const distance = face.distanceToPoint(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance) break;
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const min = new Vector3();
    const max2 = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i = 0; i < 3; i++) {
      minVertices[i] = maxVertices[i] = this.vertices[0];
    }
    min.copy(this.vertices[0].point);
    max2.copy(this.vertices[0].point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = this.vertices[i];
      const point = vertex.point;
      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) < min.getComponent(j)) {
          min.setComponent(j, point.getComponent(j));
          minVertices[j] = vertex;
        }
      }
      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) > max2.getComponent(j)) {
          max2.setComponent(j, point.getComponent(j));
          maxVertices[j] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max2.x)) + Math.max(Math.abs(min.y), Math.abs(max2.y)) + Math.max(Math.abs(min.z), Math.abs(max2.z)));
    return { min: minVertices, max: maxVertices };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min = extremes.min;
    const max2 = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i = 0; i < 3; i++) {
      const distance = max2[i].point.getComponent(i) - min[i].point.getComponent(i);
      if (distance > maxDistance) {
        maxDistance = distance;
        index = i;
      }
    }
    const v0 = min[index];
    const v1 = max2[index];
    let v2;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v1.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance = _closestPoint.distanceToSquared(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          v2 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
        const distance = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance > maxDistance) {
          maxDistance = distance;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(
        Face.create(v0, v1, v2),
        Face.create(v3, v1, v0),
        Face.create(v3, v2, v1),
        Face.create(v3, v0, v2)
      );
      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));
        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
      }
    } else {
      faces.push(
        Face.create(v0, v2, v1),
        Face.create(v3, v0, v1),
        Face.create(v3, v1, v2),
        Face.create(v3, v2, v0)
      );
      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));
        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
      }
    }
    for (let i = 0; i < 4; i++) {
      this.faces.push(faces[i]);
    }
    for (let i = 0, l = vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j = 0; j < 4; j++) {
          const distance = this.faces[j].distanceToPoint(vertex.point);
          if (distance > maxDistance) {
            maxDistance = distance;
            maxFace = this.faces[j];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const activeFaces = [];
    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance = eyeFace.distanceToPoint(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(eyePoint, crossEdge, face, horizon) {
    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i = 0; i < horizon.length; i++) {
      const horizonEdge = horizon[i];
      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  // Adds a vertex to the hull
  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();
    while ((vertex = this.nextVertexToAdd()) !== void 0) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
};
var Face = class _Face {
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  static create(a, b, c) {
    const face = new _Face();
    const e0 = new HalfEdge(a, face);
    const e1 = new HalfEdge(b, face);
    const e2 = new HalfEdge(c, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  getEdge(i) {
    let edge = this.edge;
    while (i > 0) {
      edge = edge.next;
      i--;
    }
    while (i < 0) {
      edge = edge.prev;
      i++;
    }
    return edge;
  }
  compute() {
    const a = this.edge.tail();
    const b = this.edge.head();
    const c = this.edge.next.head();
    _triangle.set(a.point, b.point, c.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  // Appends a vertex to the end of the linked list
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  // Removes a vertex from the linked list
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(a, b) {
    if (a.prev === null) {
      this.head = b.next;
    } else {
      a.prev.next = b.next;
    }
    if (b.next === null) {
      this.tail = a.prev;
    } else {
      b.next.prev = a.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var ConvexGeometry = class extends BufferGeometry {
  constructor(points = []) {
    super();
    const vertices = [];
    const normals = [];
    const convexHull = new ConvexHull().setFromPoints(points);
    const faces = convexHull.faces;
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      let edge = face.edge;
      do {
        const point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
};
var CapsuleHelper = class extends Object3D {
  constructor(r, h, useDir, material, c1 = [0, 1, 0], c2 = [0, 0.5, 0], full = false) {
    super();
    if (!r) return;
    if (!h) return;
    const geometry = new BufferGeometry();
    let py = h * 0.5 - r;
    let side = 12;
    let dir = r * 0.2;
    let colors = [];
    const positions = [
      r,
      py,
      0,
      r,
      -py,
      0,
      -r,
      py,
      0,
      -r,
      -py,
      0,
      0,
      py,
      r - dir,
      0,
      py,
      r + dir
    ];
    colors.push(
      ...c1,
      ...c2,
      ...c1,
      ...c2,
      ...c2,
      ...c2
    );
    if (full) {
      positions.push(
        0,
        py,
        r,
        0,
        -py,
        r,
        0,
        py,
        -r,
        0,
        -py,
        -r
      );
      colors.push(
        ...c1,
        ...c2,
        ...c1,
        ...c2
      );
    }
    for (let i = 0, j = 1; i < side; i++, j++) {
      const p1 = i / side * Math.PI * 2;
      const p2 = j / side * Math.PI * 2;
      positions.push(
        r * Math.cos(p1),
        py,
        r * Math.sin(p1),
        r * Math.cos(p2),
        py,
        r * Math.sin(p2),
        r * Math.cos(p1),
        -py,
        r * Math.sin(p1),
        r * Math.cos(p2),
        -py,
        r * Math.sin(p2)
      );
      colors.push(
        ...c1,
        ...c1,
        ...c2,
        ...c2
      );
    }
    for (let i = 0, j = 1; i < side; i++, j++) {
      const p1 = i / side * Math.PI * 2;
      const p2 = j / side * Math.PI * 2;
      let s = j <= side * 0.5 ? 1 : -1;
      positions.push(
        r * Math.cos(p1),
        py * s + r * Math.sin(p1),
        0,
        r * Math.cos(p2),
        py * s + r * Math.sin(p2),
        0
      );
      if (s === 1) colors.push(...c1, ...c1);
      else colors.push(...c2, ...c2);
      if (full) {
        positions.push(
          0,
          py * s + r * Math.sin(p1),
          r * Math.cos(p1),
          0,
          py * s + r * Math.sin(p2),
          r * Math.cos(p2)
        );
        if (s === 1) colors.push(...c1, ...c1);
        else colors.push(...c2, ...c2);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    geometry.computeBoundingSphere();
    this.colors = geometry.attributes.color.array;
    this.colorsbase = [...this.colors];
    this.geometry = geometry;
    this.cone = new LineSegments(geometry, material);
    this.cone.raycast = function() {
      return false;
    };
    this.cone.updateMorphTargets = () => {
    };
    this.cone.name = "cone";
    this.add(this.cone);
    this.isOver = false;
    this.matrixAutoUpdate = false;
    this.type = "CapsuleHelper";
    if (!useDir) return;
    const geometry2 = new BufferGeometry();
    const positions2 = [
      dir * 0.5,
      -py,
      r - dir,
      dir * 0.5,
      -py,
      r + dir,
      -dir * 0.5,
      -py,
      r - dir,
      -dir * 0.5,
      -py,
      r + dir,
      dir * 0.5,
      -py,
      r - dir,
      -dir * 0.5,
      -py,
      r - dir,
      -dir * 0.5,
      -py,
      r + dir,
      -dir,
      -py,
      r + dir,
      dir * 0.5,
      -py,
      r + dir,
      dir,
      -py,
      r + dir,
      -dir,
      -py,
      r + dir,
      0,
      -py,
      r + dir * 2,
      dir,
      -py,
      r + dir,
      0,
      -py,
      r + dir * 2
    ];
    colors = [];
    let cc = positions2.length / 3;
    while (cc--) {
      colors.push(1, 0, 0);
    }
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.direction = new LineSegments(geometry2, material);
    this.direction.raycast = function() {
      return false;
    };
    this.add(this.direction);
  }
  over(b) {
    if (b) {
      if (!this.isOver) {
        this.isOver = true;
        this.changeColor(this.isOver);
      }
    } else {
      if (this.isOver) {
        this.isOver = false;
        this.changeColor(this.isOver);
      }
    }
  }
  changeColor(b) {
    let i = this.colors.length;
    while (i--) this.colors[i] = b ? 1 : this.colorsbase[i];
    if (this.geometry) this.geometry.attributes.color.needsUpdate = true;
  }
  setDirection(r) {
    if (!this.direction) return;
    this.direction.rotation.y = r;
  }
  dispose() {
    this.geometry.dispose();
    this.cone.geometry.dispose();
    if (this.direction) {
      this.direction.geometry.dispose();
    }
  }
  raycast() {
    return false;
  }
  update() {
  }
};
var Body = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "body";
    this.num = Num[this.type];
    this.full = false;
    this.extraConvex = false;
    this.needMatrix = root.engine === "RAPIER" || root.engine === "HAVOK";
  }
  setFull(full) {
    this.num = Num[full ? "bodyFull" : "body"];
    this.full = full;
  }
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    const list = this.list;
    let i = list.length, b, n2;
    while (i--) {
      b = list[i];
      if (b === null) continue;
      n2 = N + i * this.num;
      if (!b.actif) {
        if (MathTool.nullArray(AR, n2, this.num) === 0) continue;
        else b.actif = true;
      }
      b.sleep = AR[n2] > 0 ? false : true;
      if (b.defMat) {
        if (b.isInstance) {
          b.instance.setColorAt(b.id, b.sleep ? Colors.sleep : Colors.body);
        } else {
          if (!b.sleep && b.material.name === "sleep") b.material = Mat.get("body");
          if (b.sleep && b.material.name === "body") b.material = Mat.get("sleep");
        }
      }
      if (b.sleep && !b.isKinematic) continue;
      if (b.isInstance) {
        if (b.speedMat) {
          let v = AR[n2] * 0.01;
          b.instance.setColorAt(b.id, [v, v, v]);
        }
        b.instance.setTransformAt(b.id, [AR[n2 + 1], AR[n2 + 2], AR[n2 + 3]], [AR[n2 + 4], AR[n2 + 5], AR[n2 + 6], AR[n2 + 7]], b.noScale ? [1, 1, 1] : b.size);
        b.position = { x: AR[n2 + 1], y: AR[n2 + 2], z: AR[n2 + 3] };
        b.quaternion = { _x: AR[n2 + 4], _y: AR[n2 + 5], _z: AR[n2 + 6], _w: AR[n2 + 7] };
        if (this.needMatrix) b.matrixWorld.compose(b.position, b.quaternion, { x: 1, y: 1, z: 1 });
        if (this.full) {
          b.velocity = { x: AR[n2 + 8], y: AR[n2 + 9], z: AR[n2 + 10] };
          b.angular = { x: AR[n2 + 11], y: AR[n2 + 12], z: AR[n2 + 13] };
        }
      } else {
        b.position.fromArray(AR, n2 + 1);
        b.quaternion.fromArray(AR, n2 + 4);
        if (this.full) {
          b.velocity.fromArray(AR, n2 + 8);
          b.angular.fromArray(AR, n2 + 11);
        }
        if (!b.auto) b.updateMatrix();
      }
    }
  }
  ///
  geometry(o = {}, b = null, material = null) {
    let g2, i, n2, s = o.size, gName = "";
    let t2 = o.type;
    let noScale = false, unic = false;
    let seg = o.seg || 16;
    const noIndex = root.engine === "OIMO" || root.engine === "JOLT" || root.engine === "CANNON";
    if (o.instance && t2 === "compound") {
      t2 = o.shapes[0].type;
      s = o.shapes[0].size;
      o.translate = o.shapes[0].pos;
    }
    if (t2 === "mesh" || t2 === "convex") {
      if (o.shape) {
        if (o.shape.isMesh) o.shape = o.shape.geometry;
      } else {
        if (o.mesh && !o.v) o.shape = o.mesh.geometry;
      }
    }
    if (o.radius) {
      if (!o.breakable) {
        if (t2 === "box") t2 = "ChamferBox";
        if (t2 === "cylinder") t2 = "ChamferCyl";
      }
    }
    if (o.geometry) {
      if (t2 === "convex") o.shape = o.geometry;
      else t2 = "direct";
    }
    if (root.engine === "PHYSX" && o.type === "cylinder") {
      let geom = new CylinderGeometry(o.size[0], o.size[0], o.size[1], seg, 1);
      if (o.isWheel) geom.rotateZ(-PI90);
      o.v = MathTool.getVertex(geom);
      o.type = "convex";
    }
    if ((root.engine === "PHYSX" || root.engine === "HAVOK" || root.engine === "JOLT") && o.type === "cone") {
      let geom = new CylinderGeometry(0, o.size[0], o.size[1], seg, 1);
      o.v = MathTool.getVertex(geom);
      o.type = "convex";
    }
    if (o.type === "stair") {
      o.type = "box";
      t2 = "box";
    }
    switch (t2) {
      case "direct":
        g2 = o.geometry.clone();
        if (o.size) g2.scale(o.size[0], o.size[1], o.size[2]);
        unic = true;
        noScale = true;
        break;
      case "convex":
        if (o.v) {
          if (o.nogeo) g2 = new BufferGeometry();
          else {
            let vv = [];
            i = Math.floor(o.v.length / 3);
            while (i--) {
              n2 = i * 3;
              vv.push(new Vector3(o.v[n2], o.v[n2 + 1], o.v[n2 + 2]));
            }
            g2 = new ConvexGeometry(vv);
          }
          unic = true;
          noScale = true;
        }
        if (o.shape) {
          g2 = o.shape.clone();
          if (o.size) g2.scale(o.size[0], o.size[0], o.size[0]);
          if (o.shapeScale) g2.scale(o.shapeScale[0], o.shapeScale[1], o.shapeScale[2]);
          let tg = noIndex ? MathTool.toNonIndexed(g2) : null;
          o.v = MathTool.getVertex(tg || g2, noIndex);
          o.index = MathTool.getIndex(tg || g2, noIndex);
          if (root.engine === "CANNON") ;
          unic = true;
          noScale = true;
        }
        if (!g2.boundingBox) g2.computeBoundingBox();
        let bx = g2.boundingBox;
        o.boxSize = [-bx.min.x + bx.max.x, -bx.min.y + bx.max.y, -bx.min.z + bx.max.z];
        break;
      case "mesh":
        g2 = o.shape.clone();
        if (o.size) g2.scale(o.size[0], o.size[0], o.size[0]);
        o.v = MathTool.getVertex(g2, noIndex);
        o.index = MathTool.getIndex(g2, noIndex);
        unic = true;
        noScale = true;
        break;
      case "customSphere":
        gName = "customSphere_" + s[0];
        g2 = Geo.get(gName);
        if (!g2) {
          g2 = new SphereGeometry(s[0], o.seg1 || 32, o.seg2 || 16);
          g2.name = gName;
        } else {
          gName = "";
        }
        noScale = true;
        o.type = "sphere";
        break;
      case "highSphere":
        gName = "highSphere_" + s[0];
        g2 = Geo.get(gName);
        if (!g2) {
          g2 = new SphereBox(s[0]);
          g2.name = gName;
        } else {
          gName = "";
        }
        noScale = true;
        o.type = "sphere";
        break;
      case "capsule":
        gName = "capsule_" + s[0] + "_" + s[1] + "_" + seg;
        g2 = Geo.get(gName);
        if (!g2) {
          g2 = new Capsule(s[0], s[1], seg);
          g2.name = gName;
        } else {
          gName = "";
        }
        noScale = true;
        break;
      case "ChamferBox":
        gName = "ChamferBox_" + s[0] + "_" + s[1] + "_" + s[2] + "_" + o.radius;
        g2 = Geo.get(gName);
        if (!g2) {
          g2 = new ChamferBox(s[0], s[1], s[2], o.radius);
          g2.name = gName;
        } else {
          gName = "";
        }
        noScale = true;
        break;
      case "ChamferCyl":
        gName = "ChamferCyl_" + s[0] + "_" + s[1] + "_" + s[2] + "_" + o.radius + "_" + seg;
        g2 = Geo.get(gName);
        if (!g2) {
          g2 = new ChamferCyl(s[0], s[0], s[1], o.radius, seg);
          g2.name = gName;
        } else {
          gName = "";
        }
        noScale = true;
        break;
      default:
        if (!o.breakable) g2 = Geo.get(t2);
        else {
          g2 = Geo.get(t2).clone();
          g2.scale(s[0], s[1], s[2]);
          unic = true;
          noScale = true;
        }
        break;
    }
    if (o.translate) g2.translate(o.translate[0], o.translate[1], o.translate[2]);
    if (o.shape) delete o.shape;
    if (o.geometry) delete o.geometry;
    if (g2.attributes.uv === void 0 || o.autoUV) {
      createUV(g2, "box", 5, o.pos, o.quat);
    }
    if (gName !== "") Geo.set(g2);
    if (o.isWheel) {
      g2 = g2.clone();
      g2.rotateZ(-PI90);
      unic = true;
    }
    if (unic) Geo.unic(g2);
    if (b === null && material === null) {
      g2.noScale = noScale;
      return g2;
    }
    if (o.meshRemplace && o.debug) material = Mat.get("debug");
    let m2 = new Mesh(g2, material);
    if (o.button) m2.isButton = true;
    if (o.helper) {
      let hcolor = o.hcolor || [0.3, 0.1, 0];
      let hcolor2 = o.hcolor2 || [0.8, 0.2, 0];
      let hh = new CapsuleHelper(s[0], s[1] + s[0] * 2, false, Mat.get("liner"), hcolor, hcolor2, true);
      m2.add(hh);
      m2.userData["helper"] = hh;
    }
    if (o.localRot) o.localQuat = MathTool.quatFromEuler(o.localRot);
    if (o.localPos) m2.position.fromArray(o.localPos);
    if (o.localQuat) m2.quaternion.fromArray(o.localQuat);
    if (!noScale) m2.scale.fromArray(o.size);
    if (o.ray !== void 0) {
      if (!o.ray) m2.raycast = () => {
        return;
      };
    }
    if (!o.meshRemplace || o.debug) {
      b.add(m2);
      if (m2.userData.helper) b.over = (b2) => {
        m2.userData.helper.over(b2);
      };
    }
  }
  add(o = {}) {
    if (o.worldScale) {
      o = this.scaler(o, o.worldScale);
      delete o.worldScale;
    }
    let i, n2, name, volume = 0;
    if (!o.instance) name = this.setName(o);
    o.type = o.type === void 0 ? "box" : o.type;
    if (o.type === "plane" && !o.visible) o.visible = false;
    if (o.type === "stair") {
      let v1 = new Vector3(0, 0, o.size[2]);
      let v2 = new Vector3(0, o.size[1] * 0.5, o.size[2] * 0.5);
      let angle = v1.angleTo(v2);
      let dist = v1.distanceTo(v2);
      o.rot = [angle * todeg$1, 0, 0];
      o.size[1] *= o.div || 0.2;
      o.size[2] = dist * 2;
      let p1 = new Vector3(0, -o.size[1] * 0.5, 0);
      p1.applyAxisAngle({ x: 1, y: 0, z: 0 }, angle);
      o.pos[1] += p1.y;
      o.pos[2] += p1.z;
    }
    if (o.massCenter && root.engine !== "PHYSX") {
      if (o.type !== "compound") {
        o.shapes = [{ type: o.type, pos: o.massCenter, size: o.size }];
        if (o.seg) o.shapes[0].seg = o.seg;
        if (o.radius) o.shapes[0].radius = o.radius;
        delete o.size;
        o.type = "compound";
      } else {
        for (i = 0; i < o.shapes.length; i++) {
          n2 = o.shapes[i];
          if (n2.pos) n2.pos = Utils.vecAdd(n2.pos, o.massCenter);
          else n2.pos = o.massCenter;
          Geo.unic(n2);
        }
      }
    }
    if (o.collision !== void 0) {
      if (o.collision === false) {
        if (root.engine === "PHYSX") o.flags = 0;
        if (root.engine === "OIMO") o.mask = 0;
      }
    }
    o.pos = o.pos === void 0 ? [0, 0, 0] : o.pos;
    o.quat = o.quat === void 0 ? [0, 0, 0, 1] : o.quat;
    if (o.rot !== void 0) o.quat = MathTool.quatFromEuler(o.rot);
    if (o.meshRot !== void 0) o.meshQuat = MathTool.quatFromEuler(o.meshRot);
    o.size = MathTool.autoSize(o.size, o.type);
    if (o.meshScale) o.meshScale = MathTool.autoSize(o.meshScale);
    let material, noMat = false;
    if (o.visible === false) o.material = "hide";
    if (o.material !== void 0) {
      if (o.material.constructor === String) material = Mat.get(o.material);
      else material = o.material;
    } else {
      noMat = true;
      material = Mat.get(this.type);
      if (o.instance) material = Mat.get("base");
    }
    if (o.unicMat) {
      material = material.clone();
      Mat.addToTmp(material);
    }
    let b = o.instance ? {} : new Basic3D();
    if (o.mesh && !o.instance) {
      if (o.mesh.type === "terrain") o.noClone = true;
      let mm = o.noClone ? o.mesh : o.mesh.clone();
      mm.position.fromArray(o.meshPos || [0, 0, 0]);
      if (o.meshQuat) mm.quaternion.fromArray(o.meshQuat);
      if (o.meshSize) mm.scale.set(1, 1, 1).multiplyScalar(o.meshSize);
      if (o.meshScale) mm.scale.fromArray(o.meshScale);
      if (!noMat) {
        mm.material = material;
        if (mm.children && !o.nofullmat) for (let k in mm.children) mm.children[k].material = material;
      }
      root.tmpMesh.push(mm);
      o.meshRemplace = true;
      b.add(mm);
    }
    switch (o.type) {
      case "null":
        break;
      case "compound":
        for (i = 0; i < o.shapes.length; i++) {
          n2 = o.shapes[i];
          n2.type = n2.type === void 0 ? "box" : n2.type;
          n2.size = MathTool.autoSize(n2.size, n2.type);
          if (n2.pos) n2.localPos = n2.pos;
          if (n2.rot !== void 0) n2.quat = MathTool.quatFromEuler(n2.rot);
          if (n2.quat) n2.localQuat = n2.quat;
          n2.debug = o.debug;
          n2.meshRemplace = o.meshRemplace || false;
          if (!o.instance) this.geometry(n2, b, material);
          else if (n2.type === "convex") {
            n2.v = MathTool.getVertex(n2.shape, false);
          }
          volume += MathTool.getVolume(n2.type, n2.size, n2.v);
        }
        break;
      default:
        if (!o.instance) this.geometry(o, b, material);
        else if (o.type === "convex") {
          o.v = MathTool.getVertex(o.shape, false);
        }
        volume = MathTool.getVolume(o.type, o.size, o.v);
        break;
    }
    b.type = this.type;
    b.size = o.size;
    b.shapetype = o.type;
    b.isKinematic = o.kinematic || false;
    b.link = 0;
    b.meshSize = o.meshSize ? o.meshSize : 1;
    if (o.button) b.isButton = true;
    b.isRay = true;
    if (o.ray !== void 0) b.setRaycast(o.ray);
    if (!o.instance) b.setRaycast();
    b.defMat = false;
    if (b.material && noMat) b.defMat = b.material.name === "body";
    if (o.instance) {
      b.isInstance = true;
      b.instance = this.getInstance(o, material);
      b.instance.isRay = b.isRay;
      b.over = b.instance.over;
      b.isOver = false;
      b.speedMat = o.speedMat || false;
      b.defMat = b.instance.material.name === "base";
      b.id = b.instance.count;
      b.refName = b.instance.name + b.id;
      b.name = b.instance.name + b.id;
      if (o.name) b.name = o.name;
      o.name = b.name;
      b.noScale = b.instance.noScale;
      if (o.sizeByInstance) b.noScale = false;
      let color = o.color;
      if (b.defMat) color = o.sleep ? Colors.sleep : Colors.body;
      b.instance.add(b, o.pos, o.quat, b.noScale ? [1, 1, 1] : b.size, color);
      b.position = { x: o.pos[0], y: o.pos[1], z: o.pos[2] };
      b.quaternion = { _x: o.quat[0], _y: o.quat[1], _z: o.quat[2], _w: o.quat[3] };
      b.velocity = { x: 0, y: 0, z: 0 };
      b.angular = { x: 0, y: 0, z: 0 };
      b.link = 0;
      if (this.needMatrix) b.matrixWorld = new Matrix4();
      if (b.instance.v) o.v = b.instance.v;
      if (b.instance.index) o.index = b.instance.index;
      o.type = b.instance.type;
    } else {
      b.name = name;
      if (o.renderOrder) b.renderOrder = o.renderOrder;
      if (o.visible === void 0) o.visible = true;
      if (o.shadow === void 0) o.shadow = o.visible;
      b.visible = o.visible !== void 0 ? o.visible : true;
      b.receiveShadow = o.shadow;
      b.castShadow = o.shadow;
      b.overMaterial = Mat.get("outline");
      this.set(o, b);
    }
    if (o.breakable) {
      root.motor.addBreaker();
      let child = b.children[0];
      b.remove(child);
      b = child;
      b.name = name;
      b.type = this.type;
      b.breakable = true;
      b.breakOption = o.breakOption !== void 0 ? o.breakOption : [250, 1, 2, 1];
    }
    b.mass = o.mass || 0;
    b.density = o.density || 0;
    if (b.density && !b.mass) b.mass = MathTool.massFromDensity(b.density, volume);
    else if (b.mass && !b.density) {
      b.density = MathTool.densityFromMass(b.mass, volume);
      if (root.engine === "RAPIER" || root.engine === "OIMO") o.density = b.density;
    }
    if (o.massInfo) console.log("%c" + b.name + " %cdensity:" + b.density + " mass:" + b.mass, "font-size:16px", "font-size:12px");
    this.addToWorld(b, o.id);
    if (o.onlyMakeMesh) return b;
    if (o.phySize) o.size = o.phySize;
    if (o.phyPos) o.pos = o.phyPos;
    if (o.rot) delete o.rot;
    if (o.mesh) delete o.mesh;
    if (o.meshRot) delete o.meshRot;
    if (o.instance) delete o.instance;
    if (o.material) delete o.material;
    if (o.parent) delete o.parent;
    if (o.solver && root.engine === "PHYSX") {
      o.mass = b.mass;
      const solver = this.byName(o.solver);
      solver.addBone(o.name);
    }
    root.post({ m: "add", o });
    return b;
  }
  set(o = {}, b = null) {
    if (b === null) b = this.byName(o.name);
    if (b === null) return;
    if (o.pos) b.position.fromArray(o.pos);
    if (o.quat) b.quaternion.fromArray(o.quat);
    b.auto = o.auto || false;
    if (!b.auto) {
      b.matrixAutoUpdate = false;
      b.updateMatrix();
    } else {
      b.matrixAutoUpdate = true;
    }
  }
  clearInstance(name) {
    let instance = root.instanceMesh[name];
    let bodyList = instance.getBodyList();
    root.motor.remove(bodyList);
    instance.dispose();
    delete root.instanceMesh[name];
  }
  getInstance(o, material) {
    if (root.instanceMesh[o.instance]) return root.instanceMesh[o.instance];
    o = { ...o };
    if (o.sizeByInstance) o.size = [1, 1, 1];
    let g2 = this.geometry(o);
    if (o.mesh) {
      if (!o.material && o.mesh.material) material = o.mesh.material;
      g2 = o.mesh.isObject3D ? o.mesh.geometry.clone() : o.mesh.clone();
      if (o.meshSize) g2.scale(o.meshSize, o.meshSize, o.meshSize);
      if (o.meshScale) g2.scale(o.meshScale[0], o.meshScale[1], o.meshScale[2]);
      g2.noScale = true;
    }
    let bb = new Instance(g2, material, 0);
    bb.type = o.type;
    bb.noScale = g2.noScale;
    if (bb.type === "convex") bb.v = o.v;
    if (o.index) bb.index = o.index;
    bb.receiveShadow = o.shadow !== void 0 ? o.shadow : true;
    bb.castShadow = o.shadow !== void 0 ? o.shadow : true;
    bb.overMaterial = Mat.get("outline");
    bb.name = o.instance;
    root.scene.add(bb);
    root.instanceMesh[o.instance] = bb;
    return bb;
  }
  scaler(o, s) {
    if (o.size) o.size = math.scaleArray(o.size, s);
    if (o.pos) o.pos = math.scaleArray(o.pos, s);
    if (o.type === "convex") o.shapeScale = [s, s, s];
    if (o.shapes) {
      let i = o.shapes.length, sh;
      while (i--) {
        sh = o.shapes[i];
        if (sh.size) sh.size = math.scaleArray(sh.size, s);
        if (sh.pos) sh.pos = math.scaleArray(sh.pos, s);
        if (sh.type === "convex") sh.shapeScale = [s, s, s];
      }
    }
    if (o.mesh) o.meshScale = [s, s, s];
    return o;
  }
};
var COLOR_SPACE_SVG = SRGBColorSpace;
var SVGLoader = class _SVGLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  }
  load(url2, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url2, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url2);
      }
    }, onProgress, onError);
  }
  parse(text) {
    const scope = this;
    function parseNode(node, style) {
      if (node.nodeType !== 1) return;
      const transform = getNodeTransform(node);
      let isDefsNode = false;
      let path = null;
      switch (node.nodeName) {
        case "svg":
          style = parseStyle(node, style);
          break;
        case "style":
          parseCSSStylesheet(node);
          break;
        case "g":
          style = parseStyle(node, style);
          break;
        case "path":
          style = parseStyle(node, style);
          if (node.hasAttribute("d")) path = parsePathNode(node);
          break;
        case "rect":
          style = parseStyle(node, style);
          path = parseRectNode(node);
          break;
        case "polygon":
          style = parseStyle(node, style);
          path = parsePolygonNode(node);
          break;
        case "polyline":
          style = parseStyle(node, style);
          path = parsePolylineNode(node);
          break;
        case "circle":
          style = parseStyle(node, style);
          path = parseCircleNode(node);
          break;
        case "ellipse":
          style = parseStyle(node, style);
          path = parseEllipseNode(node);
          break;
        case "line":
          style = parseStyle(node, style);
          path = parseLineNode(node);
          break;
        case "defs":
          isDefsNode = true;
          break;
        case "use":
          style = parseStyle(node, style);
          const href = node.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "";
          const usedNodeId = href.substring(1);
          const usedNode = node.viewportElement.getElementById(usedNodeId);
          if (usedNode) {
            parseNode(usedNode, style);
          } else {
            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
          }
          break;
      }
      if (path) {
        if (style.fill !== void 0 && style.fill !== "none") {
          path.color.setStyle(style.fill, COLOR_SPACE_SVG);
        }
        transformPath(path, currentTransform);
        paths.push(path);
        path.userData = { node, style };
      }
      const childNodes = node.childNodes;
      for (let i = 0; i < childNodes.length; i++) {
        const node2 = childNodes[i];
        if (isDefsNode && node2.nodeName !== "style" && node2.nodeName !== "defs") {
          continue;
        }
        parseNode(node2, style);
      }
      if (transform) {
        transformStack.pop();
        if (transformStack.length > 0) {
          currentTransform.copy(transformStack[transformStack.length - 1]);
        } else {
          currentTransform.identity();
        }
      }
    }
    function parsePathNode(node) {
      const path = new ShapePath();
      const point = new Vector2();
      const control = new Vector2();
      const firstPoint = new Vector2();
      let isFirstPoint = true;
      let doSetFirstPoint = false;
      const d = node.getAttribute("d");
      if (d === "" || d === "none") return null;
      const commands = d.match(/[a-df-z][^a-df-z]*/ig);
      for (let i = 0, l = commands.length; i < l; i++) {
        const command = commands[i];
        const type = command.charAt(0);
        const data2 = command.slice(1).trim();
        if (isFirstPoint === true) {
          doSetFirstPoint = true;
          isFirstPoint = false;
        }
        let numbers;
        switch (type) {
          case "M":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              if (j === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j === 0) firstPoint.copy(point);
            }
            break;
          case "H":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.x = numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "V":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.y = numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "L":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "C":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 6) {
              path.bezierCurveTo(
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                numbers[j + 5]
              );
              control.x = numbers[j + 2];
              control.y = numbers[j + 3];
              point.x = numbers[j + 4];
              point.y = numbers[j + 5];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "S":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3]
              );
              control.x = numbers[j + 0];
              control.y = numbers[j + 1];
              point.x = numbers[j + 2];
              point.y = numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "Q":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.quadraticCurveTo(
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3]
              );
              control.x = numbers[j + 0];
              control.y = numbers[j + 1];
              point.x = numbers[j + 2];
              point.y = numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "T":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx,
                ry,
                numbers[j + 0],
                numbers[j + 1]
              );
              control.x = rx;
              control.y = ry;
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "A":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j = 0, jl = numbers.length; j < jl; j += 7) {
              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;
              const start = point.clone();
              point.x = numbers[j + 5];
              point.y = numbers[j + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                start,
                point
              );
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "m":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x += numbers[j + 0];
              point.y += numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              if (j === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j === 0) firstPoint.copy(point);
            }
            break;
          case "h":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.x += numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "v":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.y += numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "l":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x += numbers[j + 0];
              point.y += numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "c":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 6) {
              path.bezierCurveTo(
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3],
                point.x + numbers[j + 4],
                point.y + numbers[j + 5]
              );
              control.x = point.x + numbers[j + 2];
              control.y = point.y + numbers[j + 3];
              point.x += numbers[j + 4];
              point.y += numbers[j + 5];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "s":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3]
              );
              control.x = point.x + numbers[j + 0];
              control.y = point.y + numbers[j + 1];
              point.x += numbers[j + 2];
              point.y += numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "q":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.quadraticCurveTo(
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3]
              );
              control.x = point.x + numbers[j + 0];
              control.y = point.y + numbers[j + 1];
              point.x += numbers[j + 2];
              point.y += numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "t":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx,
                ry,
                point.x + numbers[j + 0],
                point.y + numbers[j + 1]
              );
              control.x = rx;
              control.y = ry;
              point.x = point.x + numbers[j + 0];
              point.y = point.y + numbers[j + 1];
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "a":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j = 0, jl = numbers.length; j < jl; j += 7) {
              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;
              const start = point.clone();
              point.x += numbers[j + 5];
              point.y += numbers[j + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                start,
                point
              );
              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
            }
            break;
          case "Z":
          case "z":
            path.currentPath.autoClose = true;
            if (path.currentPath.curves.length > 0) {
              point.copy(firstPoint);
              path.currentPath.currentPoint.copy(point);
              isFirstPoint = true;
            }
            break;
          default:
            console.warn(command);
        }
        doSetFirstPoint = false;
      }
      return path;
    }
    function parseCSSStylesheet(node) {
      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;
      for (let i = 0; i < node.sheet.cssRules.length; i++) {
        const stylesheet = node.sheet.cssRules[i];
        if (stylesheet.type !== 1) continue;
        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());
        for (let j = 0; j < selectorList.length; j++) {
          const definitions = Object.fromEntries(
            Object.entries(stylesheet.style).filter(([, v]) => v !== "")
          );
          stylesheets[selectorList[j]] = Object.assign(
            stylesheets[selectorList[j]] || {},
            definitions
          );
        }
      }
    }
    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
      if (rx == 0 || ry == 0) {
        path.lineTo(end.x, end.y);
        return;
      }
      x_axis_rotation = x_axis_rotation * Math.PI / 180;
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      const dx2 = (start.x - end.x) / 2;
      const dy2 = (start.y - end.y) / 2;
      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
      let rxs = rx * rx;
      let rys = ry * ry;
      const x1ps = x1p * x1p;
      const y1ps = y1p * y1p;
      const cr = x1ps / rxs + y1ps / rys;
      if (cr > 1) {
        const s = Math.sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;
      }
      const dq = rxs * y1ps + rys * x1ps;
      const pq = (rxs * rys - dq) / dq;
      let q = Math.sqrt(Math.max(0, pq));
      if (large_arc_flag === sweep_flag) q = -q;
      const cxp = q * rx * y1p / ry;
      const cyp = -q * ry * x1p / rx;
      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);
      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
    }
    function svgAngle(ux, uy, vx, vy) {
      const dot = ux * vx + uy * vy;
      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));
      if (ux * vy - uy * vx < 0) ang = -ang;
      return ang;
    }
    function parseRectNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("x") || 0);
      const y = parseFloatWithUnits(node.getAttribute("y") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
      const w = parseFloatWithUnits(node.getAttribute("width"));
      const h = parseFloatWithUnits(node.getAttribute("height"));
      const bci = 1 - 0.551915024494;
      const path = new ShapePath();
      path.moveTo(x2 + rx, y);
      path.lineTo(x2 + w - rx, y);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + w - rx * bci,
          y,
          x2 + w,
          y + ry * bci,
          x2 + w,
          y + ry
        );
      }
      path.lineTo(x2 + w, y + h - ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + w,
          y + h - ry * bci,
          x2 + w - rx * bci,
          y + h,
          x2 + w - rx,
          y + h
        );
      }
      path.lineTo(x2 + rx, y + h);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + rx * bci,
          y + h,
          x2,
          y + h - ry * bci,
          x2,
          y + h - ry
        );
      }
      path.lineTo(x2, y + ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x2, y + ry * bci, x2 + rx * bci, y, x2 + rx, y);
      }
      return path;
    }
    function parsePolygonNode(node) {
      function iterator(match, a, b) {
        const x2 = parseFloatWithUnits(a);
        const y = parseFloatWithUnits(b);
        if (index === 0) {
          path.moveTo(x2, y);
        } else {
          path.lineTo(x2, y);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = true;
      return path;
    }
    function parsePolylineNode(node) {
      function iterator(match, a, b) {
        const x2 = parseFloatWithUnits(a);
        const y = parseFloatWithUnits(b);
        if (index === 0) {
          path.moveTo(x2, y);
        } else {
          path.lineTo(x2, y);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseCircleNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const r = parseFloatWithUnits(node.getAttribute("r") || 0);
      const subpath = new Path();
      subpath.absarc(x2, y, r, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseEllipseNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
      const subpath = new Path();
      subpath.absellipse(x2, y, rx, ry, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseLineNode(node) {
      const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
      const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
      const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
      const y2 = parseFloatWithUnits(node.getAttribute("y2") || 0);
      const path = new ShapePath();
      path.moveTo(x1, y1);
      path.lineTo(x2, y2);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseStyle(node, style) {
      style = Object.assign({}, style);
      let stylesheetStyles = {};
      if (node.hasAttribute("class")) {
        const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i) => i.trim());
        for (let i = 0; i < classSelectors.length; i++) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i]]);
        }
      }
      if (node.hasAttribute("id")) {
        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
      }
      function addStyle(svgName, jsName, adjustFunction) {
        if (adjustFunction === void 0) adjustFunction = function copy(v) {
          if (v.startsWith("url")) console.warn("SVGLoader: url access in attributes is not implemented.");
          return v;
        };
        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));
        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);
        if (node.style && node.style[svgName] !== "") style[jsName] = adjustFunction(node.style[svgName]);
      }
      function clamp(v) {
        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));
      }
      function positive(v) {
        return Math.max(0, parseFloatWithUnits(v));
      }
      addStyle("fill", "fill");
      addStyle("fill-opacity", "fillOpacity", clamp);
      addStyle("fill-rule", "fillRule");
      addStyle("opacity", "opacity", clamp);
      addStyle("stroke", "stroke");
      addStyle("stroke-opacity", "strokeOpacity", clamp);
      addStyle("stroke-width", "strokeWidth", positive);
      addStyle("stroke-linejoin", "strokeLineJoin");
      addStyle("stroke-linecap", "strokeLineCap");
      addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
      addStyle("visibility", "visibility");
      return style;
    }
    function getReflection(a, b) {
      return a - (b - a);
    }
    function parseFloats(input, flags, stride) {
      if (typeof input !== "string") {
        throw new TypeError("Invalid input: " + typeof input);
      }
      const RE = {
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      };
      const SEP = 0;
      const INT = 1;
      const FLOAT = 2;
      const EXP = 3;
      let state = SEP;
      let seenComma = true;
      let number = "", exponent = "";
      const result = [];
      function throwSyntaxError(current2, i, partial) {
        const error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i + ".");
        error.partial = partial;
        throw error;
      }
      function newNumber() {
        if (number !== "") {
          if (exponent === "") result.push(Number(number));
          else result.push(Number(number) * Math.pow(10, Number(exponent)));
        }
        number = "";
        exponent = "";
      }
      let current;
      const length = input.length;
      for (let i = 0; i < length; i++) {
        current = input[i];
        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
          state = INT;
          number = current;
          newNumber();
          continue;
        }
        if (state === SEP) {
          if (RE.WHITESPACE.test(current)) {
            continue;
          }
          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
            state = INT;
            number = current;
            continue;
          }
          if (RE.POINT.test(current)) {
            state = FLOAT;
            number = current;
            continue;
          }
          if (RE.COMMA.test(current)) {
            if (seenComma) {
              throwSyntaxError(current, i, result);
            }
            seenComma = true;
          }
        }
        if (state === INT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.POINT.test(current)) {
            number += current;
            state = FLOAT;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
            throwSyntaxError(current, i, result);
          }
        }
        if (state === FLOAT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.POINT.test(current) && number[number.length - 1] === ".") {
            throwSyntaxError(current, i, result);
          }
        }
        if (state === EXP) {
          if (RE.DIGIT.test(current)) {
            exponent += current;
            continue;
          }
          if (RE.SIGN.test(current)) {
            if (exponent === "") {
              exponent += current;
              continue;
            }
            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
              throwSyntaxError(current, i, result);
            }
          }
        }
        if (RE.WHITESPACE.test(current)) {
          newNumber();
          state = SEP;
          seenComma = false;
        } else if (RE.COMMA.test(current)) {
          newNumber();
          state = SEP;
          seenComma = true;
        } else if (RE.SIGN.test(current)) {
          newNumber();
          state = INT;
          number = current;
        } else if (RE.POINT.test(current)) {
          newNumber();
          state = FLOAT;
          number = current;
        } else {
          throwSyntaxError(current, i, result);
        }
      }
      newNumber();
      return result;
    }
    const units = ["mm", "cm", "in", "pt", "pc", "px"];
    const unitConversion = {
      "mm": {
        "mm": 1,
        "cm": 0.1,
        "in": 1 / 25.4,
        "pt": 72 / 25.4,
        "pc": 6 / 25.4,
        "px": -1
      },
      "cm": {
        "mm": 10,
        "cm": 1,
        "in": 1 / 2.54,
        "pt": 72 / 2.54,
        "pc": 6 / 2.54,
        "px": -1
      },
      "in": {
        "mm": 25.4,
        "cm": 2.54,
        "in": 1,
        "pt": 72,
        "pc": 6,
        "px": -1
      },
      "pt": {
        "mm": 25.4 / 72,
        "cm": 2.54 / 72,
        "in": 1 / 72,
        "pt": 1,
        "pc": 6 / 72,
        "px": -1
      },
      "pc": {
        "mm": 25.4 / 6,
        "cm": 2.54 / 6,
        "in": 1 / 6,
        "pt": 72 / 6,
        "pc": 1,
        "px": -1
      },
      "px": {
        "px": 1
      }
    };
    function parseFloatWithUnits(string) {
      let theUnit = "px";
      if (typeof string === "string" || string instanceof String) {
        for (let i = 0, n2 = units.length; i < n2; i++) {
          const u = units[i];
          if (string.endsWith(u)) {
            theUnit = u;
            string = string.substring(0, string.length - u.length);
            break;
          }
        }
      }
      let scale = void 0;
      if (theUnit === "px" && scope.defaultUnit !== "px") {
        scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
      } else {
        scale = unitConversion[theUnit][scope.defaultUnit];
        if (scale < 0) {
          scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
        }
      }
      return scale * parseFloat(string);
    }
    function getNodeTransform(node) {
      if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
        return null;
      }
      const transform = parseNodeTransform(node);
      if (transformStack.length > 0) {
        transform.premultiply(transformStack[transformStack.length - 1]);
      }
      currentTransform.copy(transform);
      transformStack.push(transform);
      return transform;
    }
    function parseNodeTransform(node) {
      const transform = new Matrix3();
      const currentTransform2 = tempTransform0;
      if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
        const tx = parseFloatWithUnits(node.getAttribute("x"));
        const ty = parseFloatWithUnits(node.getAttribute("y"));
        transform.translate(tx, ty);
      }
      if (node.hasAttribute("transform")) {
        const transformsTexts = node.getAttribute("transform").split(")");
        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
          const transformText = transformsTexts[tIndex].trim();
          if (transformText === "") continue;
          const openParPos = transformText.indexOf("(");
          const closeParPos = transformText.length;
          if (openParPos > 0 && openParPos < closeParPos) {
            const transformType = transformText.slice(0, openParPos);
            const array = parseFloats(transformText.slice(openParPos + 1));
            currentTransform2.identity();
            switch (transformType) {
              case "translate":
                if (array.length >= 1) {
                  const tx = array[0];
                  let ty = 0;
                  if (array.length >= 2) {
                    ty = array[1];
                  }
                  currentTransform2.translate(tx, ty);
                }
                break;
              case "rotate":
                if (array.length >= 1) {
                  let angle = 0;
                  let cx = 0;
                  let cy = 0;
                  angle = array[0] * Math.PI / 180;
                  if (array.length >= 3) {
                    cx = array[1];
                    cy = array[2];
                  }
                  tempTransform1.makeTranslation(-cx, -cy);
                  tempTransform2.makeRotation(angle);
                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                  tempTransform1.makeTranslation(cx, cy);
                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                }
                break;
              case "scale":
                if (array.length >= 1) {
                  const scaleX = array[0];
                  let scaleY = scaleX;
                  if (array.length >= 2) {
                    scaleY = array[1];
                  }
                  currentTransform2.scale(scaleX, scaleY);
                }
                break;
              case "skewX":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    Math.tan(array[0] * Math.PI / 180),
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "skewY":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    0,
                    0,
                    Math.tan(array[0] * Math.PI / 180),
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "matrix":
                if (array.length === 6) {
                  currentTransform2.set(
                    array[0],
                    array[2],
                    array[4],
                    array[1],
                    array[3],
                    array[5],
                    0,
                    0,
                    1
                  );
                }
                break;
            }
          }
          transform.premultiply(currentTransform2);
        }
      }
      return transform;
    }
    function transformPath(path, m2) {
      function transfVec2(v2) {
        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m2);
        v2.set(tempV3.x, tempV3.y);
      }
      function transfEllipseGeneric(curve) {
        const a = curve.xRadius;
        const b = curve.yRadius;
        const cosTheta = Math.cos(curve.aRotation);
        const sinTheta = Math.sin(curve.aRotation);
        const v1 = new Vector3(a * cosTheta, a * sinTheta, 0);
        const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0);
        const f1 = v1.applyMatrix3(m2);
        const f2 = v2.applyMatrix3(m2);
        const mF = tempTransform0.set(
          f1.x,
          f2.x,
          0,
          f1.y,
          f2.y,
          0,
          0,
          0,
          1
        );
        const mFInv = tempTransform1.copy(mF).invert();
        const mFInvT = tempTransform2.copy(mFInv).transpose();
        const mQ = mFInvT.multiply(mFInv);
        const mQe = mQ.elements;
        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);
        const rt1sqrt = Math.sqrt(ed.rt1);
        const rt2sqrt = Math.sqrt(ed.rt2);
        curve.xRadius = 1 / rt1sqrt;
        curve.yRadius = 1 / rt2sqrt;
        curve.aRotation = Math.atan2(ed.sn, ed.cs);
        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;
        if (!isFullEllipse) {
          const mDsqrt = tempTransform1.set(
            rt1sqrt,
            0,
            0,
            0,
            rt2sqrt,
            0,
            0,
            0,
            1
          );
          const mRT = tempTransform2.set(
            ed.cs,
            ed.sn,
            0,
            -ed.sn,
            ed.cs,
            0,
            0,
            0,
            1
          );
          const mDRF = mDsqrt.multiply(mRT).multiply(mF);
          const transformAngle = (phi) => {
            const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);
            return Math.atan2(sinR, cosR);
          };
          curve.aStartAngle = transformAngle(curve.aStartAngle);
          curve.aEndAngle = transformAngle(curve.aEndAngle);
          if (isTransformFlipped(m2)) {
            curve.aClockwise = !curve.aClockwise;
          }
        }
      }
      function transfEllipseNoSkew(curve) {
        const sx = getTransformScaleX(m2);
        const sy = getTransformScaleY(m2);
        curve.xRadius *= sx;
        curve.yRadius *= sy;
        const theta = sx > Number.EPSILON ? Math.atan2(m2.elements[1], m2.elements[0]) : Math.atan2(-m2.elements[3], m2.elements[4]);
        curve.aRotation += theta;
        if (isTransformFlipped(m2)) {
          curve.aStartAngle *= -1;
          curve.aEndAngle *= -1;
          curve.aClockwise = !curve.aClockwise;
        }
      }
      const subPaths = path.subPaths;
      for (let i = 0, n2 = subPaths.length; i < n2; i++) {
        const subPath = subPaths[i];
        const curves = subPath.curves;
        for (let j = 0; j < curves.length; j++) {
          const curve = curves[j];
          if (curve.isLineCurve) {
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isCubicBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
            transfVec2(curve.v3);
          } else if (curve.isQuadraticBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isEllipseCurve) {
            tempV2.set(curve.aX, curve.aY);
            transfVec2(tempV2);
            curve.aX = tempV2.x;
            curve.aY = tempV2.y;
            if (isTransformSkewed(m2)) {
              transfEllipseGeneric(curve);
            } else {
              transfEllipseNoSkew(curve);
            }
          }
        }
      }
    }
    function isTransformFlipped(m2) {
      const te = m2.elements;
      return te[0] * te[4] - te[1] * te[3] < 0;
    }
    function isTransformSkewed(m2) {
      const te = m2.elements;
      const basisDot = te[0] * te[3] + te[1] * te[4];
      if (basisDot === 0) return false;
      const sx = getTransformScaleX(m2);
      const sy = getTransformScaleY(m2);
      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;
    }
    function getTransformScaleX(m2) {
      const te = m2.elements;
      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);
    }
    function getTransformScaleY(m2) {
      const te = m2.elements;
      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);
    }
    function eigenDecomposition(A2, B2, C2) {
      let rt1, rt2, cs, sn, t2;
      const sm = A2 + C2;
      const df = A2 - C2;
      const rt = Math.sqrt(df * df + 4 * B2 * B2);
      if (sm > 0) {
        rt1 = 0.5 * (sm + rt);
        t2 = 1 / rt1;
        rt2 = A2 * t2 * C2 - B2 * t2 * B2;
      } else if (sm < 0) {
        rt2 = 0.5 * (sm - rt);
      } else {
        rt1 = 0.5 * rt;
        rt2 = -0.5 * rt;
      }
      if (df > 0) {
        cs = df + rt;
      } else {
        cs = df - rt;
      }
      if (Math.abs(cs) > 2 * Math.abs(B2)) {
        t2 = -2 * B2 / cs;
        sn = 1 / Math.sqrt(1 + t2 * t2);
        cs = t2 * sn;
      } else if (Math.abs(B2) === 0) {
        cs = 1;
        sn = 0;
      } else {
        t2 = -0.5 * cs / B2;
        cs = 1 / Math.sqrt(1 + t2 * t2);
        sn = t2 * cs;
      }
      if (df > 0) {
        t2 = cs;
        cs = -sn;
        sn = t2;
      }
      return { rt1, rt2, cs, sn };
    }
    const paths = [];
    const stylesheets = {};
    const transformStack = [];
    const tempTransform0 = new Matrix3();
    const tempTransform1 = new Matrix3();
    const tempTransform2 = new Matrix3();
    const tempTransform3 = new Matrix3();
    const tempV2 = new Vector2();
    const tempV3 = new Vector3();
    const currentTransform = new Matrix3();
    const xml = new DOMParser().parseFromString(text, "image/svg+xml");
    parseNode(xml.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    });
    const data = { paths, xml: xml.documentElement };
    return data;
  }
  static createShapes(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      const x1 = a0.x;
      const x2 = a1.x;
      const x3 = b0.x;
      const x4 = b1.x;
      const y1 = a0.y;
      const y2 = a1.y;
      const y3 = b0.y;
      const y4 = b1.y;
      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      const t1 = nom1 / denom;
      const t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (let i = 0; i < 2; i++) {
          classifyPoint(i === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            const x5 = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);
            return { x: x5, y, t: classifyResult.t };
          }
        }
        return null;
      } else {
        for (let i = 0; i < 2; i++) {
          classifyPoint(i === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          }
        }
        const x5 = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);
        return { x: x5, y, t: t1 };
      }
    }
    function classifyPoint(p2, edgeStart, edgeEnd) {
      const ax = edgeEnd.x - edgeStart.x;
      const ay = edgeEnd.y - edgeStart.y;
      const bx = p2.x - edgeStart.x;
      const by = p2.y - edgeStart.y;
      const sa = ax * by - bx * ay;
      if (p2.x === edgeStart.x && p2.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p2.x === edgeEnd.x && p2.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax * bx < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      let t2;
      if (ax !== 0) {
        t2 = bx / ax;
      } else {
        t2 = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t2;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find((i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox, paths) {
      const center = new Vector2();
      boundingBox.getCenter(center);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p2) => {
            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p2 });
          });
        }
      });
      allIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i2) => {
        if (i2.identifier === simplePath.identifier) {
          baseIntersections.push(i2);
        } else {
          otherIntersections.push(i2);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i = 0;
      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i].identifier);
        }
        i++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i2 = 0; i2 < stack.length; i2++) {
          const identifier = stack[i2];
          if (isHole) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = false;
            isHoleFor = identifier;
          } else if (lastCWValue !== allPaths[identifier].isCW) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = true;
          }
        }
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -999999999;
    let simplePaths = shapePath.subPaths.map((p2) => {
      const points = p2.getPoints();
      let maxY = -999999999;
      let minY = BIGNUMBER;
      let maxX = -999999999;
      let minX = BIGNUMBER;
      for (let i = 0; i < points.length; i++) {
        const p3 = points[i];
        if (p3.y > maxY) {
          maxY = p3.y;
        }
        if (p3.y < minY) {
          minY = p3.y;
        }
        if (p3.x > maxX) {
          maxX = p3.x;
        }
        if (p3.x < minX) {
          minX = p3.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return { curves: p2.curves, points, isCW: ShapeUtils.isClockWise(points), identifier: -1, boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)) };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);
    for (let identifier = 0; identifier < simplePaths.length; identifier++) {
      simplePaths[identifier].identifier = identifier;
    }
    const isAHole = simplePaths.map((p2) => isHoleTo(p2, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));
    const shapesToReturn = [];
    simplePaths.forEach((p2) => {
      const amIAHole = isAHole[p2.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape();
        shape.curves = p2.curves;
        const holes = isAHole.filter((h) => h.isHole && h.for === p2.identifier);
        holes.forEach((h) => {
          const hole = simplePaths[h.identifier];
          const path = new Path();
          path.curves = hole.curves;
          shape.holes.push(path);
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  }
  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color = color !== void 0 ? color : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  }
  static pointsToStroke(points, style, arcDivisions, minDistance) {
    const vertices = [];
    const normals = [];
    const uvs = [];
    if (_SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  }
  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
    const tempV2_1 = new Vector2();
    const tempV2_2 = new Vector2();
    const tempV2_3 = new Vector2();
    const tempV2_4 = new Vector2();
    const tempV2_5 = new Vector2();
    const tempV2_6 = new Vector2();
    const tempV2_7 = new Vector2();
    const lastPointL = new Vector2();
    const lastPointR = new Vector2();
    const point0L = new Vector2();
    const point0R = new Vector2();
    const currentPointL = new Vector2();
    const currentPointR = new Vector2();
    const nextPointL = new Vector2();
    const nextPointR = new Vector2();
    const innerPoint = new Vector2();
    const outerPoint = new Vector2();
    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
    minDistance = minDistance !== void 0 ? minDistance : 1e-3;
    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
    points = removeDuplicatedPoints(points);
    const numPoints = points.length;
    if (numPoints < 2) return 0;
    const isClosed = points[0].equals(points[numPoints - 1]);
    let currentPoint;
    let previousPoint = points[0];
    let nextPoint;
    const strokeWidth2 = style.strokeWidth / 2;
    const deltaU = 1 / (numPoints - 1);
    let u0 = 0, u1;
    let innerSideModified;
    let joinIsOnLeftSide;
    let isMiter;
    let initialJoinIsOnLeftSide = false;
    let numVertices = 0;
    let currentCoordinate = vertexOffset * 3;
    let currentCoordinateUV = vertexOffset * 2;
    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
    lastPointL.copy(points[0]).sub(tempV2_1);
    lastPointR.copy(points[0]).add(tempV2_1);
    point0L.copy(lastPointL);
    point0R.copy(lastPointR);
    for (let iPoint = 1; iPoint < numPoints; iPoint++) {
      currentPoint = points[iPoint];
      if (iPoint === numPoints - 1) {
        if (isClosed) {
          nextPoint = points[1];
        } else nextPoint = void 0;
      } else {
        nextPoint = points[iPoint + 1];
      }
      const normal1 = tempV2_1;
      getNormal(previousPoint, currentPoint, normal1);
      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
      currentPointL.copy(currentPoint).sub(tempV2_3);
      currentPointR.copy(currentPoint).add(tempV2_3);
      u1 = u0 + deltaU;
      innerSideModified = false;
      if (nextPoint !== void 0) {
        getNormal(currentPoint, nextPoint, tempV2_2);
        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
        nextPointL.copy(currentPoint).sub(tempV2_3);
        nextPointR.copy(currentPoint).add(tempV2_3);
        joinIsOnLeftSide = true;
        tempV2_3.subVectors(nextPoint, previousPoint);
        if (normal1.dot(tempV2_3) < 0) {
          joinIsOnLeftSide = false;
        }
        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;
        tempV2_3.subVectors(nextPoint, currentPoint);
        tempV2_3.normalize();
        const dot = Math.abs(normal1.dot(tempV2_3));
        if (dot > Number.EPSILON) {
          const miterSide = strokeWidth2 / dot;
          tempV2_3.multiplyScalar(-miterSide);
          tempV2_4.subVectors(currentPoint, previousPoint);
          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
          innerPoint.copy(tempV2_5).negate();
          const miterLength2 = tempV2_5.length();
          const segmentLengthPrev = tempV2_4.length();
          tempV2_4.divideScalar(segmentLengthPrev);
          tempV2_6.subVectors(nextPoint, currentPoint);
          const segmentLengthNext = tempV2_6.length();
          tempV2_6.divideScalar(segmentLengthNext);
          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
            innerSideModified = true;
          }
          outerPoint.copy(tempV2_5).add(currentPoint);
          innerPoint.add(currentPoint);
          isMiter = false;
          if (innerSideModified) {
            if (joinIsOnLeftSide) {
              nextPointR.copy(innerPoint);
              currentPointR.copy(innerPoint);
            } else {
              nextPointL.copy(innerPoint);
              currentPointL.copy(innerPoint);
            }
          } else {
            makeSegmentTriangles();
          }
          switch (style.strokeLineJoin) {
            case "bevel":
              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
              break;
            case "round":
              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
              if (joinIsOnLeftSide) {
                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
              } else {
                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
              }
              break;
            case "miter":
            case "miter-clip":
            default:
              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
              if (miterFraction < 1) {
                if (style.strokeLineJoin !== "miter-clip") {
                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                  break;
                } else {
                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                  if (joinIsOnLeftSide) {
                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                    addVertex(currentPointL, u1, 0);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                    addVertex(currentPointR, u1, 1);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
              } else {
                if (innerSideModified) {
                  if (joinIsOnLeftSide) {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(lastPointR, u0, 1);
                    addVertex(outerPoint, u1, 0);
                    addVertex(innerPoint, u1, 1);
                  } else {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(innerPoint, u1, 0);
                    addVertex(outerPoint, u1, 1);
                  }
                  if (joinIsOnLeftSide) {
                    nextPointL.copy(outerPoint);
                  } else {
                    nextPointR.copy(outerPoint);
                  }
                } else {
                  if (joinIsOnLeftSide) {
                    addVertex(currentPointL, u1, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    addVertex(currentPointR, u1, 1);
                    addVertex(outerPoint, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
                isMiter = true;
              }
              break;
          }
        } else {
          makeSegmentTriangles();
        }
      } else {
        makeSegmentTriangles();
      }
      if (!isClosed && iPoint === numPoints - 1) {
        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
      }
      u0 = u1;
      previousPoint = currentPoint;
      lastPointL.copy(nextPointL);
      lastPointR.copy(nextPointR);
    }
    if (!isClosed) {
      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
    } else if (innerSideModified && vertices) {
      let lastOuter = outerPoint;
      let lastInner = innerPoint;
      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
        lastOuter = innerPoint;
        lastInner = outerPoint;
      }
      if (joinIsOnLeftSide) {
        if (isMiter || initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 0 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 1 * 3);
          }
        }
      } else {
        if (isMiter || !initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 1 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 0 * 3);
          }
        }
      }
    }
    return numVertices;
    function getNormal(p1, p2, result) {
      result.subVectors(p2, p1);
      return result.set(-result.y, result.x).normalize();
    }
    function addVertex(position, u, v) {
      if (vertices) {
        vertices[currentCoordinate] = position.x;
        vertices[currentCoordinate + 1] = position.y;
        vertices[currentCoordinate + 2] = 0;
        if (normals) {
          normals[currentCoordinate] = 0;
          normals[currentCoordinate + 1] = 0;
          normals[currentCoordinate + 2] = 1;
        }
        currentCoordinate += 3;
        if (uvs) {
          uvs[currentCoordinateUV] = u;
          uvs[currentCoordinateUV + 1] = v;
          currentCoordinateUV += 2;
        }
      }
      numVertices += 3;
    }
    function makeCircularSector(center, p1, p2, u, v) {
      tempV2_1.copy(p1).sub(center).normalize();
      tempV2_2.copy(p2).sub(center).normalize();
      let angle = Math.PI;
      const dot = tempV2_1.dot(tempV2_2);
      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));
      angle /= arcDivisions;
      tempV2_3.copy(p1);
      for (let i = 0, il = arcDivisions - 1; i < il; i++) {
        tempV2_4.copy(tempV2_3).rotateAround(center, angle);
        addVertex(tempV2_3, u, v);
        addVertex(tempV2_4, u, v);
        addVertex(center, u, 0.5);
        tempV2_3.copy(tempV2_4);
      }
      addVertex(tempV2_4, u, v);
      addVertex(p2, u, v);
      addVertex(center, u, 0.5);
    }
    function makeSegmentTriangles() {
      addVertex(lastPointR, u0, 1);
      addVertex(lastPointL, u0, 0);
      addVertex(currentPointL, u1, 0);
      addVertex(lastPointR, u0, 1);
      addVertex(currentPointL, u1, 1);
      addVertex(currentPointR, u1, 0);
    }
    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(innerPoint, u, 0.5);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(innerPoint, u, 0.5);
        }
      } else {
        if (joinIsOnLeftSide2) {
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(currentPoint, u, 0.5);
        } else {
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(currentPoint, u, 0.5);
        }
      }
    }
    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u0, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPoint, u1, 0.5);
          addVertex(nextPointL, u0, 0);
          addVertex(innerPoint, u1, 1);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u0, 1);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 0);
          addVertex(nextPointR, u0, 1);
        }
      }
    }
    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {
      switch (style.strokeLineCap) {
        case "round":
          if (start) {
            makeCircularSector(center, p2, p1, u, 0.5);
          } else {
            makeCircularSector(center, p1, p2, u, 0.5);
          }
          break;
        case "square":
          if (start) {
            tempV2_1.subVectors(p1, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
              tempV2_4.toArray(vertices, 3 * 3);
            } else {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_3.toArray(vertices, 3 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
            }
          } else {
            tempV2_1.subVectors(p2, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            const vl = vertices.length;
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            } else {
              tempV2_3.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            }
          }
          break;
      }
    }
    function removeDuplicatedPoints(points2) {
      let dupPoints = false;
      for (let i = 1, n2 = points2.length - 1; i < n2; i++) {
        if (points2[i].distanceTo(points2[i + 1]) < minDistance) {
          dupPoints = true;
          break;
        }
      }
      if (!dupPoints) return points2;
      const newPoints = [];
      newPoints.push(points2[0]);
      for (let i = 1, n2 = points2.length - 1; i < n2; i++) {
        if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {
          newPoints.push(points2[i]);
        }
      }
      newPoints.push(points2[points2.length - 1]);
      return newPoints;
    }
  }
};
var AutoSvg = class extends Mesh {
  constructor(model2, option = {}, material = null) {
    super();
    this.model = model2;
    this.material = material;
    this.outMaterial = material ? true : false;
    this.XML = new XMLSerializer();
    this.color = new Color();
    this.opacity = 1;
    this.svgLoader = new SVGLoader();
    this.base = "http://www.w3.org/2000/svg";
    this.svg = document.createElementNS(this.base, "svg");
    this.layerUp = 1e-4;
    this.fill = true;
    this.stroke = true;
    this.size = option.size || 1;
    this.scaler = 1 / this.size;
    if (!this.model) return;
    let o = {
      radius: 5,
      min: 90,
      max: 90,
      strokeSize: 0.25,
      ...option
    };
    switch (this.model) {
      case "angle":
        this.fill = o.fill !== void 0 ? o.fill : true;
        this.stroke = o.stroke !== void 0 ? o.stroke : true;
        let min = Math.abs(o.min);
        this.add("path", { d: this.circle(0, 0, o.radius, 180, 180 + o.max, true), stroke: "none", fill: "#FF0000", "fill-opacity": 0.1 });
        this.add("path", { d: this.circle(0, 0, o.radius, 180, 180 + o.max, false, false, 0.3), stroke: "#FF0000", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "round" });
        this.add("path", { d: this.circle(0, 0, o.radius, 180 - min, 180, true), stroke: "none", fill: "#0050FF", "fill-opacity": 0.1 });
        this.add("path", { d: this.circle(0, 0, o.radius, 180 - min, 180, false, false, 0.3, true), stroke: "#0050FF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "round" });
        break;
      case "liner":
        let r = o.radius * 0.5;
        let y1 = o.max * this.scaler;
        let y2 = o.min * this.scaler;
        this.fill = o.fill !== void 0 ? o.fill : true;
        this.stroke = o.stroke !== void 0 ? o.stroke : true;
        this.add("path", { d: this.segment({ x: -r, y: 0 }, { x: r, y: 0 }), stroke: "#FFFFFF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: -r, y: y1 }, { x: r, y: y1 }), stroke: "#FF0000", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: -r, y: y2 }, { x: r, y: y2 }), stroke: "#0050FF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: 0, y: 0 }, { x: 0, y: y1 }), stroke: "#FF0000", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: 0, y: 0 }, { x: 0, y: y2 }), stroke: "#0050FF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        break;
      case "needle":
        this.fill = o.fill !== void 0 ? o.fill : true;
        this.stroke = o.stroke !== void 0 ? o.stroke : true;
        this.add("path", { d: this.circle(0, 0, 0.7, 0, 360, false, true, 0), stroke: "#FFFFFF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: 0, y: 0 }, { x: 0, y: 4.4 }), stroke: "#FFFFFF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "round" });
        break;
      case "middle":
        let mm = o.radius * 0.5;
        this.fill = o.fill !== void 0 ? o.fill : true;
        this.stroke = o.stroke !== void 0 ? o.stroke : true;
        this.add("path", { d: this.circle(0, 0, 0.7, 0, 360, false, true, 0), stroke: "#FFFFFF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: 0, y: -mm }, { x: 0, y: mm }), stroke: "#FFFFFF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        this.add("path", { d: this.segment({ x: -mm, y: 0 }, { x: mm, y: 0 }), stroke: "#FFFFFF", "stroke-opacity": 1, "stroke-width": o.strokeSize, fill: "none", "stroke-linecap": "butt" });
        break;
    }
    this.toMesh();
  }
  raycast() {
    return false;
  }
  update(option = {}) {
    let o = {};
    switch (this.model) {
      case "angle":
        o = {
          radius: 5,
          min: -90,
          max: 90,
          ...option
        };
        let min = Math.abs(o.min);
        this.change("d", this.circle(0, 0, o.radius, 180, 180 + o.max, true), 0);
        this.change("d", this.circle(0, 0, o.radius, 180, 180 + o.max, false, false, 0.3), 1);
        this.change("d", this.circle(0, 0, o.radius, 180 - min, 180, true), 2);
        this.change("d", this.circle(0, 0, o.radius, 180 - min, 180, false, false, 0.3, true), 3);
        break;
    }
    if (option.wireframe !== void 0) this.material.wireframe = option.wireframe;
    this.fill = o.fill !== void 0 ? o.fill : true;
    this.stroke = o.stroke !== void 0 ? o.stroke : true;
    this.toMesh();
  }
  // SVG SIDE
  set(o = {}, parent) {
    for (let t2 in o) {
      if (parent) parent.setAttributeNS(null, t2, o[t2]);
      else this.svg.setAttributeNS(null, t2, o[t2]);
    }
  }
  add(type, o = {}) {
    let g2 = document.createElementNS(this.base, type);
    this.set(o, g2);
    this.svg.appendChild(g2);
  }
  change(type, value, id) {
    this.svg.childNodes[id].setAttributeNS(null, type, value);
  }
  getString() {
    return this.XML.serializeToString(this.svg);
  }
  polarToCartesian(x2, y, radius, angleInDegrees) {
    var rad = (angleInDegrees - 90) * Math.PI / 180;
    return { x: x2 + radius * Math.cos(rad), y: y + radius * Math.sin(rad) };
  }
  circle(x2, y, radius, startAngle = 0, endAngle = 360, tri = false, close = false, endTag = 0, over = false) {
    if (startAngle === 0 && endAngle === 360) {
      startAngle = 1e-4;
      close = true;
    }
    let start = this.polarToCartesian(x2, y, radius, endAngle);
    let end = this.polarToCartesian(x2, y, radius, startAngle);
    let arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
    let d = [
      "M",
      start.x,
      start.y,
      "A",
      radius,
      radius,
      0,
      arcSweep,
      0,
      end.x,
      end.y
    ];
    if (tri) d.push(
      "L",
      x2,
      y,
      "L",
      start.x,
      start.y
    );
    if (close) d.push("Z");
    if (endTag !== 0) {
      let p1 = this.polarToCartesian(x2, y, radius - endTag, over ? startAngle : endAngle);
      let p2 = this.polarToCartesian(x2, y, radius + endTag, over ? startAngle : endAngle);
      d.push("M", p1.x, p1.y, "L", p2.x, p2.y);
    }
    return d.join(" ");
  }
  segment(p1, p2) {
    let d = ["M", p1.x, p1.y, "L", p2.x, p2.y];
    return d.join(" ");
  }
  // THREE SIDE
  geomColor(g2, color, opacity = 1) {
    let i = g2.attributes.position.count;
    let cc = [];
    while (i--) {
      cc.push(color.r, color.g, color.b, opacity);
    }
    g2.setAttribute("color", new Float32BufferAttribute(cc, 4));
  }
  toGeometry() {
    if (!this.fill && !this.stroke) return null;
    let geom = [];
    let layer = 0;
    let opacity = 1;
    let data = this.svgLoader.parse(this.getString());
    for (const path of data.paths) {
      const fillColor = path.userData.style.fill;
      if (this.fill && fillColor !== void 0 && fillColor !== "none") {
        this.color.setStyle(fillColor);
        opacity = path.userData.style.fillOpacity;
        if (opacity < this.opacity) this.opacity = opacity;
        const shapes = SVGLoader.createShapes(path);
        for (const shape of shapes) {
          const geometry = new ShapeGeometry(shape);
          if (geometry) {
            this.geomColor(geometry, this.color, opacity);
            let gg = new BufferGeometry().copy(geometry).toNonIndexed();
            gg.translate(0, 0, -layer * this.layerUp);
            geom.push(gg);
            layer++;
          }
        }
      }
      const strokeColor = path.userData.style.stroke;
      if (this.stroke && strokeColor !== void 0 && strokeColor !== "none") {
        this.color.setStyle(strokeColor);
        opacity = path.userData.style.strokeOpacity;
        if (opacity < this.opacity) this.opacity = opacity;
        for (const subPath of path.subPaths) {
          const geometry = SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style, 6);
          if (geometry) {
            this.geomColor(geometry, this.color, opacity);
            geometry.translate(0, 0, -layer * this.layerUp);
            geom.push(geometry);
            layer++;
          }
        }
      }
    }
    return geom;
  }
  toMesh() {
    let s = this.size;
    if (this.geometry) this.geometry.dispose();
    let tmpG = this.toGeometry();
    if (tmpG) {
      this.geometry = mergeGeometries(tmpG);
      this.geometry.scale(s, -s, s);
      this.geometry.rotateY(Math.PI);
      this.geometry.rotateZ(-Math.PI * 0.5);
      this.geometry.rotateY(Math.PI * 0.5);
      this.geometry.computeBoundingSphere();
    } else {
      this.geometry = new BufferGeometry();
    }
    if (this.material === null) {
      this.material = new MeshBasicMaterial({ vertexColors: true, transparent: this.opacity !== 1, side: DoubleSide });
      this.material.defines = { "USE_COLOR_ALPHA": "" };
    }
  }
  dispose() {
    if (this.material && !this.outMaterial) this.material.dispose();
    if (this.geometry) this.geometry.dispose();
  }
};
var JointDebug = class extends Basic3D {
  constructor(o = {}) {
    super();
    this.isJoint = true;
    this.type = "joint";
    this.mode = o.mode || "hinge";
    this.visible = o.visible !== void 0 ? o.visible : false;
    this.mtx = new Matrix4();
    this.size = o.helperSize || 0.1;
    let material = Mat.get("line");
    let mat2, dt2;
    switch (this.mode) {
      case "prismatic":
        mat2 = Mat.get("svg");
        dt2 = {
          min: -180,
          max: 180,
          fill: false,
          stroke: true,
          wireframe: false,
          size: this.size * 0.5
        };
        if (o.lm) {
          dt2.min = o.lm[0];
          dt2.max = o.lm[1];
        }
        this.m1 = new AutoSvg("liner", dt2, mat2);
        this.m2 = new AutoSvg("middle", dt2, mat2);
        this.m1.geometry.rotateY(90 * MathTool.torad);
        this.add(this.m1);
        this.add(this.m2);
        break;
      case "hinge":
      case "cylindrical":
        mat2 = Mat.get("svg");
        dt2 = {
          min: -180,
          max: 180,
          fill: false,
          stroke: true,
          wireframe: false,
          size: this.size * 0.5
        };
        if (o.lm) {
          dt2.min = o.lm[0];
          dt2.max = o.lm[1];
        }
        if (o.lmr) {
          dt2.min = o.lmr[0];
          dt2.max = o.lmr[1];
        }
        this.m1 = new AutoSvg("angle", dt2, mat2);
        this.m2 = new AutoSvg("needle", dt2, mat2);
        this.add(this.m1);
        this.add(this.m2);
        break;
      default:
        const geom = Geo.get("joint");
        let g2 = geom.clone();
        g2.scale(this.size, this.size, this.size);
        this.m1 = new LineSegments(g2, material);
        this.add(this.m1);
        g2 = geom.clone();
        g2.scale(this.size * 0.8, this.size * 0.8, this.size * 0.8);
        this.m2 = new LineSegments(g2, material);
        this.add(this.m2);
        break;
    }
    this.m1.matrixAutoUpdate = false;
    this.m2.matrixAutoUpdate = false;
    this.body1 = null;
    this.body2 = null;
    this.mat1 = new Matrix4();
    this.mat2 = new Matrix4();
    this.end = new Vector3();
    let qq = new Quaternion();
    if (o.quat1) this.mat1.makeRotationFromQuaternion(qq.fromArray(o.quat1));
    if (o.quat2) this.mat2.makeRotationFromQuaternion(qq.fromArray(o.quat2));
    this.mat1.setPosition(o.pos1[0], o.pos1[1], o.pos1[2]);
    this.mat2.setPosition(o.pos2[0], o.pos2[1], o.pos2[2]);
    const positions = [0, 0, 0, 0, 0, 0];
    const colors = [1, 0, 0, 1, 0, 0];
    const gline = new BufferGeometry();
    gline.setAttribute("position", new Float32BufferAttribute(positions, 3));
    gline.setAttribute("color", new Float32BufferAttribute(colors, 3));
    gline.computeBoundingSphere();
    this.m3 = new LineSegments(gline, material);
    this.add(this.m3);
    this.m3.matrixAutoUpdate = false;
    this.pp = this.m3.geometry.attributes.position;
  }
  update() {
    if (!this.visible) return;
    if (this.body1) {
      this.matrix.copy(this.body1.matrixWorld).multiply(this.mat1);
    } else {
      this.matrix.copy(this.mat1);
    }
    if (this.body2) {
      this.m2.matrix.copy(this.body2.matrixWorld).multiply(this.mat2);
    } else {
      this.m2.matrix.copy(this.mat2);
    }
    this.m2.matrix.premultiply(this.matrix.clone().invert());
    this.end.setFromMatrixPosition(this.m2.matrix);
    this.pp.setXYZ(1, this.end.x, this.end.y, this.end.z);
    this.pp.needsUpdate = true;
    if (this.mode === "cylindrical") {
      this.m1.position.copy(this.end);
      this.m1.updateMatrix();
    }
    if (!this.visible) this.visible = true;
  }
  updateFromPhy(r, n2 = 0) {
    if (!this.visible) return;
    this.position.fromArray(r, n2);
    this.quaternion.fromArray(r, n2 + 3);
    this.updateMatrix();
    this.m2.position.fromArray(r, n2 + 7);
    this.m2.quaternion.fromArray(r, n2 + 10);
    this.m2.matrix.compose(this.m2.position, this.m2.quaternion, { x: 1, y: 1, z: 1 });
    this.mtx.copy(this.matrix).invert().multiply(this.m2.matrix);
    this.mtx.decompose(this.m2.position, this.m2.quaternion, { x: 1, y: 1, z: 1 });
    this.m2.updateMatrix();
    this.pp.setXYZ(1, this.m2.position.x, this.m2.position.y, this.m2.position.z);
    this.pp.needsUpdate = true;
    if (this.mode === "cylindrical") {
      this.m1.position.copy(this.m2.position);
      this.m1.updateMatrix();
    }
    if (!this.visible) this.visible = true;
  }
  dispose() {
    if (this.body1) this.body1.link--;
    if (this.body2) this.body2.link--;
    this.m1.geometry.dispose();
    this.m2.geometry.dispose();
    this.m3.geometry.dispose();
    this.children = [];
  }
};
var Joint = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "joint";
    this.v1 = new Vector3();
    this.v2 = new Vector3();
  }
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    let i = this.list.length, j, n2;
    while (i--) {
      j = this.list[i];
      n2 = N + i * Num.joint;
      if (Num.joint === 16) j.updateFromPhy(AR, n2);
      else j.update();
    }
  }
  ///
  add(o = {}) {
    let name = this.setName(o);
    let body1 = null;
    let body2 = null;
    let isString;
    let isWorldAxis = false;
    if (!o.axis1) o.axis1 = [1, 0, 0];
    if (!o.axis2) o.axis2 = [1, 0, 0];
    if (!o.pos1) o.pos1 = [0, 0, 0];
    if (!o.pos2) o.pos2 = [0, 0, 0];
    if (o.limit) o.lm = o.limit;
    else if (o.lm) o.limit = o.lm;
    if (o.mode === "universal" || o.mode === "dof" || o.mode === "d6") o.mode = "generic";
    if (o.mode === "revolute") o.mode = "hinge";
    if (o.mode === "slider") o.mode = "cylindrical";
    if (o.b1) {
      isString = typeof o.b1 === "string";
      body1 = isString ? Utils.byName(o.b1) : o.b1;
      if (!isString) o.b1 = o.b1.name;
      if (body1) body1.link++;
    }
    if (o.b2) {
      isString = typeof o.b2 === "string";
      body2 = isString ? Utils.byName(o.b2) : o.b2;
      if (!isString) o.b2 = o.b2.name;
      if (body2) body2.link++;
    }
    if (o.worldPos) o.worldAnchor = o.worldPos;
    if (o.worldAnchor) {
      o.pos1 = body1 ? Utils.toLocal(this.v1.fromArray(o.worldAnchor), body1).toArray() : o.worldAnchor;
      o.pos2 = body2 ? Utils.toLocal(this.v2.fromArray(o.worldAnchor), body2).toArray() : o.worldAnchor;
      delete o.worldAnchor;
    }
    if (o.worldAxis) {
      o.axis1 = body1 ? Utils.toLocal(this.v1.fromArray(o.worldAxis), body1, true).toArray() : o.worldAxis;
      o.axis2 = body2 ? Utils.toLocal(this.v2.fromArray(o.worldAxis), body2, true).toArray() : o.worldAxis;
      isWorldAxis = true;
      delete o.worldAxis;
    }
    if (o.worldQuat) {
      o.quat1 = Utils.quatLocal(o.worldQuat, body1);
      o.quat2 = Utils.quatLocal(o.worldQuat, body2);
      if (root.engine === "OIMO" || root.engine === "HAVOK" || root.engine === "JOLT") {
        o.axis1 = Utils.axisLocal(MathTool.quatToAxis(o.worldQuat), body1);
        o.axis2 = Utils.axisLocal(MathTool.quatToAxis(o.worldQuat), body2);
      }
      delete o.worldQuat;
    }
    if (o.rot1 !== void 0) {
      o.quat1 = MathTool.quatFromEuler(o.rot1);
      delete o.rot1;
    }
    if (o.rot2 !== void 0) {
      o.quat2 = MathTool.quatFromEuler(o.rot2);
      delete o.rot2;
    }
    if (!o.quat1) o.quat1 = new Quaternion().setFromUnitVectors(new Vector3(1, 0, 0), new Vector3().fromArray(o.axis1).normalize()).toArray();
    if (!o.quat2) o.quat2 = new Quaternion().setFromUnitVectors(new Vector3(1, 0, 0), new Vector3().fromArray(o.axis2).normalize()).toArray();
    if (root.engine === "AMMO" && isWorldAxis && o.mode === "hinge") {
      let ee = new Euler(0, -90 * torad$3, 0);
      let qq = new Quaternion().setFromEuler(ee).toArray();
      o.quatX = qq;
    }
    if (o.drivePosition) {
      if (o.drivePosition.rot !== void 0) {
        o.drivePosition.quat = MathTool.quatFromEuler(o.drivePosition.rot);
        delete o.drivePosition.rot;
      }
    }
    let j = new JointDebug(o);
    j.name = name;
    j.body1 = body1;
    j.body2 = body2;
    if (o.visible === void 0) o.visible = root.jointVisible || false;
    this.set(o, j);
    this.addToWorld(j, o.id);
    root.post({ m: "add", o });
    return j;
  }
  set(o = {}, j = null) {
    if (j === null) j = this.byName(o.name);
    if (j === null) return;
    if (o.visible !== void 0) j.visible = o.visible;
  }
};
var Contact = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "contact";
  }
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    let i = this.list.length, c, n2;
    while (i--) {
      c = this.list[i];
      n2 = N + i * Num.contact;
      c.update(AR, n2);
    }
  }
  add(o = {}) {
    this.setName(o);
    let c = new Pair(o);
    if (o.callback) delete o.callback;
    this.addToWorld(c, o.id);
    root.post({ m: "add", o });
    return c;
  }
};
var Pair = class {
  constructor(o = {}) {
    this.type = "contact";
    this.name = o.name;
    this.callback = o.callback || function() {
    };
    this.b1 = o.b1 || null;
    this.b2 = o.b2 || null;
    this.ignore = o.ignore || [];
    this.always = o.always !== void 0 ? o.always : true;
    this.simple = o.simple || false;
    this.data = {
      hit: false,
      point: [0, 0, 0],
      normal: [0, 0, 0]
      //object: null,
    };
  }
  update(r, n2 = 0) {
    this.data.hit = r[n2] > 0 ? true : false;
    if (!this.simple) {
      this.data.point = [r[n2 + 1], r[n2 + 2], r[n2 + 3]];
      this.data.normal = [r[n2 + 4], r[n2 + 5], r[n2 + 6]];
    }
    if (this.data.hit || this.always) this.callback(this.data);
  }
};
var Vehicle = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "vehicle";
    this.num = Num[this.type];
  }
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    let i = this.list.length, n2, s;
    while (i--) {
      s = this.list[i];
      n2 = N + i * this.num;
      s.step(AR, n2);
    }
  }
  add(o = {}) {
    this.setName(o);
    const car = new Car(o);
    this.addToWorld(car, o.id);
    root.post({ m: "add", o: car.o });
    return car;
  }
  set(o = {}, b = null) {
    if (b === null) b = this.byName(o.name);
    if (b === null) return;
  }
};
var Car = class extends Basic3D {
  //extends Object3D {
  constructor(o) {
    super();
    if (o.extra) {
      this.extra = o.extra;
      delete o.extra;
    }
    this.type = "vehicle";
    this.name = o.name || "car";
    this.isRay = o.ray || false;
    this.actif = false;
    this.steering = 0;
    this.suspension = [];
    this.rolling = [];
    this.init(o);
  }
  drive() {
  }
  raycast() {
    return;
  }
  init(o) {
    this.mass = o.mass || 2e3;
    this.model = null;
    this.size = o.size || [0.85 * 2, 0.5 * 2, 2.5 * 2];
    this.massCenter = o.massCenter || [0, 0.55, 1.594];
    this.chassisPos = o.chassisPos || [0, 0.83, 0];
    this.maxSteering = o.maxSteering || 24;
    this.incSteering = o.incSteering || 2;
    this.s_travel = o.s_travel || 0.4;
    this.s_ratio = 1 / (this.s_travel * 0.5);
    this.decaly = root.engine === "PHYSX" ? this.s_travel * 0.5 : 0;
    this.numWheel = o.numWheel || 4;
    this.radius = o.radius || 0.35;
    this.radiusBack = o.radiusBack || this.radius;
    this.deep = o.deep || 0.3;
    this.deepBack = o.deepBack || this.deep;
    let byAxe = this.numWheel < 4 ? 1 : 2;
    if (!o.wPos) o.wPos = [0.8, 0.1, 1.4];
    if (o.wPos) {
      this.wPos = o.wPos;
      var p2, wp = o.wPos, axe, pp = [], s = 1, back = 0, y, x2, z, pzz;
      wp.length === 3 ? true : false;
      wp.length === 4 ? true : false;
      for (let i = 0; i < this.numWheel; i++) {
        s = i % 2 === 0 ? -1 : 1;
        axe = Math.floor(i * 0.5);
        back = i >= byAxe ? true : false;
        y = wp[1];
        if (y === 0) y = back ? this.radiusBack : this.radius;
        x2 = wp[0];
        if (x2 instanceof Array) x2 = wp[0][axe];
        z = back ? -wp[2] : wp[2];
        if (wp[2] instanceof Array) z = wp[2][axe];
        p2 = [x2 * s, y, z];
        pp.push(p2);
      }
      this.wheelsPosition = pp;
      delete o.wPos;
    }
    if (o.wheelsPosition) this.wheelsPosition = o.wheelsPosition;
    const scale = o.meshScale || 1;
    const chassisShapes = [];
    if (o.chassisShape) chassisShapes.push({ type: "convex", shape: o.chassisShape, size: [scale], pos: this.chassisPos, filter: [1, -1, 0, 0], isExclusive: true, ray: this.isRay });
    else chassisShapes.push({ type: "box", size: this.size, pos: this.chassisPos });
    for (let i = 0; i < this.numWheel; i++) {
      if (i < byAxe) chassisShapes.push({ type: "cylinder", size: [this.radius, this.deep], isWheel: true, radius: o.rad || 0.05, shadow: false, ray: false });
      else chassisShapes.push({ type: "cylinder", size: [this.radiusBack, this.deepBack], isWheel: true, radius: o.rad || 0.05, shadow: false, ray: false });
    }
    var material = Mat.get(o.debug ? "debug" : o.chassisMesh === void 0 ? "body" : "hide");
    let n2;
    for (let i = 0; i < chassisShapes.length; i++) {
      n2 = chassisShapes[i];
      if (n2.pos) n2.localPos = n2.pos;
      n2.size = MathTool.autoSize(n2.size, n2.type);
      root.items.body.geometry(n2, this, material);
    }
    let m2;
    if (o.chassisMesh) {
      m2 = o.noClone ? o.chassisMesh : o.chassisMesh.clone();
      m2.position.set(0, 0, 0);
      Utils.noRay(m2);
      m2.scale.set(scale, scale, scale);
      this.children[0].add(m2);
      this.model = m2;
      delete o.chassisMesh;
    }
    if (o.wheelMesh) {
      for (let i = 1; i < this.numWheel + 1; i++) {
        back = i >= byAxe + 1;
        if (o.wheelMeshBack) m2 = back ? o.wheelMeshBack.clone() : o.wheelMesh.clone();
        else m2 = o.wheelMesh.clone();
        Utils.noRay(m2);
        m2.position.set(0, 0, 0);
        if (i == 2 || i == 4) m2.scale.set(-scale, scale, scale);
        else m2.scale.set(scale, scale, scale);
        this.children[i].add(m2);
      }
      delete o.wheelMesh;
    }
    if (o.suspensionMesh) {
      this.suspensionMesh = [];
      for (let i = 1; i < this.numWheel + 1; i++) {
        m2 = o.suspensionMesh.clone();
        Utils.noRay(m2);
        m2.position.set(0, 0, 0);
        m2.position.fromArray(this.wheelsPosition[i - 1]);
        m2.position.x = 0;
        if (i == 2 || i == 4) m2.scale.set(scale, scale, scale);
        else m2.scale.set(-scale, scale, scale);
        this.children[0].add(m2);
        this.suspensionMesh.push(m2);
      }
      delete o.suspensionMesh;
    }
    if (o.brakeMesh) {
      this.brake = [];
      for (let i = 1; i < this.numWheel + 1; i++) {
        back = i > 2;
        if (o.brakeMeshBack) m2 = back ? o.brakeMeshBack.clone() : o.brakeMesh.clone();
        else m2 = o.brakeMesh.clone();
        Utils.noRay(m2);
        m2.position.set(0, 0, 0);
        m2.position.fromArray(this.wheelsPosition[i - 1]);
        if (o.brakeMeshBack) pzz = scale;
        else pzz = back ? scale : -scale;
        if (i == 2 || i == 4) m2.scale.set(-scale, scale, pzz);
        else m2.scale.set(scale, scale, pzz);
        this.children[0].add(m2);
        this.brake.push(m2);
      }
      delete o.brakeMesh;
    }
    o.mass = this.mass;
    o.size = o.chassisShape ? chassisShapes[0].boxSize : this.size;
    o.numWheel = this.numWheel;
    o.wheelsPosition = this.wheelsPosition;
    o.radius = this.radius;
    o.radiusBack = this.radiusBack;
    o.deep = this.deep;
    o.deepBack = this.deepBack;
    o.chassisShape = chassisShapes[0];
    o.maxSteering = this.maxSteering;
    o.incSteering = this.incSteering;
    o.s_travel = this.s_travel;
    o.massCenter = this.massCenter;
    o.chassisPos = this.chassisPos;
    this.o = o;
  }
  set(o) {
    o.name = this.name;
    root.motor.change(o);
  }
  respawn(o) {
    o = o || {};
    o.respawn = true;
    o.name = this.name;
    if (o.keepRotation) o.quat = this.quaternion.toArray();
    root.motor.change(o);
  }
  move() {
  }
  dispose() {
  }
  step(AR, n2) {
    if (!this.actif) {
      let a = AR[n2 + 0] + AR[n2 + 1] + AR[n2 + 2] + AR[n2 + 3] + AR[n2 + 4] + AR[n2 + 5] + AR[n2 + 6] + AR[n2 + 7];
      if (a === 0) return;
      else this.actif = true;
    }
    this.position.fromArray(AR, n2 + 1);
    this.quaternion.fromArray(AR, n2 + 4);
    this.updateMatrix();
    let num = this.numWheel + 1;
    let mesh;
    let s1 = 0, s2 = 0;
    let sp = [];
    let k = 0;
    for (let i = 0; i < num; i++) {
      k = i * 8 + n2;
      if (i === 0) AR[k] / this.circum;
      if (i === 1) s1 = AR[k];
      if (i === 2) s2 = AR[k];
      mesh = this.children[i];
      if (mesh && i > 0) {
        sp[i - 1] = this.wheelsPosition[i - 1][1] - this.decaly - AR[k + 2];
        mesh.position.fromArray(AR, k + 1);
        mesh.quaternion.fromArray(AR, k + 4);
        this.rolling[i - 1] = mesh.rotation.x;
        if (this.brake) {
          this.brake[i - 1].position.copy(mesh.position);
          if (i == 1 || i == 2) this.brake[i - 1].rotation.y = AR[k];
        }
      }
    }
    k = 4;
    while (k--) {
      this.suspension[k] = MathTool.clamp(sp[k] * this.s_ratio, -1, 1);
      if (this.suspensionMesh) {
        if (this.suspension[k] > 0) {
          Utils.morph(this.suspensionMesh[k].children[0], "low", this.suspension[k]);
          Utils.morph(this.suspensionMesh[k].children[0], "top", 0);
        } else {
          Utils.morph(this.suspensionMesh[k].children[0], "low", 0);
          Utils.morph(this.suspensionMesh[k].children[0], "top", -this.suspension[k]);
        }
      }
    }
    this.steering = Math.round((s1 + s2) * 0.5 * todeg$1) / this.maxSteering;
  }
};
var _endMatrix = new Matrix4();
var _p = new Vector3();
var _q$1 = new Quaternion();
var _s = new Vector3();
var _matrixWorldInv = new Matrix4();
var _boneMatrix = new Matrix4();
var Spine = ["hip", "abdomen", "chest", "neck", "head", "rCollar", "lCollar", "lShldr", "rShldr", "lThigh", "rThigh", "rBreast", "lBreast"];
var SkeletonBody = class extends Object3D {
  constructor(name, model2, bones, mass = null, option = {}) {
    super();
    this.prefix = name || "yoo_";
    this.mode = "follow";
    this.withFinger = false;
    this.nodes = [];
    this.bones = bones;
    this.model = model2;
    this.scaler = this.model.scale.x;
    this.posRef = {};
    this.quatRef = {};
    this.useSolver = false;
    if (root.engine !== "PHYSX") this.useSolver = false;
    this.nameList = [];
    this.jointList = [];
    this.breast = false;
    this.ready = false;
    this.matrixAutoUpdate = false;
    this.mass = mass;
    this.friction = 0.5;
    this.restitution = 0;
    this.option = option;
    this.useDrive = option.useDrive !== void 0 ? option.useDrive : true;
    this.showJoint = option.showJoint !== void 0 ? option.showJoint : false;
    this.init();
  }
  setMass(mass) {
    if (mass === this.mass) return;
    this.mass = mass;
    const d = [];
    let i = this.nodes.length;
    let m2 = this.mass / i;
    while (i--) d.push({ name: this.nodes[i].name, mass: m2 });
    root.motor.change(d);
  }
  setMode(mode) {
    if (mode === this.mode) return;
    this.mode = mode;
    const data = [];
    let kinematic = this.mode === "follow";
    let i = this.nodes.length, node;
    while (i--) {
      node = this.nodes[i];
      data.push({ name: node.name, kinematic });
      node.kinematic = kinematic;
      node.bone.isPhysics = !kinematic;
    }
    root.motor.change(data);
  }
  freeBone(node) {
    if (!node.kinematic) return;
    node.cc++;
    if (node.cc === 20) {
      node.cc = 0;
      node.kinematic = false;
      node.bone.isPhysics = true;
      root.motor.change({ name: node.name, kinematic: false });
    }
  }
  isVisible(v) {
    let i = this.nameList.length;
    while (i--) Utils.byName(this.nameList[i]).visible = v;
  }
  init() {
    if (this.useSolver) this.solver = root.motor.add({
      type: "solver",
      name: this.prefix + "_solver",
      iteration: 32,
      fix: true,
      needData: true
    });
    this.useAggregate = root.engine === "PHYSX";
    const data = [];
    let scaleMatrix = new Matrix4().makeScale(this.scaler, this.scaler, this.scaler);
    let p2 = new Vector3();
    let s = new Vector3();
    let q = new Quaternion();
    let e = new Euler();
    let mtx = new Matrix4();
    let tmpMtx = new Matrix4();
    let tmpMtxR = new Matrix4();
    _matrixWorldInv.copy(this.model.matrixWorld).invert();
    let p1 = new Vector3();
    let p22 = new Vector3();
    let sizer = [1, 1, 1, 1, 1, 1, 1];
    if (this.option.sizer) {
      sizer = this.option.sizer;
    }
    let i, lng = this.bones.length, name, n2, bone, parent;
    let size, dist, rot, type, kinematic, translate, phyName, motion;
    let averageMass = 0;
    if (this.mass) averageMass = this.mass / lng;
    for (i = 0; i < lng; i++) {
      type = null;
      bone = this.bones[i];
      name = bone.name;
      parent = bone.parent;
      if (parent) {
        n2 = parent.name;
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        p1.setFromMatrixPosition(_boneMatrix);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, parent.matrixWorld);
        p22.setFromMatrixPosition(_boneMatrix);
        dist = p1.distanceTo(p22);
        translate = [0, 0, dist * 0.5];
        size = [dist, 1, 1];
        rot = null;
        kinematic = true;
        motion = false;
        if (n2 === "hip" && name === "abdomen") {
          type = "capsule";
          size = [dist * sizer[0], 0.08];
          translate = [0, 0, -dist * sizer[0]];
          rot = [0, 0, 90];
        }
        if (n2 === "abdomen" && name === "chest") {
          type = "capsule";
          size = [dist * 0.7 * sizer[1], 0.08];
          translate = [0, 0, -dist * 0.5 - 0.06];
          rot = [90, 0, 0];
        }
        if (n2 === "chest" && name === "neck") {
          type = "capsule";
          size = [dist * 0.4 * sizer[2], 0.04];
          translate = [0, 0, -dist * 0.5 - 0.02];
          rot = [0, 0, 90];
        }
        if (n2 === "neck" && name === "head") {
          type = "capsule";
          size = [0.06 * sizer[3], dist];
          translate = [0, 0, -dist * 0.5];
          rot = [90, 0, 0];
        }
        if (n2 === "head" && name === "End_head") {
          type = "capsule";
          size = [0.1 * sizer[4], dist - 0.17];
          translate = [0, 0.02, -dist * 0.5 + 0.02];
          rot = [90, 0, 0];
        }
        if (n2 === "chest" && name === "rBreast" && root.engine !== "HAVOK") {
          n2 = "rBreast";
          parent = bone;
          type = "sphere";
          size = [0.065];
          translate = [0.065, 0, 0];
          this.breast = true;
          motion = true;
        }
        if (n2 === "chest" && name === "lBreast" && root.engine !== "HAVOK") {
          n2 = "lBreast";
          parent = bone;
          type = "sphere";
          size = [0.065];
          translate = [0.065, 0, 0];
          this.breast = true;
          motion = true;
        }
        let r = 0.04 * sizer[5];
        let w = dist - r;
        if (n2 === "lCollar" && name === "lShldr") {
          type = "capsule";
          size = [r, dist * 0.3];
          translate = [dist * 0.6, 0, 0];
          rot = [0, 0, 90];
        }
        if (n2 === "lShldr" && name === "lForeArm") {
          type = "capsule";
          size = [r, w];
          translate = [w * 0.5, 0, 0];
          rot = [0, 0, 90];
        }
        if (n2 === "lForeArm" && name === "lHand") {
          type = "capsule";
          size = [r, w];
          translate = [w * 0.5, 0, 0];
          rot = [0, 0, 90];
        }
        if (n2 === "lHand" && name === "lMid1") {
          type = "box";
          size = [dist * 2, 0.09, 0.05];
          translate = [dist, 0, 0];
        }
        if (n2 === "rCollar" && name === "rShldr") {
          type = "capsule";
          size = [r, dist * 0.3];
          translate = [-dist * 0.6, 0, 0];
          rot = [0, 0, 90];
        }
        if (n2 === "rShldr" && name === "rForeArm") {
          type = "capsule";
          size = [r, w];
          translate = [-w * 0.5, 0, 0];
          rot = [0, 0, 90];
        }
        if (n2 === "rForeArm" && name === "rHand") {
          type = "capsule";
          size = [r, w];
          translate = [-w * 0.5, 0, 0];
          rot = [0, 0, 90];
        }
        if (n2 === "rHand" && name === "rMid1") {
          type = "box";
          size = [dist * 2, 0.09, 0.05];
          translate = [-dist, 0, 0];
        }
        r = 0.06 * sizer[6];
        w = dist - r;
        if (n2 === "lThigh") {
          type = "capsule";
          size = [r, dist];
          rot = [90, 0, 0];
          translate = [0, 0, w * 0.5];
        }
        if (n2 === "lShin") {
          type = "capsule";
          size = [r, dist];
          rot = [90, 0, 0];
          translate = [0, 0, w * 0.5];
        }
        if (n2 === "lFoot") {
          type = "capsule";
          size = [0.05, dist];
          translate = [0, dist * 0.5 - 0.025, 0.04];
        }
        if (n2 === "rThigh") {
          type = "capsule";
          size = [r, dist];
          rot = [90, 0, 0];
          translate = [0, 0, w * 0.5];
        }
        if (n2 === "rShin") {
          type = "capsule";
          size = [r, dist];
          rot = [90, 0, 0];
          translate = [0, 0, w * 0.5];
        }
        if (n2 === "rFoot") {
          type = "capsule";
          size = [0.05, dist];
          translate = [0, dist * 0.5 - 0.025, 0.04];
        }
        r = 0.04;
        w = dist - r;
        if (n2 === "rEar_0") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
          Spine.push("rEar_0");
        }
        if (n2 === "rEar_1") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
          Spine.push("rEar_1");
        }
        if (n2 === "rEar_2") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
          Spine.push("rEar_2");
        }
        if (n2 === "rEar_3") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
        }
        if (n2 === "lEar_0") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
          Spine.push("lEar_0");
        }
        if (n2 === "lEar_1") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
          Spine.push("lEar_1");
        }
        if (n2 === "lEar_2") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
          Spine.push("lEar_2");
        }
        if (n2 === "lEar_3") {
          type = "capsule";
          size = [r, dist];
          rot = [0, 0, 90];
          translate = [w * 0.5, 0, 0];
        }
        if (this.withFinger) {
          if (n2 === "lHand" && name === "lMid1") {
            type = "box";
            size = [dist, 0.09, 0.05];
            translate = [dist * 0.5, 0, 0];
          }
          if (n2 === "rHand" && name === "rMid1") {
            type = "box";
            size = [dist, 0.09, 0.05];
            translate = [-dist * 0.5, 0, 0];
          }
          if (n2 === "rThumb1" && name === "rThumb2") {
            type = "capsule";
            size = [0.02, dist];
            rot = [0, 0, 90];
          }
          if (n2 === "rThumb2" && name === "rThumb3") {
            type = "capsule";
            size = [0.02, dist];
            rot = [0, 0, 90];
          }
          if (n2 === "rHand" && name === "rMid1") {
            type = "capsule";
            size = [0.02, dist];
            rot = [0, 0, 90];
            translate = [-dist * 0.6, 0, 0];
          }
          if (n2 === "rMid1" && name === "rMid2") {
            type = "capsule";
            size = [0.02, dist];
            rot = [0, 0, 90];
            translate = [-dist * 0.6, 0, 0];
          }
          if (n2 === "rMid2" && name === "rMid3") {
            type = "capsule";
            size = [0.02, dist];
            rot = [0, 0, 90];
            translate = [-dist * 0.6, 0, 0];
          }
        }
        if (type !== null) {
          phyName = this.prefix + "_bone_" + n2;
          tmpMtx.makeTranslation(translate[0], translate[1], translate[2]);
          if (rot) {
            tmpMtxR.makeRotationFromEuler(e.set(rot[0] * torad$3, rot[1] * torad$3, rot[2] * torad$3));
            tmpMtx.multiply(tmpMtxR);
          }
          parent.updateWorldMatrix(true, false);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, parent.matrixWorld);
          mtx.copy(_boneMatrix);
          mtx.decompose(p2, q, s);
          this.posRef[phyName] = p2.toArray();
          if (n2 === "lForeArm" || n2 === "rForeArm") {
            _q$1.setFromAxisAngle({ x: 0, y: 1, z: 0 }, -90 * torad$3);
            q.multiply(_q$1);
          }
          this.quatRef[phyName] = q.toArray();
          mtx.multiplyMatrices(_boneMatrix, tmpMtx);
          mtx.decompose(p2, q, s);
          this.nameList.push(phyName);
          let bb = {
            name: phyName,
            friction: this.friction,
            restitution: this.restitution,
            type,
            size: MathTool.scaleArray(size, this.scaler, 3),
            pos: p2.toArray(),
            //rot: rot,
            quat: q.toArray(),
            kinematic,
            //group:16,
            //mask:mask,
            //mask:0,
            material: "hide",
            //material:'debug',
            shadow: false,
            neverSleep: true,
            helper: true,
            hcolor: [0, 0.5, 1],
            hcolor2: [0, 0.2, 1],
            //hcolor:[0.87, 0.76, 0.65],
            //hcolor2:[0.9, 0.77, 0.64],
            penetrationVelocity: 3,
            stabilization: 0.1,
            //maxVelocity:[100,10],
            damping: [0.25, 0.5],
            //maxAngularVelocity:3,
            //linked:link,
            //iterations:[4,4],
            //inertiaScale:[20,20,20],
            //iterations:[4,2],
            /*bone:parent,
            decal:tmpMtx.clone(),
            decalinv:tmpMtx.clone().invert(),*/
            ...this.option
          };
          if (this.useAggregate) {
            if (Spine.indexOf(n2) !== -1) {
              bb["aggregate"] = this.prefix + "__Group";
              bb["aggregateMax"] = 21;
            }
            bb["mask"] = 1 | 2;
          } else {
            let mask = 1 | 2;
            if (n2 === "lForeArm" || n2 === "rForeArm" || n2 === "lShin" || n2 === "rShin") mask = 1 | 2 | 32;
            if (n2 === "rEar_1" || n2 === "rEar_2" || n2 === "rEar_3" || n2 === "lEar_1" || n2 === "lEar_2" || n2 === "lEar_3") mask = 1 | 2 | 32;
            if (n2 === "rEar_0" || n2 === "rEar_0") mask = 0;
            bb["group"] = 32;
            bb["mask"] = mask;
          }
          if (this.mass !== null) bb["mass"] = averageMass;
          else bb["density"] = 1;
          data.push(bb);
          let inv = tmpMtx.clone().invert().premultiply(scaleMatrix);
          this.nodes.push({
            name: phyName,
            kinematic,
            motion,
            // auto move
            bone: parent,
            decal: tmpMtx.clone(),
            decalinv: inv,
            quat: q.toArray(),
            pos: p2.toArray(),
            //scaler:this.scaler,
            cc: 0
          });
        }
      }
    }
    root.motor.add(data);
    this.addLink();
    this.dispatchEvent({ type: "start", message: "go !" });
    this.ready = true;
  }
  existe(name) {
    return this.nameList.indexOf(name) !== -1 ? true : false;
  }
  addLink() {
    let sp = [0.05, 1, 0];
    if (root.engine === "PHYSX") {
      sp = [50, 10, 0, 0.5];
    }
    let driveSetting = {
      stiffness: 2,
      damping: 0.1,
      forceLimit: 1e7,
      isAcceleration: false
    };
    let p2 = this.prefix + "_bone_";
    let data = [];
    let sett = {
      type: "joint",
      mode: "d6",
      lm: [["ry", -180, 180, ...sp], ["rz", -180, 180, ...sp]],
      collision: false,
      helperSize: 0.05,
      visible: this.showJoint
      //acc:true,
      //worldAxis:[1,0,0],
      //autoDrive: true,
      /*drives: [
      ['rx', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ],
      ['ry', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ],
      ['rz', driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration ]
      ],*/
    };
    if (this.useDrive) {
      sett["drives"] = [
        ["rx", driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration],
        ["ry", driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration],
        ["rz", driveSetting.stiffness, driveSetting.damping, driveSetting.forceLimit, driveSetting.isAcceleration]
      ];
    }
    let breastMotion = [-1e-3, 1e-3, 100, 0.2, 0.5];
    data.push({ ...sett, b1: p2 + "hip", b2: p2 + "abdomen", worldPos: this.posRef[p2 + "abdomen"], worldQuat: this.quatRef[p2 + "hip"], lm: [["rx", -20, 20, ...sp], ["ry", -20, 20, ...sp], ["rz", -20, 20, ...sp]] });
    data.push({ ...sett, b1: p2 + "abdomen", b2: p2 + "chest", worldPos: this.posRef[p2 + "chest"], worldQuat: this.quatRef[p2 + "chest"], lm: [["rx", -20, 20, ...sp], ["ry", -20, 20, ...sp], ["rz", -20, 20, ...sp]] });
    data.push({ ...sett, b1: p2 + "chest", b2: p2 + "neck", worldPos: this.posRef[p2 + "neck"], worldQuat: this.quatRef[p2 + "neck"], lm: [["rx", 0, 30, ...sp], ["ry", -1, 1, ...sp], ["rz", -30, 30, ...sp]] });
    data.push({ ...sett, b1: p2 + "neck", b2: p2 + "head", worldPos: this.posRef[p2 + "head"], worldQuat: this.quatRef[p2 + "head"], lm: [["rx", 0, 30, ...sp], ["ry", -1, 1, ...sp], ["rz", -30, 30, ...sp]] });
    data.push({ ...sett, b1: p2 + "chest", b2: p2 + "rCollar", worldPos: this.posRef[p2 + "rCollar"], worldQuat: this.quatRef[p2 + "rCollar"], mode: "fixe" });
    data.push({ ...sett, b1: p2 + "chest", b2: p2 + "lCollar", worldPos: this.posRef[p2 + "lCollar"], worldQuat: this.quatRef[p2 + "lCollar"], mode: "fixe" });
    data.push({ ...sett, b1: p2 + "rCollar", b2: p2 + "rShldr", worldPos: this.posRef[p2 + "rShldr"], worldQuat: this.quatRef[p2 + "rShldr"] });
    data.push({ ...sett, b1: p2 + "lCollar", b2: p2 + "lShldr", worldPos: this.posRef[p2 + "lShldr"], worldQuat: this.quatRef[p2 + "lShldr"] });
    if (this.existe(p2 + "rForeArm")) data.push({ ...sett, b1: p2 + "rShldr", b2: p2 + "rForeArm", worldPos: this.posRef[p2 + "rForeArm"], worldQuat: this.quatRef[p2 + "rForeArm"], lm: [["rx", 0, 160, ...sp]] });
    if (this.existe(p2 + "lForeArm")) data.push({ ...sett, b1: p2 + "lShldr", b2: p2 + "lForeArm", worldPos: this.posRef[p2 + "lForeArm"], worldQuat: this.quatRef[p2 + "lForeArm"], lm: [["rx", 0, 160, ...sp]] });
    if (this.existe(p2 + "rHand")) data.push({ ...sett, b1: p2 + "rForeArm", b2: p2 + "rHand", worldPos: this.posRef[p2 + "rHand"], worldQuat: this.quatRef[p2 + "rHand"], lm: [["rx", 0, 160, ...sp], ["ry", -10, 10, ...sp]] });
    if (this.existe(p2 + "lHand")) data.push({ ...sett, b1: p2 + "lForeArm", b2: p2 + "lHand", worldPos: this.posRef[p2 + "lHand"], worldQuat: this.quatRef[p2 + "lHand"], lm: [["rx", 0, 160, ...sp], ["ry", -10, 10, ...sp]] });
    data.push({ ...sett, b1: p2 + "hip", b2: p2 + "rThigh", worldPos: this.posRef[p2 + "rThigh"], worldQuat: this.quatRef[p2 + "rThigh"] });
    data.push({ ...sett, b1: p2 + "hip", b2: p2 + "lThigh", worldPos: this.posRef[p2 + "lThigh"], worldQuat: this.quatRef[p2 + "lThigh"] });
    if (this.existe(p2 + "rShin")) data.push({ ...sett, b1: p2 + "rThigh", b2: p2 + "rShin", worldPos: this.posRef[p2 + "rShin"], lm: [["rx", 0, 160, ...sp]], worldQuat: this.quatRef[p2 + "rShin"] });
    if (this.existe(p2 + "lShin")) data.push({ ...sett, b1: p2 + "lThigh", b2: p2 + "lShin", worldPos: this.posRef[p2 + "lShin"], lm: [["rx", 0, 160, ...sp]], worldQuat: this.quatRef[p2 + "lShin"] });
    if (this.existe(p2 + "rFoot")) data.push({ ...sett, b1: p2 + "rShin", b2: p2 + "rFoot", worldPos: this.posRef[p2 + "rFoot"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]], worldQuat: this.quatRef[p2 + "rFoot"] });
    if (this.existe(p2 + "lFoot")) data.push({ ...sett, b1: p2 + "lShin", b2: p2 + "lFoot", worldPos: this.posRef[p2 + "lFoot"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]], worldQuat: this.quatRef[p2 + "lFoot"] });
    if (this.breast) {
      if (this.existe(p2 + "rBreast")) data.push({ ...sett, b1: p2 + "chest", b2: p2 + "rBreast", worldPos: this.posRef[p2 + "rBreast"], worldQuat: this.quatRef[p2 + "rBreast"], lm: [["x", ...breastMotion], ["y", ...breastMotion], ["z", ...breastMotion]] });
      if (this.existe(p2 + "lBreast")) data.push({ ...sett, b1: p2 + "chest", b2: p2 + "lBreast", worldPos: this.posRef[p2 + "lBreast"], worldQuat: this.quatRef[p2 + "lBreast"], lm: [["x", ...breastMotion], ["y", ...breastMotion], ["z", ...breastMotion]] });
    }
    if (this.existe(p2 + "lEar_0")) data.push({ ...sett, b1: p2 + "head", b2: p2 + "lEar_0", worldPos: this.posRef[p2 + "lEar_0"], worldQuat: this.quatRef[p2 + "lEar_0"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "lEar_1")) data.push({ ...sett, b1: p2 + "lEar_0", b2: p2 + "lEar_1", worldPos: this.posRef[p2 + "lEar_1"], worldQuat: this.quatRef[p2 + "lEar_1"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "lEar_2")) data.push({ ...sett, b1: p2 + "lEar_1", b2: p2 + "lEar_2", worldPos: this.posRef[p2 + "lEar_2"], worldQuat: this.quatRef[p2 + "lEar_2"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "lEar_3")) data.push({ ...sett, b1: p2 + "lEar_2", b2: p2 + "lEar_3", worldPos: this.posRef[p2 + "lEar_3"], worldQuat: this.quatRef[p2 + "lEar_3"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "rEar_0")) data.push({ ...sett, b1: p2 + "head", b2: p2 + "rEar_0", worldPos: this.posRef[p2 + "rEar_0"], worldQuat: this.quatRef[p2 + "rEar_0"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "rEar_1")) data.push({ ...sett, b1: p2 + "rEar_0", b2: p2 + "rEar_1", worldPos: this.posRef[p2 + "rEar_1"], worldQuat: this.quatRef[p2 + "rEar_1"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "rEar_2")) data.push({ ...sett, b1: p2 + "rEar_1", b2: p2 + "rEar_2", worldPos: this.posRef[p2 + "rEar_2"], worldQuat: this.quatRef[p2 + "rEar_2"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    if (this.existe(p2 + "rEar_3")) data.push({ ...sett, b1: p2 + "rEar_2", b2: p2 + "rEar_3", worldPos: this.posRef[p2 + "rEar_3"], worldQuat: this.quatRef[p2 + "rEar_3"], lm: [["rx", -10, 30, ...sp], ["rz", -10, 10, ...sp]] });
    let x2 = 0;
    for (let j in data) {
      data[j].name = this.prefix + "_joint_" + x2;
      this.jointList.push(data[j].name);
      x2++;
    }
    root.motor.add(data);
  }
  /*makeLink () {
  
          let p = this.prefix;
          let data = []
          data.push({ type:'joint', mode:'d6', b1:p+'hip', b2:p+'abdomen', visible:true })
          data.push({ type:'joint', mode:'d6', b1:p+'abdomen', b2:p+'chest', visible:true })
          //data.push({ type:'joint', mode:'d6', b1:this.prefix*'chest', b2:this.prefix*'abdomen' })
  
          //console.log(this.prefix, data)
  
          root.motor.add( data )
  
      }*/
  updateMatrixWorld(force) {
    if (!this.ready) return;
    let up = [];
    const nodes = this.nodes;
    let i = nodes.length, node, bone, body, n2 = 0;
    while (i--) {
      node = nodes[n2];
      bone = node.bone;
      n2++;
      if (node.kinematic) {
        _endMatrix.multiplyMatrices(bone.matrixWorld, node.decal);
        _endMatrix.decompose(_p, _q$1, _s);
        node.pos = _p.toArray();
        node.quat = _q$1.toArray();
        up.push({ name: node.name, pos: node.pos, quat: node.quat });
        if (node.motion) this.freeBone(node);
      } else {
        body = Utils.byName(node.name);
        if (body) {
          _endMatrix.copy(body.matrixWorld).multiply(node.decalinv);
          bone.phyMtx.copy(_endMatrix);
          bone.isPhysics = true;
        }
      }
    }
    if (up.length !== 0) root.motor.change(up, true);
  }
  dispose() {
    root.motor.remove(this.jointList);
    root.motor.remove(this.nameList);
    this.nodes = [];
    this.posRef = {};
    this.quatRef = {};
    this.parent.remove(this);
    this.nameList = [];
    this.jointList = [];
  }
};
var _renderer;
var fullscreenQuadGeometry;
var fullscreenQuadMaterial;
var fullscreenQuad;
function decompress(texture, maxTextureSize = Infinity, renderer2 = null) {
  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);
  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({
    uniforms: { blitTexture: new Uniform(texture) },
    vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
    fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
  });
  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;
  fullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace;
  fullscreenQuadMaterial.needsUpdate = true;
  if (!fullscreenQuad) {
    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);
    fullscreenQuad.frustrumCulled = false;
  }
  const _camera = new PerspectiveCamera();
  const _scene = new Scene();
  _scene.add(fullscreenQuad);
  if (renderer2 === null) {
    renderer2 = _renderer = new WebGLRenderer({ antialias: false });
  }
  const width = Math.min(texture.image.width, maxTextureSize);
  const height = Math.min(texture.image.height, maxTextureSize);
  renderer2.setSize(width, height);
  renderer2.clear();
  renderer2.render(_scene, _camera);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  context.drawImage(renderer2.domElement, 0, 0, width, height);
  const readableTexture = new CanvasTexture(canvas);
  readableTexture.minFilter = texture.minFilter;
  readableTexture.magFilter = texture.magFilter;
  readableTexture.wrapS = texture.wrapS;
  readableTexture.wrapT = texture.wrapT;
  readableTexture.name = texture.name;
  if (_renderer) {
    _renderer.forceContextLoss();
    _renderer.dispose();
    _renderer = null;
  }
  return readableTexture;
}
var KHR_mesh_quantization_ExtraAttrTypes = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
var GLTFExporter = class {
  constructor() {
    this.pluginCallbacks = [];
    this.register(function(writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsUnlitExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsTransmissionExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsVolumeExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsIorExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsSpecularExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsClearcoatExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsIridescenceExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsSheenExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsAnisotropyExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsEmissiveStrengthExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsBumpExtension$1(writer);
    });
    this.register(function(writer) {
      return new GLTFMeshGpuInstancing$1(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(input, onDone, onError, options) {
    const writer = new GLTFWriter();
    const plugins = [];
    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {
      plugins.push(this.pluginCallbacks[i](writer));
    }
    writer.setPlugins(plugins);
    writer.write(input, onDone, options).catch(onError);
  }
  parseAsync(input, options) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(input, resolve, reject, options);
    });
  }
};
var WEBGL_CONSTANTS$1 = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var KHR_MESH_QUANTIZATION = "KHR_mesh_quantization";
var THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS$1.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS$1.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS$1.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS$1.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS$1.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS$1.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS$1.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS$1.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS$1.MIRRORED_REPEAT;
var PATH_PROPERTIES$1 = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};
var DEFAULT_SPECULAR_COLOR = new Color();
var GLB_HEADER_BYTES = 12;
var GLB_HEADER_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_PREFIX_BYTES = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
function equalArray(array1, array2) {
  return array1.length === array2.length && array1.every(function(element, index) {
    return element === array2[index];
  });
}
function stringToArrayBuffer(text) {
  return new TextEncoder().encode(text).buffer;
}
function isIdentityMatrix(matrix) {
  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function getMinMax(attribute, start, count) {
  const output = {
    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let i = start; i < start + count; i++) {
    for (let a = 0; a < attribute.itemSize; a++) {
      let value;
      if (attribute.itemSize > 4) {
        value = attribute.array[i * attribute.itemSize + a];
      } else {
        if (a === 0) value = attribute.getX(i);
        else if (a === 1) value = attribute.getY(i);
        else if (a === 2) value = attribute.getZ(i);
        else if (a === 3) value = attribute.getW(i);
        if (attribute.normalized === true) {
          value = MathUtils.normalize(value, attribute.array);
        }
      }
      output.min[a] = Math.min(output.min[a], value);
      output.max[a] = Math.max(output.max[a], value);
    }
  }
  return output;
}
function getPaddedBufferSize(bufferSize) {
  return Math.ceil(bufferSize / 4) * 4;
}
function getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
  if (paddedLength !== arrayBuffer.byteLength) {
    const array = new Uint8Array(paddedLength);
    array.set(new Uint8Array(arrayBuffer));
    if (paddingByte !== 0) {
      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {
        array[i] = paddingByte;
      }
    }
    return array.buffer;
  }
  return arrayBuffer;
}
function getCanvas() {
  if (typeof document === "undefined" && typeof OffscreenCanvas !== "undefined") {
    return new OffscreenCanvas(1, 1);
  }
  return document.createElement("canvas");
}
function getToBlobPromise(canvas, mimeType) {
  if (canvas.toBlob !== void 0) {
    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));
  }
  let quality;
  if (mimeType === "image/jpeg") {
    quality = 0.92;
  } else if (mimeType === "image/webp") {
    quality = 0.8;
  }
  return canvas.convertToBlob({
    type: mimeType,
    quality
  });
}
var GLTFWriter = class {
  constructor() {
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.buffers = [];
    this.nodeMap = /* @__PURE__ */ new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.extensionsRequired = {};
    this.uids = /* @__PURE__ */ new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    };
    this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(input, onDone, options = {}) {
    this.options = Object.assign({
      // default options
      binary: false,
      trs: false,
      onlyVisible: true,
      maxTextureSize: Infinity,
      animations: [],
      includeCustomExtensions: false
    }, options);
    if (this.options.animations.length > 0) {
      this.options.trs = true;
    }
    this.processInput(input);
    await Promise.all(this.pending);
    const writer = this;
    const buffers = writer.buffers;
    const json = writer.json;
    options = writer.options;
    const extensionsUsed = writer.extensionsUsed;
    const extensionsRequired = writer.extensionsRequired;
    const blob = new Blob(buffers, { type: "application/octet-stream" });
    const extensionsUsedList = Object.keys(extensionsUsed);
    const extensionsRequiredList = Object.keys(extensionsRequired);
    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;
    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;
    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;
    if (options.binary === true) {
      const reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function() {
        const binaryChunk = getPaddedArrayBuffer(reader.result);
        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);
        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
        const header = new ArrayBuffer(GLB_HEADER_BYTES);
        const headerView = new DataView(header);
        headerView.setUint32(0, GLB_HEADER_MAGIC, true);
        headerView.setUint32(4, GLB_VERSION, true);
        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
        headerView.setUint32(8, totalByteLength, true);
        const glbBlob = new Blob([
          header,
          jsonChunkPrefix,
          jsonChunk,
          binaryChunkPrefix,
          binaryChunk
        ], { type: "application/octet-stream" });
        const glbReader = new FileReader();
        glbReader.readAsArrayBuffer(glbBlob);
        glbReader.onloadend = function() {
          onDone(glbReader.result);
        };
      };
    } else {
      if (json.buffers && json.buffers.length > 0) {
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          const base64data = reader.result;
          json.buffers[0].uri = base64data;
          onDone(json);
        };
      } else {
        onDone(json);
      }
    }
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0) return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === void 0) objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0) objectDef.extras = json;
    } catch (error) {
      console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message);
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(attribute, isRelativeCopy = false) {
    if (this.uids.has(attribute) === false) {
      const uids2 = /* @__PURE__ */ new Map();
      uids2.set(true, this.uid++);
      uids2.set(false, this.uid++);
      this.uids.set(attribute, uids2);
    }
    const uids = this.uids.get(attribute);
    return uids.get(isRelativeCopy);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal)) return false;
    const v = new Vector3();
    for (let i = 0, il = normal.count; i < il; i++) {
      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;
    }
    return true;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);
    const attribute = normal.clone();
    const v = new Vector3();
    for (let i = 0, il = attribute.count; i < il; i++) {
      v.fromBufferAttribute(attribute, i);
      if (v.x === 0 && v.y === 0 && v.z === 0) {
        v.setX(1);
      } else {
        v.normalize();
      }
      attribute.setXYZ(i, v.x, v.y, v.z);
    }
    cache.attributesNormalized.set(normal, attribute);
    return attribute;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(mapDef, texture) {
    let didTransform = false;
    const transformDef = {};
    if (texture.offset.x !== 0 || texture.offset.y !== 0) {
      transformDef.offset = texture.offset.toArray();
      didTransform = true;
    }
    if (texture.rotation !== 0) {
      transformDef.rotation = texture.rotation;
      didTransform = true;
    }
    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {
      transformDef.scale = texture.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions["KHR_texture_transform"] = transformDef;
      this.extensionsUsed["KHR_texture_transform"] = true;
    }
  }
  buildMetalRoughTexture(metalnessMap, roughnessMap) {
    if (metalnessMap === roughnessMap) return metalnessMap;
    function getEncodingConversion(map2) {
      if (map2.colorSpace === SRGBColorSpace) {
        return function SRGBToLinear(c) {
          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
        };
      }
      return function LinearToLinear(c) {
        return c;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
    if (metalnessMap instanceof CompressedTexture) {
      metalnessMap = decompress(metalnessMap);
    }
    if (roughnessMap instanceof CompressedTexture) {
      roughnessMap = decompress(roughnessMap);
    }
    const metalness = metalnessMap ? metalnessMap.image : null;
    const roughness = roughnessMap ? roughnessMap.image : null;
    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);
    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);
    const canvas = getCanvas();
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    context.fillStyle = "#00ffff";
    context.fillRect(0, 0, width, height);
    const composite = context.getImageData(0, 0, width, height);
    if (metalness) {
      context.drawImage(metalness, 0, 0, width, height);
      const convert = getEncodingConversion(metalnessMap);
      const data = context.getImageData(0, 0, width, height).data;
      for (let i = 2; i < data.length; i += 4) {
        composite.data[i] = convert(data[i] / 256) * 256;
      }
    }
    if (roughness) {
      context.drawImage(roughness, 0, 0, width, height);
      const convert = getEncodingConversion(roughnessMap);
      const data = context.getImageData(0, 0, width, height).data;
      for (let i = 1; i < data.length; i += 4) {
        composite.data[i] = convert(data[i] / 256) * 256;
      }
    }
    context.putImageData(composite, 0, 0);
    const reference = metalnessMap || roughnessMap;
    const texture = reference.clone();
    texture.source = new Source(canvas);
    texture.colorSpace = NoColorSpace;
    texture.channel = (metalnessMap || roughnessMap).channel;
    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {
      console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.");
    }
    return texture;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(buffer) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers) json.buffers = [{ byteLength: 0 }];
    buffers.push(buffer);
    return 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(attribute, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews) json.bufferViews = [];
    let componentSize;
    switch (componentType) {
      case WEBGL_CONSTANTS$1.BYTE:
      case WEBGL_CONSTANTS$1.UNSIGNED_BYTE:
        componentSize = 1;
        break;
      case WEBGL_CONSTANTS$1.SHORT:
      case WEBGL_CONSTANTS$1.UNSIGNED_SHORT:
        componentSize = 2;
        break;
      default:
        componentSize = 4;
    }
    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i = start; i < start + count; i++) {
      for (let a = 0; a < attribute.itemSize; a++) {
        let value;
        if (attribute.itemSize > 4) {
          value = attribute.array[i * attribute.itemSize + a];
        } else {
          if (a === 0) value = attribute.getX(i);
          else if (a === 1) value = attribute.getY(i);
          else if (a === 2) value = attribute.getZ(i);
          else if (a === 3) value = attribute.getW(i);
          if (attribute.normalized === true) {
            value = MathUtils.normalize(value, attribute.array);
          }
        }
        if (componentType === WEBGL_CONSTANTS$1.FLOAT) {
          dataView.setFloat32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS$1.INT) {
          dataView.setInt32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS$1.UNSIGNED_INT) {
          dataView.setUint32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS$1.SHORT) {
          dataView.setInt16(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS$1.UNSIGNED_SHORT) {
          dataView.setUint16(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS$1.BYTE) {
          dataView.setInt8(offset, value);
        } else if (componentType === WEBGL_CONSTANTS$1.UNSIGNED_BYTE) {
          dataView.setUint8(offset, value);
        }
        offset += componentSize;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength
    };
    if (target !== void 0) bufferViewDef.target = target;
    if (target === WEBGL_CONSTANTS$1.ARRAY_BUFFER) {
      bufferViewDef.byteStride = attribute.itemSize * componentSize;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews) json.bufferViews = [];
    return new Promise(function(resolve) {
      const reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function() {
        const buffer = getPaddedArrayBuffer(reader.result);
        const bufferViewDef = {
          buffer: writer.processBuffer(buffer),
          byteOffset: writer.byteOffset,
          byteLength: buffer.byteLength
        };
        writer.byteOffset += buffer.byteLength;
        resolve(json.bufferViews.push(bufferViewDef) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(attribute, geometry, start, count) {
    const json = this.json;
    const types = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let componentType;
    if (attribute.array.constructor === Float32Array) {
      componentType = WEBGL_CONSTANTS$1.FLOAT;
    } else if (attribute.array.constructor === Int32Array) {
      componentType = WEBGL_CONSTANTS$1.INT;
    } else if (attribute.array.constructor === Uint32Array) {
      componentType = WEBGL_CONSTANTS$1.UNSIGNED_INT;
    } else if (attribute.array.constructor === Int16Array) {
      componentType = WEBGL_CONSTANTS$1.SHORT;
    } else if (attribute.array.constructor === Uint16Array) {
      componentType = WEBGL_CONSTANTS$1.UNSIGNED_SHORT;
    } else if (attribute.array.constructor === Int8Array) {
      componentType = WEBGL_CONSTANTS$1.BYTE;
    } else if (attribute.array.constructor === Uint8Array) {
      componentType = WEBGL_CONSTANTS$1.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + attribute.array.constructor.name);
    }
    if (start === void 0) start = 0;
    if (count === void 0 || count === Infinity) count = attribute.count;
    if (count === 0) return null;
    const minMax = getMinMax(attribute, start, count);
    let bufferViewTarget;
    if (geometry !== void 0) {
      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS$1.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS$1.ARRAY_BUFFER;
    }
    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);
    const accessorDef = {
      bufferView: bufferView.id,
      byteOffset: bufferView.byteOffset,
      componentType,
      count,
      max: minMax.max,
      min: minMax.min,
      type: types[attribute.itemSize]
    };
    if (attribute.normalized === true) accessorDef.normalized = true;
    if (!json.accessors) json.accessors = [];
    return json.accessors.push(accessorDef) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(image, format, flipY, mimeType = "image/png") {
    if (image !== null) {
      const writer = this;
      const cache = writer.cache;
      const json = writer.json;
      const options = writer.options;
      const pending = writer.pending;
      if (!cache.images.has(image)) cache.images.set(image, {});
      const cachedImages = cache.images.get(image);
      const key = mimeType + ":flipY/" + flipY.toString();
      if (cachedImages[key] !== void 0) return cachedImages[key];
      if (!json.images) json.images = [];
      const imageDef = { mimeType };
      const canvas = getCanvas();
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext("2d");
      if (flipY === true) {
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
      }
      if (image.data !== void 0) {
        if (format !== RGBAFormat) {
          console.error("GLTFExporter: Only RGBAFormat is supported.", format);
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        for (let i = 0; i < data.length; i += 4) {
          data[i + 0] = image.data[i + 0];
          data[i + 1] = image.data[i + 1];
          data[i + 2] = image.data[i + 2];
          data[i + 3] = image.data[i + 3];
        }
        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      } else {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        } else {
          throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement or ImageBitmap.");
        }
      }
      if (options.binary === true) {
        pending.push(
          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {
            imageDef.bufferView = bufferViewIndex;
          })
        );
      } else {
        if (canvas.toDataURL !== void 0) {
          imageDef.uri = canvas.toDataURL(mimeType);
        } else {
          pending.push(
            getToBlobPromise(canvas, mimeType).then((blob) => new FileReader().readAsDataURL(blob)).then((dataURL) => {
              imageDef.uri = dataURL;
            })
          );
        }
      }
      const index = json.images.push(imageDef) - 1;
      cachedImages[key] = index;
      return index;
    } else {
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
    }
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(map2) {
    const json = this.json;
    if (!json.samplers) json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map2.magFilter],
      minFilter: THREE_TO_WEBGL[map2.minFilter],
      wrapS: THREE_TO_WEBGL[map2.wrapS],
      wrapT: THREE_TO_WEBGL[map2.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(map2) {
    const writer = this;
    const options = writer.options;
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map2)) return cache.textures.get(map2);
    if (!json.textures) json.textures = [];
    if (map2 instanceof CompressedTexture) {
      map2 = decompress(map2, options.maxTextureSize);
    }
    let mimeType = map2.userData.mimeType;
    if (mimeType === "image/webp") mimeType = "image/png";
    const textureDef = {
      sampler: this.processSampler(map2),
      source: this.processImage(map2.image, map2.format, map2.flipY, mimeType)
    };
    if (map2.name) textureDef.name = map2.name;
    this._invokeAll(function(ext) {
      ext.writeTexture && ext.writeTexture(map2, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map2, index);
    return index;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(material) {
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material)) return cache.materials.get(material);
    if (material.isShaderMaterial) {
      console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
      return null;
    }
    if (!json.materials) json.materials = [];
    const materialDef = { pbrMetallicRoughness: {} };
    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {
      console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    }
    const color = material.color.toArray().concat([material.opacity]);
    if (!equalArray(color, [1, 1, 1, 1])) {
      materialDef.pbrMetallicRoughness.baseColorFactor = color;
    }
    if (material.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }
    if (material.metalnessMap || material.roughnessMap) {
      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);
      const metalRoughMapDef = {
        index: this.processTexture(metalRoughTexture),
        channel: metalRoughTexture.channel
      };
      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);
      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
    }
    if (material.map) {
      const baseColorMapDef = {
        index: this.processTexture(material.map),
        texCoord: material.map.channel
      };
      this.applyTextureTransform(baseColorMapDef, material.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if (material.emissive) {
      const emissive = material.emissive;
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = material.emissive.toArray();
      }
      if (material.emissiveMap) {
        const emissiveMapDef = {
          index: this.processTexture(material.emissiveMap),
          texCoord: material.emissiveMap.channel
        };
        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }
    if (material.normalMap) {
      const normalMapDef = {
        index: this.processTexture(material.normalMap),
        texCoord: material.normalMap.channel
      };
      if (material.normalScale && material.normalScale.x !== 1) {
        normalMapDef.scale = material.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material.normalMap);
      materialDef.normalTexture = normalMapDef;
    }
    if (material.aoMap) {
      const occlusionMapDef = {
        index: this.processTexture(material.aoMap),
        texCoord: material.aoMap.channel
      };
      if (material.aoMapIntensity !== 1) {
        occlusionMapDef.strength = material.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }
    if (material.transparent) {
      materialDef.alphaMode = "BLEND";
    } else {
      if (material.alphaTest > 0) {
        materialDef.alphaMode = "MASK";
        materialDef.alphaCutoff = material.alphaTest;
      }
    }
    if (material.side === DoubleSide) materialDef.doubleSided = true;
    if (material.name !== "") materialDef.name = material.name;
    this.serializeUserData(material, materialDef);
    this._invokeAll(function(ext) {
      ext.writeMaterial && ext.writeMaterial(material, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material, index);
    return index;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(mesh) {
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i = 0, l = mesh.material.length; i < l; i++) {
        meshCacheKeyParts.push(mesh.material[i].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(":");
    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);
    const geometry = mesh.geometry;
    let mode;
    if (mesh.isLineSegments) {
      mode = WEBGL_CONSTANTS$1.LINES;
    } else if (mesh.isLineLoop) {
      mode = WEBGL_CONSTANTS$1.LINE_LOOP;
    } else if (mesh.isLine) {
      mode = WEBGL_CONSTANTS$1.LINE_STRIP;
    } else if (mesh.isPoints) {
      mode = WEBGL_CONSTANTS$1.POINTS;
    } else {
      mode = mesh.material.wireframe ? WEBGL_CONSTANTS$1.LINES : WEBGL_CONSTANTS$1.TRIANGLES;
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];
    const nameConversion = {
      uv: "TEXCOORD_0",
      uv1: "TEXCOORD_1",
      uv2: "TEXCOORD_2",
      uv3: "TEXCOORD_3",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    };
    const originalNormal = geometry.getAttribute("normal");
    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
      geometry.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
    }
    let modifiedAttribute = null;
    for (let attributeName in geometry.attributes) {
      if (attributeName.slice(0, 5) === "morph") continue;
      const attribute = geometry.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName)) attributeName = "_" + attributeName;
      if (cache.attributes.has(this.getUID(attribute))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));
        continue;
      }
      modifiedAttribute = null;
      const array = attribute.array;
      if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);
      }
      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);
      if (accessor !== null) {
        if (!attributeName.startsWith("_")) {
          this.detectMeshQuantization(attributeName, attribute);
        }
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute), accessor);
      }
    }
    if (originalNormal !== void 0) geometry.setAttribute("normal", originalNormal);
    if (Object.keys(attributes).length === 0) return null;
    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== void 0) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {
        const target = {};
        let warned = false;
        for (const attributeName in geometry.morphAttributes) {
          if (attributeName !== "position" && attributeName !== "normal") {
            if (!warned) {
              console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
              warned = true;
            }
            continue;
          }
          const attribute = geometry.morphAttributes[attributeName][i];
          const gltfAttributeName = attributeName.toUpperCase();
          const baseAttribute = geometry.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute, true))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));
            continue;
          }
          const relativeAttribute = attribute.clone();
          if (!geometry.morphTargetsRelative) {
            for (let j = 0, jl = attribute.count; j < jl; j++) {
              for (let a = 0; a < attribute.itemSize; a++) {
                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));
                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));
                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));
                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));
              }
            }
          }
          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);
          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i]);
        if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[i]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry.groups.length === 0) return null;
    let didForceIndices = false;
    if (isMultiMaterial && geometry.index === null) {
      const indices = [];
      for (let i = 0, il = geometry.attributes.position.count; i < il; i++) {
        indices[i] = i;
      }
      geometry.setIndex(indices);
      didForceIndices = true;
    }
    const materials2 = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let i = 0, il = groups.length; i < il; i++) {
      const primitive = {
        mode,
        attributes
      };
      this.serializeUserData(geometry, primitive);
      if (targets.length > 0) primitive.targets = targets;
      if (geometry.index !== null) {
        let cacheKey = this.getUID(geometry.index);
        if (groups[i].start !== void 0 || groups[i].count !== void 0) {
          cacheKey += ":" + groups[i].start + ":" + groups[i].count;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null) delete primitive.indices;
      }
      const material = this.processMaterial(materials2[groups[i].materialIndex]);
      if (material !== null) primitive.material = material;
      primitives.push(primitive);
    }
    if (didForceIndices === true) {
      geometry.setIndex(null);
    }
    meshDef.primitives = primitives;
    if (!json.meshes) json.meshes = [];
    this._invokeAll(function(ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(attributeName, attribute) {
    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;
    let attrType = void 0;
    switch (attribute.array.constructor) {
      case Int8Array:
        attrType = "byte";
        break;
      case Uint8Array:
        attrType = "unsigned byte";
        break;
      case Int16Array:
        attrType = "short";
        break;
      case Uint16Array:
        attrType = "unsigned short";
        break;
      default:
        return;
    }
    if (attribute.normalized) attrType += " normalized";
    const attrNamePrefix = attributeName.split("_", 1)[0];
    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {
      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;
      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;
    }
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras) json.cameras = [];
    const isOrtho = camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? "orthographic" : "perspective"
    };
    if (isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }
    if (camera.name !== "") cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(clip, root2) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations) json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root2);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i = 0; i < tracks.length; ++i) {
      const track = tracks[i];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root2, trackBinding.nodeName);
      const trackProperty = PATH_PROPERTIES$1[trackBinding.propertyName];
      if (trackBinding.objectName === "bones") {
        if (trackNode.isSkinnedMesh === true) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = void 0;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        return null;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === PATH_PROPERTIES$1.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {
        interpolation = "CUBICSPLINE";
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = "STEP";
      } else {
        interpolation = "LINEAR";
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
        interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || "clip_" + json.animations.length,
      samplers,
      channels
    });
    return json.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    const node = json.nodes[nodeMap.get(object)];
    const skeleton = object.skeleton;
    if (skeleton === void 0) return null;
    const rootJoint = object.skeleton.bones[0];
    if (rootJoint === void 0) return null;
    const joints = [];
    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
    const temporaryBoneInverse = new Matrix4();
    for (let i = 0; i < skeleton.bones.length; ++i) {
      joints.push(nodeMap.get(skeleton.bones[i]));
      temporaryBoneInverse.copy(skeleton.boneInverses[i]);
      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);
    }
    if (json.skins === void 0) json.skins = [];
    json.skins.push({
      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
      joints,
      skeleton: nodeMap.get(rootJoint)
    });
    const skinIndex = node.skin = json.skins.length - 1;
    return skinIndex;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(object) {
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes) json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (isIdentityMatrix(object.matrix) === false) {
        nodeDef.matrix = object.matrix.elements;
      }
    }
    if (object.name !== "") nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if (object.isMesh || object.isLine || object.isPoints) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null) nodeDef.mesh = meshIndex;
    } else if (object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object.isSkinnedMesh) this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i = 0, l = object.children.length; i < l; i++) {
        const child = object.children[i];
        if (child.visible || options.onlyVisible === false) {
          const nodeIndex2 = this.processNode(child);
          if (nodeIndex2 !== null) children.push(nodeIndex2);
        }
      }
      if (children.length > 0) nodeDef.children = children;
    }
    this._invokeAll(function(ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(scene2) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene2.name !== "") sceneDef.name = scene2.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i = 0, l = scene2.children.length; i < l; i++) {
      const child = scene2.children[i];
      if (child.visible || options.onlyVisible === false) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null) nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0) sceneDef.nodes = nodes;
    this.serializeUserData(scene2, sceneDef);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(objects) {
    const scene2 = new Scene();
    scene2.name = "AuxScene";
    for (let i = 0; i < objects.length; i++) {
      scene2.children.push(objects[i]);
    }
    this.processScene(scene2);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function(ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i = 0; i < input.length; i++) {
      if (input[i] instanceof Scene) {
        this.processScene(input[i]);
      } else {
        objectsWithoutScene.push(input[i]);
      }
    }
    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);
    for (let i = 0; i < this.skins.length; ++i) {
      this.processSkin(this.skins[i]);
    }
    for (let i = 0; i < options.animations.length; ++i) {
      this.processAnimation(options.animations[i], input[0]);
    }
    this._invokeAll(function(ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i = 0, il = this.plugins.length; i < il; i++) {
      func(this.plugins[i]);
    }
  }
};
var GLTFLightExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_lights_punctual";
  }
  writeNode(light, nodeDef) {
    if (!light.isLight) return;
    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name) lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light.isDirectionalLight) {
      lightDef.type = "directional";
    } else if (light.isPointLight) {
      lightDef.type = "point";
      if (light.distance > 0) lightDef.range = light.distance;
    } else if (light.isSpotLight) {
      lightDef.type = "spot";
      if (light.distance > 0) lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (1 - light.penumbra) * light.angle;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (light.decay !== void 0 && light.decay !== 2) {
      console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.");
    }
    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = { lights: [] };
      extensionsUsed[this.name] = true;
    }
    const lights = json.extensions[this.name].lights;
    lights.push(lightDef);
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = { light: lights.length - 1 };
  }
};
var GLTFMaterialsUnlitExtension$1 = class GLTFMaterialsUnlitExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_unlit";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshBasicMaterial) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
var GLTFMaterialsClearcoatExtension$1 = class GLTFMaterialsClearcoatExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.clearcoatFactor = material.clearcoat;
    if (material.clearcoatMap) {
      const clearcoatMapDef = {
        index: writer.processTexture(material.clearcoatMap),
        texCoord: material.clearcoatMap.channel
      };
      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);
      extensionDef.clearcoatTexture = clearcoatMapDef;
    }
    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;
    if (material.clearcoatRoughnessMap) {
      const clearcoatRoughnessMapDef = {
        index: writer.processTexture(material.clearcoatRoughnessMap),
        texCoord: material.clearcoatRoughnessMap.channel
      };
      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);
      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;
    }
    if (material.clearcoatNormalMap) {
      const clearcoatNormalMapDef = {
        index: writer.processTexture(material.clearcoatNormalMap),
        texCoord: material.clearcoatNormalMap.channel
      };
      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);
      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsIridescenceExtension$1 = class GLTFMaterialsIridescenceExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_iridescence";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.iridescenceFactor = material.iridescence;
    if (material.iridescenceMap) {
      const iridescenceMapDef = {
        index: writer.processTexture(material.iridescenceMap),
        texCoord: material.iridescenceMap.channel
      };
      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);
      extensionDef.iridescenceTexture = iridescenceMapDef;
    }
    extensionDef.iridescenceIor = material.iridescenceIOR;
    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];
    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];
    if (material.iridescenceThicknessMap) {
      const iridescenceThicknessMapDef = {
        index: writer.processTexture(material.iridescenceThicknessMap),
        texCoord: material.iridescenceThicknessMap.channel
      };
      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);
      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsTransmissionExtension$1 = class GLTFMaterialsTransmissionExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_transmission";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material.transmission;
    if (material.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material.transmissionMap),
        texCoord: material.transmissionMap.channel
      };
      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsVolumeExtension$1 = class GLTFMaterialsVolumeExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_volume";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thicknessFactor = material.thickness;
    if (material.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material.thicknessMap),
        texCoord: material.thicknessMap.channel
      };
      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    extensionDef.attenuationDistance = material.attenuationDistance;
    extensionDef.attenuationColor = material.attenuationColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsIorExtension$1 = class GLTFMaterialsIorExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_ior";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.ior = material.ior;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsSpecularExtension$1 = class GLTFMaterialsSpecularExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_specular";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorMap) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.specularIntensityMap) {
      const specularIntensityMapDef = {
        index: writer.processTexture(material.specularIntensityMap),
        texCoord: material.specularIntensityMap.channel
      };
      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);
      extensionDef.specularTexture = specularIntensityMapDef;
    }
    if (material.specularColorMap) {
      const specularColorMapDef = {
        index: writer.processTexture(material.specularColorMap),
        texCoord: material.specularColorMap.channel
      };
      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);
      extensionDef.specularColorTexture = specularColorMapDef;
    }
    extensionDef.specularFactor = material.specularIntensity;
    extensionDef.specularColorFactor = material.specularColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsSheenExtension$1 = class GLTFMaterialsSheenExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_sheen";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.sheenRoughnessMap) {
      const sheenRoughnessMapDef = {
        index: writer.processTexture(material.sheenRoughnessMap),
        texCoord: material.sheenRoughnessMap.channel
      };
      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);
      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;
    }
    if (material.sheenColorMap) {
      const sheenColorMapDef = {
        index: writer.processTexture(material.sheenColorMap),
        texCoord: material.sheenColorMap.channel
      };
      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);
      extensionDef.sheenColorTexture = sheenColorMapDef;
    }
    extensionDef.sheenRoughnessFactor = material.sheenRoughness;
    extensionDef.sheenColorFactor = material.sheenColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsAnisotropyExtension$1 = class GLTFMaterialsAnisotropyExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.anisotropyMap) {
      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) };
      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);
      extensionDef.anisotropyTexture = anisotropyMapDef;
    }
    extensionDef.anisotropyStrength = material.anisotropy;
    extensionDef.anisotropyRotation = material.anisotropyRotation;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsEmissiveStrengthExtension$1 = class GLTFMaterialsEmissiveStrengthExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.emissiveStrength = material.emissiveIntensity;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsBumpExtension$1 = class GLTFMaterialsBumpExtension {
  constructor(writer) {
    this.writer = writer;
    this.name = "EXT_materials_bump";
  }
  writeMaterial(material, materialDef) {
    if (!material.isMeshStandardMaterial || material.bumpScale === 1 && !material.bumpMap) return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material.bumpMap) {
      const bumpMapDef = {
        index: writer.processTexture(material.bumpMap),
        texCoord: material.bumpMap.channel
      };
      writer.applyTextureTransform(bumpMapDef, material.bumpMap);
      extensionDef.bumpTexture = bumpMapDef;
    }
    extensionDef.bumpFactor = material.bumpScale;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMeshGpuInstancing$1 = class GLTFMeshGpuInstancing {
  constructor(writer) {
    this.writer = writer;
    this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(object, nodeDef) {
    if (!object.isInstancedMesh) return;
    const writer = this.writer;
    const mesh = object;
    const translationAttr = new Float32Array(mesh.count * 3);
    const rotationAttr = new Float32Array(mesh.count * 4);
    const scaleAttr = new Float32Array(mesh.count * 3);
    const matrix = new Matrix4();
    const position = new Vector3();
    const quaternion2 = new Quaternion();
    const scale = new Vector3();
    for (let i = 0; i < mesh.count; i++) {
      mesh.getMatrixAt(i, matrix);
      matrix.decompose(position, quaternion2, scale);
      position.toArray(translationAttr, i * 3);
      quaternion2.toArray(rotationAttr, i * 4);
      scale.toArray(scaleAttr, i * 3);
    }
    const attributes = {
      TRANSLATION: writer.processAccessor(new BufferAttribute(translationAttr, 3)),
      ROTATION: writer.processAccessor(new BufferAttribute(rotationAttr, 4)),
      SCALE: writer.processAccessor(new BufferAttribute(scaleAttr, 3))
    };
    if (mesh.instanceColor)
      attributes._COLOR_0 = writer.processAccessor(mesh.instanceColor);
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = { attributes };
    writer.extensionsUsed[this.name] = true;
    writer.extensionsRequired[this.name] = true;
  }
};
GLTFExporter.Utils = {
  insertKeyframe: function(track, time) {
    const tolerance = 1e-3;
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i = 0; i < valueSize; i++) {
        values[i] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance) return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i = 0; i < track.times.length; i++) {
        if (Math.abs(track.times[i] - time) < tolerance) return i;
        if (track.times[i] < time && track.times[i + 1] > time) {
          times.set(track.times.slice(0, i + 1), 0);
          times[i + 1] = time;
          times.set(track.times.slice(i + 1), i + 2);
          values.set(track.values.slice(0, (i + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i + 1) * valueSize);
          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);
          index = i + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function(clip, root2) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i = 0; i < sourceTracks.length; ++i) {
      let sourceTrack = sourceTracks[i];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root2, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
        tracks.push(sourceTrack);
        continue;
      }
      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        }
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === void 0) {
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;
      if (mergedTracks[sourceTrackNode.uuid] === void 0) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j = 0; j < mergedTrack.times.length; j++) {
          values[j * targetCount + targetIndex] = mergedTrack.values[j];
        }
        mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];
      for (let j = 0; j < mergedTrack.times.length; j++) {
        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
      }
      for (let j = 0; j < sourceTrack.times.length; j++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
};
function clone(source) {
  const sourceLookup = /* @__PURE__ */ new Map();
  const cloneLookup = /* @__PURE__ */ new Map();
  const clone2 = source.clone();
  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {
    sourceLookup.set(clonedNode, sourceNode);
    cloneLookup.set(sourceNode, clonedNode);
  });
  clone2.traverse(function(node) {
    if (!node.isSkinnedMesh) return;
    const clonedMesh = node;
    const sourceMesh = sourceLookup.get(node);
    const sourceBones = sourceMesh.skeleton.bones;
    clonedMesh.skeleton = sourceMesh.skeleton.clone();
    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
      return cloneLookup.get(bone);
    });
    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
  });
  return clone2;
}
function parallelTraverse(a, b, callback) {
  callback(a, b);
  for (let i = 0; i < a.children.length; i++) {
    parallelTraverse(a.children[i], b.children[i], callback);
  }
}
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing2(parser);
    });
  }
  load(url2, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url2);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url2);
    }
    this.manager.itemStart(url2);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url2);
      scope.manager.itemEnd(url2);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url2, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url2);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError) onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension2();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light") return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0) return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension2 = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsDispersionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
};
var GLTFMaterialsIridescenceExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsBumpExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing2 = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m2 = new Matrix4();
        const p2 = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p2.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m2.compose(p2, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td2 = t1 - t0;
    const p2 = (t2 - t0) / td2;
    const pp = p2 * p2;
    const ppp = pp * p2;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p2;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td2;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td2;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0) hasMorphPosition = true;
    if (target.NORMAL !== void 0) hasMorphNormal = true;
    if (target.COLOR_0 !== void 0) hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
  if (uri.search(/\.ktx2($|\?)/i) > 0 || uri.search(/^data\:image\/ktx2/) === 0) return "image/ktx2";
  return "image/png";
}
var _identityMatrix$1 = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene2 of result.scenes) {
          scene2.updateMatrixWorld();
        }
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   *
   * @param {Object} cache
   * @param {Object3D} index
   */
  _addNodeRef(cache, index) {
    if (index === void 0) return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /**
   * Returns a reference to a shared resource, cloning it if necessary.
   *
   * @param {Object} cache
   * @param {number} index
   * @param {Object} object
   * @return {Object}
   */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object;
    const ref = object.clone();
    const updateMappings = (original, clone2) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone2, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone2.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      texture.generateMipmaps = !texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   *
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @param {string} colorSpace
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture) return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents) cacheKey += "derivative-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name) material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /**
   * When Object3D instances are targeted by animation, they need unique names.
   *
   * @param {string} originalName
   * @return {string}
   */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials2 = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials2[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat2 = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat2.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat2);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0) continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0) continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k = 0; k < createdTracks.length; k++) {
            tracks.push(createdTracks[k]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0) return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh) return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh) return;
          mesh.bind(skeleton, _identityMatrix$1);
        });
      }
      for (let i = 0, il = children.length; i < il; i++) {
        node.add(children[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene2 = new Group();
    if (sceneDef.name) scene2.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene2, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene2, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene2.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene2);
      return scene2;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl = targetNames.length; j < jl; j++) {
      const track = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl = outputArray.length; j < jl; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max2 = accessor.max;
    if (min !== void 0 && max2 !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max2[0], max2[1], max2[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max2 = accessor.max;
        if (min !== void 0 && max2 !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max2[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max2[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max2[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
var _taskCache$1 = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url2, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url2, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError) {
    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace).catch(onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache$1.has(buffer)) {
      const cachedTask = _taskCache$1.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker2;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker2 = _worker;
      return new Promise((resolve, reject) => {
        worker2._callbacks[taskID] = { resolve, reject };
        worker2.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker2 && taskID) {
        this._releaseTask(worker2, taskID);
      }
    });
    _taskCache$1.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace) return;
    const _color2 = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color2.fromBufferAttribute(attribute, i).convertSRGBToLinear();
      attribute.setXYZ(i, _color2.r, _color2.g, _color2.b);
    }
  }
  _loadLibrary(url2, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url2, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker3 = new Worker(this.workerSourceURL);
        worker3._callbacks = {};
        worker3._taskCosts = {};
        worker3._taskLoad = 0;
        worker3.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker3.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker3._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker3._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker3);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker2 = this.workerPool[this.workerPool.length - 1];
      worker2._taskCosts[taskID] = taskCost;
      worker2._taskLoad += taskCost;
      return worker2;
    });
  }
  _releaseTask(worker2, taskID) {
    worker2._taskLoad -= worker2._taskCosts[taskID];
    delete worker2._callbacks[taskID];
    delete worker2._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker2) => worker2._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index) buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1) continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}
var durl = function(c) {
  return URL.createObjectURL(new Blob([c], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(durl(""));
} catch (e) {
  durl = function(c) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(c);
  };
}
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new u32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return [b, r];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x$1 = (i & 43690) >>> 1 | (i & 21845) << 1;
  x$1 = (x$1 & 52428) >>> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >>> 4 | (x$1 & 3855) << 4;
  rev[i] = ((x$1 & 65280) >>> 8 | (x$1 & 255) << 8) >>> 1;
}
var x$1;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i)
    ++l[cd[i] - 1];
  var le = new u16(mb);
  for (i = 0; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m2 = v | (1 << r_1) - 1; v <= m2; ++v) {
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = hMap(flt, 9, 1);
var fdrm = hMap(fdt, 5, 1);
var max = function(a) {
  var m2 = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m2)
      m2 = a[i];
  }
  return m2;
};
var bits = function(d, p2, m2) {
  var o = p2 / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d, p2) {
  var o = p2 / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 / 8 | 0) + (p2 & 7 && 1);
};
var slc = function(v, s, e) {
  if (e == null || e > v.length)
    e = v.length;
  var n2 = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  n2.set(v.subarray(s, e));
  return n2;
};
var inflt = function(dat, buf, st) {
  var sl = dat.length;
  if (!sl || st && !st.l && sl < 5)
    return buf || new u8(0);
  var noBuf = !buf || st;
  var noSt = !st || st.i;
  if (!st)
    st = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t2), bt);
        st.b = bt += l, st.p = pos = t2 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >>> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n2 = 0;
            if (s == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt2);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
      if (!c)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt2];
          buf[bt + 1] = buf[bt + 1 - dt2];
          buf[bt + 2] = buf[bt + 2 - dt2];
          buf[bt + 3] = buf[bt + 3 - dt2];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = lpos, st.b = bt;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var et = new u8(0);
var zlv = function(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
function findSpan(p2, u, U) {
  const n2 = U.length - p2 - 1;
  if (u >= U[n2]) {
    return n2 - 1;
  }
  if (u <= U[p2]) {
    return p2;
  }
  let low = p2;
  let high = n2;
  let mid = Math.floor((low + high) / 2);
  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u, p2, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j = 1; j <= p2; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r = 0; r < j; ++r) {
      const rv = right[r + 1];
      const lv = left[j - r];
      const temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }
    N[j] = saved;
  }
  return N;
}
function calcBSplinePoint(p2, U, P, u) {
  const span = findSpan(p2, u, U);
  const N = calcBasisFunctions(span, u, p2, U);
  const C2 = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p2; ++j) {
    const point = P[span - p2 + j];
    const Nj = N[j];
    const wNj = point.w * Nj;
    C2.x += point.x * wNj;
    C2.y += point.y * wNj;
    C2.z += point.z * wNj;
    C2.w += point.w * Nj;
  }
  return C2;
}
function calcBasisFunctionDerivatives(span, u, p2, n2, U) {
  const zeroArr = [];
  for (let i = 0; i <= p2; ++i)
    zeroArr[i] = 0;
  const ders = [];
  for (let i = 0; i <= n2; ++i)
    ders[i] = zeroArr.slice(0);
  const ndu = [];
  for (let i = 0; i <= p2; ++i)
    ndu[i] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p2; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      ndu[j][r2] = rv + lv;
      const temp = ndu[r2][j - 1] / ndu[j][r2];
      ndu[r2][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p2; ++j) {
    ders[0][j] = ndu[j][p2];
  }
  for (let r2 = 0; r2 <= p2; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a = [];
    for (let i = 0; i <= p2; ++i) {
      a[i] = zeroArr.slice(0);
    }
    a[0][0] = 1;
    for (let k = 1; k <= n2; ++k) {
      let d = 0;
      const rk = r2 - k;
      const pk = p2 - k;
      if (r2 >= k) {
        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
        d = a[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r2 - 1 <= pk ? k - 1 : p2 - r2;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d += a[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];
        d += a[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r = p2;
  for (let k = 1; k <= n2; ++k) {
    for (let j = 0; j <= p2; ++j) {
      ders[k][j] *= r;
    }
    r *= p2 - k;
  }
  return ders;
}
function calcBSplineDerivatives(p2, U, P, u, nd) {
  const du = nd < p2 ? nd : p2;
  const CK = [];
  const span = findSpan(p2, u, U);
  const nders = calcBasisFunctionDerivatives(span, u, p2, du, U);
  const Pw = [];
  for (let i = 0; i < P.length; ++i) {
    const point = P[i].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i] = point;
  }
  for (let k = 0; k <= du; ++k) {
    const point = Pw[span - p2].clone().multiplyScalar(nders[k][0]);
    for (let j = 1; j <= p2; ++j) {
      point.add(Pw[span - p2 + j].clone().multiplyScalar(nders[k][j]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k, i) {
  let nom = 1;
  for (let j = 2; j <= k; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k - i; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i = 0; i < nd; ++i) {
    const point = Pders[i];
    Aders[i] = new Vector3(point.x, point.y, point.z);
    wders[i] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v = Aders[k].clone();
    for (let i = 1; i <= k; ++i) {
      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));
    }
    CK[k] = v.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p2, U, P, u, nd) {
  const Pders = calcBSplineDerivatives(p2, U, P, u, nd);
  return calcRationalCurveDerivatives(Pders);
}
var NURBSCurve = class extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i = 0; i < controlPoints.length; ++i) {
      const point = controlPoints[i];
      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
    }
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const u = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
    if (hpoint.w !== 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t2, optionalTarget = new Vector3()) {
    const tangent = optionalTarget;
    const u = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
};
var fbxTree;
var connections;
var sceneGraph;
var FBXLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url2, onLoad, onProgress, onError) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url2) : scope.path;
    const loader = new FileLoader(this.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url2, function(buffer) {
      try {
        onLoad(scope.parse(buffer, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url2);
      }
    }, onProgress, onError);
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary(FBXBuffer)) {
      fbxTree = new BinaryParser().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString(FBXBuffer);
      if (!isFbxFormatASCII(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
      }
      fbxTree = new TextParser().parse(FBXText);
    }
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
  }
};
var FBXTreeParser = class {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections = this.parseConnections();
    const images = this.parseImages();
    const textures = this.parseTextures(images);
    const materials2 = this.parseMaterials(textures);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse(deformers);
    this.parseScene(deformers, geometryMap, materials2);
    return sceneGraph;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree) {
      const rawConnections = fbxTree.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = { ID: toID, relationship };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = { ID: fromID, relationship };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree.Objects) {
      const videoNodes = fbxTree.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id = parseInt(nodeID);
        images[id] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
          }
        }
      }
    }
    for (const id in images) {
      const filename = images[id];
      if (blobs[filename] !== void 0) images[id] = blobs[filename];
      else images[id] = images[id].split("\\").pop();
    }
    return images;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(videoNode) {
    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type;
    switch (extension) {
      case "bmp":
        type = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type = "image/jpeg";
        break;
      case "png":
        type = "image/png";
        break;
      case "tif":
        type = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
        return;
    }
    if (typeof content === "string") {
      return "data:" + type + ";base64," + content;
    } else {
      const array = new Uint8Array(content);
      return window.URL.createObjectURL(new Blob([array], { type }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree.Objects) {
      const textureNodes = fbxTree.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture);
      }
    }
    return textureMap;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(textureNode, images) {
    const texture = this.loadTexture(textureNode, images);
    texture.ID = textureNode.id;
    texture.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    if ("Scaling" in textureNode) {
      const values = textureNode.Scaling.value;
      texture.repeat.x = values[0];
      texture.repeat.y = values[1];
    }
    if ("Translation" in textureNode) {
      const values = textureNode.Translation.value;
      texture.offset.x = values[0];
      texture.offset.y = values[1];
    }
    return texture;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(textureNode, images) {
    const nonNativeExtensions = /* @__PURE__ */ new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"]);
    const extension = textureNode.FileName.split(".").pop().toLowerCase();
    const loader = nonNativeExtensions.has(extension) ? this.manager.getHandler(`.${extension}`) : this.textureLoader;
    if (!loader) {
      console.warn(
        `FBXLoader: ${extension.toUpperCase()} loader not found, creating placeholder texture for`,
        textureNode.RelativeFilename
      );
      return new Texture();
    }
    const loaderPath = loader.path;
    if (!loaderPath) {
      loader.setPath(this.textureLoader.path);
    }
    const children = connections.get(textureNode.id).children;
    let fileName;
    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
      fileName = images[children[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        loader.setPath(void 0);
      }
    }
    const texture = loader.load(fileName);
    loader.setPath(loaderPath);
    return texture;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree.Objects) {
      const materialNodes = fbxTree.Objects.Material;
      for (const nodeID in materialNodes) {
        const material = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material !== null) materialMap.set(parseInt(nodeID), material);
      }
    }
    return materialMap;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type = materialNode.ShadingModel;
    if (typeof type === "object") {
      type = type.value;
    }
    if (!connections.has(ID)) return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material;
    switch (type.toLowerCase()) {
      case "phong":
        material = new MeshPhongMaterial();
        break;
      case "lambert":
        material = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
        material = new MeshPhongMaterial();
        break;
    }
    material.setValues(parameters);
    material.name = name;
    return material;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Diffuse.value), SRGBColorSpace);
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.DiffuseColor.value), SRGBColorSpace);
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Emissive.value), SRGBColorSpace);
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.EmissiveColor.value), SRGBColorSpace);
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    parameters.opacity = 1 - (materialNode.TransparencyFactor ? parseFloat(materialNode.TransparencyFactor.value) : 0);
    if (parameters.opacity === 1 || parameters.opacity === 0) {
      parameters.opacity = materialNode.Opacity ? parseFloat(materialNode.Opacity.value) : null;
      if (parameters.opacity === null) {
        parameters.opacity = 1 - (materialNode.TransparentColor ? parseFloat(materialNode.TransparentColor.value[0]) : 0);
      }
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Specular.value), SRGBColorSpace);
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.SpecularColor.value), SRGBColorSpace);
    }
    const scope = this;
    connections.get(ID).children.forEach(function(child) {
      const type = child.relationship;
      switch (type) {
        case "Bump":
          parameters.bumpMap = scope.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            parameters.map.colorSpace = SRGBColorSpace;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            parameters.emissiveMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping;
            parameters.envMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            parameters.specularMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        // AKA glossiness map
        case "SpecularFactor":
        // AKA specularLevel
        case "VectorDisplacementColor":
        // NOTE: Seems to be a copy of DisplacementColor
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
          break;
      }
    });
    return parameters;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(textureMap, id) {
    if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id = connections.get(id).children[0].ID;
    }
    return textureMap.get(id);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree.Objects) {
      const DeformerNodes = fbxTree.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections.get(parseInt(nodeID));
        if (deformerNode.attrType === "Skin") {
          const skeleton = this.parseSkeleton(relationships, DeformerNodes);
          skeleton.ID = nodeID;
          if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
          skeleton.geometryID = relationships.parents[0].ID;
          skeletons[nodeID] = skeleton;
        } else if (deformerNode.attrType === "BlendShape") {
          const morphTarget = {
            id: nodeID
          };
          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
          morphTarget.id = nodeID;
          if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
          morphTargets[nodeID] = morphTarget;
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster") return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i = 0; i < relationships.children.length; i++) {
      const child = relationships.children[i];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel") return;
      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  // create the main Group() to be returned by the loader
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph = new Group();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree.Objects.Model;
    const scope = this;
    modelMap.forEach(function(model2) {
      const modelNode = modelNodes[model2.ID];
      scope.setLookAtProperties(model2, modelNode);
      const parentConnections = connections.get(model2.ID).parents;
      parentConnections.forEach(function(connection) {
        const parent = modelMap.get(connection.ID);
        if (parent !== void 0) parent.add(model2);
      });
      if (model2.parent === null) {
        sceneGraph.add(model2);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.addGlobalSceneSettings();
    sceneGraph.traverse(function(node) {
      if (node.userData.transformData) {
        if (node.parent) {
          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
        }
        const transform = generateTransform(node.userData.transformData);
        node.applyMatrix4(transform);
        node.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser().parse();
    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
      sceneGraph.children[0].animations = animations;
      sceneGraph = sceneGraph.children[0];
    }
    sceneGraph.animations = animations;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree.Objects.Model;
    for (const nodeID in modelNodes) {
      const id = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections.get(id);
      let model2 = this.buildSkeleton(relationships, skeletons, id, node.attrName);
      if (!model2) {
        switch (node.attrType) {
          case "Camera":
            model2 = this.createCamera(relationships);
            break;
          case "Light":
            model2 = this.createLight(relationships);
            break;
          case "Mesh":
            model2 = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model2 = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model2 = new Bone();
            break;
          case "Null":
          default:
            model2 = new Group();
            break;
        }
        model2.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
        model2.userData.originalName = node.attrName;
        model2.ID = id;
      }
      this.getTransformData(model2, node);
      modelMap.set(id, model2);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id, name) {
    let bone = null;
    relationships.parents.forEach(function(parent) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i) {
          if (rawBone.ID === parent.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
            bone.userData.originalName = name;
            bone.ID = id;
            skeleton.bones[i] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(relationships) {
    let model2;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model2 = new Object3D();
    } else {
      let type = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect = width / height;
      let fov = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type) {
        case 0:
          model2 = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
          if (focalLength !== null) model2.setFocalLength(focalLength);
          break;
        case 1:
          console.warn("THREE.FBXLoader: Orthographic cameras not supported yet.");
          model2 = new Object3D();
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
          model2 = new Object3D();
          break;
      }
    }
    return model2;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(relationships) {
    let model2;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model2 = new Object3D();
    } else {
      let type;
      if (lightAttribute.LightType === void 0) {
        type = 0;
      } else {
        type = lightAttribute.LightType.value;
      }
      let color = 16777215;
      if (lightAttribute.Color !== void 0) {
        color = ColorManagement.toWorkingColorSpace(new Color().fromArray(lightAttribute.Color.value), SRGBColorSpace);
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance = 0;
        } else {
          distance = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type) {
        case 0:
          model2 = new PointLight(color, intensity, distance, decay);
          break;
        case 1:
          model2 = new DirectionalLight(color, intensity);
          break;
        case 2:
          let angle = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model2 = new SpotLight(color, intensity, distance, angle, penumbra, decay);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
          model2 = new PointLight(color, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model2.castShadow = true;
      }
    }
    return model2;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model2;
    let geometry = null;
    let material = null;
    const materials2 = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials2.push(materialMap.get(child.ID));
      }
    });
    if (materials2.length > 1) {
      material = materials2;
    } else if (materials2.length > 0) {
      material = materials2[0];
    } else {
      material = new MeshPhongMaterial({
        name: Loader.DEFAULT_MATERIAL_NAME,
        color: 13421772
      });
      materials2.push(material);
    }
    if ("color" in geometry.attributes) {
      materials2.forEach(function(material2) {
        material2.vertexColors = true;
      });
    }
    if (geometry.FBX_Deformer) {
      model2 = new SkinnedMesh(geometry, material);
      model2.normalizeSkinWeights();
    } else {
      model2 = new Mesh(geometry, material);
    }
    return model2;
  }
  createCurve(relationships, geometryMap) {
    const geometry = relationships.children.reduce(function(geo2, child) {
      if (geometryMap.has(child.ID)) geo2 = geometryMap.get(child.ID);
      return geo2;
    }, null);
    const material = new LineBasicMaterial({
      name: Loader.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Line(geometry, material);
  }
  // parse the model node for transform data
  getTransformData(model2, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    else transformData.eulerOrder = getEulerOrder(0);
    if ("Lcl_Translation" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode) transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode) transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
    model2.userData.transformData = transformData;
  }
  setLookAtProperties(model2, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children = connections.get(model2.ID).children;
      children.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model2.target !== void 0) {
              model2.target.position.fromArray(pos);
              sceneGraph.add(model2.target);
            } else {
              model2.lookAt(new Vector3().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent) {
        if (geometryMap.has(parent.ID)) {
          const geoID = parent.ID;
          const geoRelationships = connections.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model2 = modelMap.get(geoConnParent.ID);
              model2.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree.Objects) {
      const BindPoseNode = fbxTree.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in fbxTree) {
      if ("AmbientColor" in fbxTree.GlobalSettings) {
        const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
        const r = ambientColor[0];
        const g2 = ambientColor[1];
        const b = ambientColor[2];
        if (r !== 0 || g2 !== 0 || b !== 0) {
          const color = new Color().setRGB(r, g2, b, SRGBColorSpace);
          sceneGraph.add(new AmbientLight(color, 1));
        }
      }
      if ("UnitScaleFactor" in fbxTree.GlobalSettings) {
        sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;
      }
    }
  }
};
var GeometryParser = class {
  constructor() {
    this.negativeMaterialIndices = false;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections.get(parseInt(nodeID));
        const geo2 = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo2);
      }
    }
    if (this.negativeMaterialIndices === true) {
      console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
    }
    return geometryMap;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent) {
      return fbxTree.Objects.Model[parent.ID];
    });
    if (modelNodes.length === 0) return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0) skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode) transformData.scale = modelNode.GeometricScaling.value;
    const transform = generateTransform(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo2 = new BufferGeometry();
    if (geoNode.attrName) geo2.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo2.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo2.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
    }
    if (skeleton) {
      geo2.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
      geo2.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
      geo2.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo2.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i) {
      const name = i === 0 ? "uv" : `uv${i}`;
      geo2.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i) {
        if (currentIndex !== prevMaterialIndex) {
          geo2.addGroup(startIndex, i - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i;
        }
      });
      if (geo2.groups.length > 0) {
        const lastGroup = geo2.groups[geo2.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo2.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo2.groups.length === 0) {
        geo2.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo2, geoNode, morphTargets, preTransform);
    return geo2;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i = 0;
      while (geoNode.LayerElementUV[i]) {
        if (geoNode.LayerElementUV[i].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
        }
        i++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i) {
        rawBone.indices.forEach(function(index, j) {
          if (geoInfo.weightTable[index] === void 0) geoInfo.weightTable[index] = [];
          geoInfo.weightTable[index].push({
            id: i,
            weight: rawBone.weights[j]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
      if (geoInfo.color) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex] !== void 0) {
          geoInfo.weightTable[vertexIndex].forEach(function(wt) {
            weights.push(wt.weight);
            weightIndices.push(wt.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i = 0; i < 4; ++i) {
          faceWeights.push(weights[i]);
          faceWeightIndices.push(weightIndices[i]);
        }
      }
      if (geoInfo.normal) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
        if (materialIndex < 0) {
          scope.negativeMaterialIndices = true;
          materialIndex = 0;
        }
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, i) {
          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
          if (faceUVs[i] === void 0) {
            faceUVs[i] = [];
          }
          faceUVs[i].push(data[0]);
          faceUVs[i].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  getNormalNewell(vertices) {
    const normal = new Vector3(0, 0, 0);
    for (let i = 0; i < vertices.length; i++) {
      const current = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      normal.x += (current.y - next.y) * (current.z + next.z);
      normal.y += (current.z - next.z) * (current.x + next.x);
      normal.z += (current.x - next.x) * (current.y + next.y);
    }
    normal.normalize();
    return normal;
  }
  getNormalTangentAndBitangent(vertices) {
    const normalVector = this.getNormalNewell(vertices);
    const up = Math.abs(normalVector.z) > 0.5 ? new Vector3(0, 1, 0) : new Vector3(0, 0, 1);
    const tangent = up.cross(normalVector).normalize();
    const bitangent = normalVector.clone().cross(tangent).normalize();
    return {
      normal: normalVector,
      tangent,
      bitangent
    };
  }
  flattenVertex(vertex, normalTangent, normalBitangent) {
    return new Vector2(
      vertex.dot(normalTangent),
      vertex.dot(normalBitangent)
    );
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    let triangles;
    if (faceLength > 3) {
      const vertices = [];
      const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;
      for (let i = 0; i < facePositionIndexes.length; i += 3) {
        vertices.push(
          new Vector3(
            positions[facePositionIndexes[i]],
            positions[facePositionIndexes[i + 1]],
            positions[facePositionIndexes[i + 2]]
          )
        );
      }
      const { tangent, bitangent } = this.getNormalTangentAndBitangent(vertices);
      const triangulationInput = [];
      for (const vertex of vertices) {
        triangulationInput.push(this.flattenVertex(vertex, tangent, bitangent));
      }
      triangles = ShapeUtils.triangulateShape(triangulationInput, []);
    } else {
      triangles = [[0, 1, 2]];
    }
    for (const [i0, i1, i2] of triangles) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[i0 * 4]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i1 * 4]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i2 * 4]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[i0 * 3]);
        buffers.colors.push(faceColors[i0 * 3 + 1]);
        buffers.colors.push(faceColors[i0 * 3 + 2]);
        buffers.colors.push(faceColors[i1 * 3]);
        buffers.colors.push(faceColors[i1 * 3 + 1]);
        buffers.colors.push(faceColors[i1 * 3 + 2]);
        buffers.colors.push(faceColors[i2 * 3]);
        buffers.colors.push(faceColors[i2 * 3 + 1]);
        buffers.colors.push(faceColors[i2 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[i0 * 3]);
        buffers.normal.push(faceNormals[i0 * 3 + 1]);
        buffers.normal.push(faceNormals[i0 * 3 + 2]);
        buffers.normal.push(faceNormals[i1 * 3]);
        buffers.normal.push(faceNormals[i1 * 3 + 1]);
        buffers.normal.push(faceNormals[i1 * 3 + 2]);
        buffers.normal.push(faceNormals[i2 * 3]);
        buffers.normal.push(faceNormals[i2 * 3 + 1]);
        buffers.normal.push(faceNormals[i2 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, j) {
          if (buffers.uvs[j] === void 0) buffers.uvs[j] = [];
          buffers.uvs[j].push(faceUVs[j][i0 * 2]);
          buffers.uvs[j].push(faceUVs[j][i0 * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i1 * 2]);
          buffers.uvs[j].push(faceUVs[j][i1 * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i2 * 2]);
          buffers.uvs[j].push(faceUVs[j][i2 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0) return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
    const basePositions = parentGeoNode.Vertices !== void 0 ? parentGeoNode.Vertices.a : [];
    const baseIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const morphIndices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length);
    for (let i = 0; i < morphIndices.length; i++) {
      const morphIndex = morphIndices[i] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices: baseIndices,
      vertexPositions: morphPositions,
      baseVertexPositions: basePositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
    positionAttribute.name = name || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer = NormalNode.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer = UVNode.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    for (let i = 0, c = new Color(); i < buffer.length; i += 4) {
      c.fromArray(buffer, i);
      ColorManagement.toWorkingColorSpace(c, SRGBColorSpace);
      c.toArray(buffer, i);
    }
    return {
      dataSize: 4,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(MaterialNode) {
    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode.Materials.a;
    const materialIndices = [];
    for (let i = 0; i < materialIndexBuffer.length; ++i) {
      materialIndices.push(i);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(geoNode) {
    const order = parseInt(geoNode.Order);
    if (isNaN(order)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry();
    }
    const degree = order - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i = 0, l = pointsValues.length; i < l; i += 4) {
      controlPoints.push(new Vector4().fromArray(pointsValues, i));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i = 0; i < degree; ++i) {
        controlPoints.push(controlPoints[i]);
      }
    }
    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry().setFromPoints(points);
  }
};
var AnimationParser = class {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree.Objects.AnimationCurve === void 0) return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children = connection.children;
        children.forEach(function(child, i) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i] === void 0) {
                const modelID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node.transform = child2.matrix;
                      if (child2.userData.transformData) node.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node.transform) node.transform = new Matrix4();
                  if ("PreRotation" in rawModel) node.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel) node.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i] = node;
                }
              }
              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i] === void 0) {
                const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                const morpherID = connections.get(deformerID).parents[0].ID;
                const geoID = connections.get(morpherID).parents[0].ID;
                const modelID = connections.get(geoID).parents[0].ID;
                const rawModel = fbxTree.Objects.Model[modelID];
                const node = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i] = node;
              }
              layerCurveNodes[i][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children = connections.get(parseInt(nodeID)).children;
      if (children.length > 1) {
        console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      }
      const layer = layersMap.get(children[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector3();
    let initialScale = new Vector3();
    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, new Quaternion(), initialScale);
    initialPosition = initialPosition.toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
      if (positionTrack !== void 0) tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
      if (rotationTrack !== void 0) tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0) tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0) tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type) {
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type, times, values);
  }
  generateRotationTrack(modelName, curves, preRotation, postRotation, eulerOrder) {
    let times;
    let values;
    if (curves.x !== void 0 && curves.y !== void 0 && curves.z !== void 0) {
      const result = this.interpolateRotations(curves.x, curves.y, curves.z, eulerOrder);
      times = result[0];
      values = result[1];
    }
    const defaultEulerOrder = getEulerOrder(0);
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils.degToRad);
      preRotation.push(defaultEulerOrder);
      preRotation = new Euler().fromArray(preRotation);
      preRotation = new Quaternion().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils.degToRad);
      postRotation.push(defaultEulerOrder);
      postRotation = new Euler().fromArray(postRotation);
      postRotation = new Quaternion().setFromEuler(postRotation).invert();
    }
    const quaternion2 = new Quaternion();
    const euler = new Euler();
    const quaternionValues = [];
    if (!values || !times) return new QuaternionKeyframeTrack(modelName + ".quaternion", [0], [0]);
    for (let i = 0; i < values.length; i += 3) {
      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
      quaternion2.setFromEuler(euler);
      if (preRotation !== void 0) quaternion2.premultiply(preRotation);
      if (postRotation !== void 0) quaternion2.multiply(postRotation);
      if (i > 2) {
        const prevQuat = new Quaternion().fromArray(
          quaternionValues,
          (i - 3) / 3 * 4
        );
        if (prevQuat.dot(quaternion2) < 0) {
          quaternion2.set(-quaternion2.x, -quaternion2.y, -quaternion2.z, -quaternion2.w);
        }
      }
      quaternion2.toArray(quaternionValues, i / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(curves) {
    let times = [];
    if (curves.x !== void 0) times = times.concat(curves.x.times);
    if (curves.y !== void 0) times = times.concat(curves.y.times);
    if (curves.z !== void 0) times = times.concat(curves.z.times);
    times = times.sort(function(a, b) {
      return a - b;
    });
    if (times.length > 1) {
      let targetIndex = 1;
      let lastValue = times[0];
      for (let i = 1; i < times.length; i++) {
        const currentValue = times[i];
        if (currentValue !== lastValue) {
          times[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times = times.slice(0, targetIndex);
    }
    return times;
  }
  getKeyframeTrackValues(times, curves, initialValue) {
    const prevValue = initialValue;
    const values = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times.forEach(function(time) {
      if (curves.x) xIndex = curves.x.times.indexOf(time);
      if (curves.y) yIndex = curves.y.times.indexOf(time);
      if (curves.z) zIndex = curves.z.times.indexOf(time);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values.push(xValue);
        prevValue[0] = xValue;
      } else {
        values.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values.push(yValue);
        prevValue[1] = yValue;
      } else {
        values.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values.push(zValue);
        prevValue[2] = zValue;
      } else {
        values.push(prevValue[2]);
      }
    });
    return values;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(curvex, curvey, curvez, eulerOrder) {
    const times = [];
    const values = [];
    times.push(curvex.times[0]);
    values.push(MathUtils.degToRad(curvex.values[0]));
    values.push(MathUtils.degToRad(curvey.values[0]));
    values.push(MathUtils.degToRad(curvez.values[0]));
    for (let i = 1; i < curvex.values.length; i++) {
      const initialValue = [
        curvex.values[i - 1],
        curvey.values[i - 1],
        curvez.values[i - 1]
      ];
      if (isNaN(initialValue[0]) || isNaN(initialValue[1]) || isNaN(initialValue[2])) {
        continue;
      }
      const initialValueRad = initialValue.map(MathUtils.degToRad);
      const currentValue = [
        curvex.values[i],
        curvey.values[i],
        curvez.values[i]
      ];
      if (isNaN(currentValue[0]) || isNaN(currentValue[1]) || isNaN(currentValue[2])) {
        continue;
      }
      const currentValueRad = currentValue.map(MathUtils.degToRad);
      const valuesSpan = [
        currentValue[0] - initialValue[0],
        currentValue[1] - initialValue[1],
        currentValue[2] - initialValue[2]
      ];
      const absoluteSpan = [
        Math.abs(valuesSpan[0]),
        Math.abs(valuesSpan[1]),
        Math.abs(valuesSpan[2])
      ];
      if (absoluteSpan[0] >= 180 || absoluteSpan[1] >= 180 || absoluteSpan[2] >= 180) {
        const maxAbsSpan = Math.max(...absoluteSpan);
        const numSubIntervals = maxAbsSpan / 180;
        const E1 = new Euler(...initialValueRad, eulerOrder);
        const E2 = new Euler(...currentValueRad, eulerOrder);
        const Q1 = new Quaternion().setFromEuler(E1);
        const Q2 = new Quaternion().setFromEuler(E2);
        if (Q1.dot(Q2)) {
          Q2.set(-Q2.x, -Q2.y, -Q2.z, -Q2.w);
        }
        const initialTime = curvex.times[i - 1];
        const timeSpan = curvex.times[i] - initialTime;
        const Q3 = new Quaternion();
        const E3 = new Euler();
        for (let t2 = 0; t2 < 1; t2 += 1 / numSubIntervals) {
          Q3.copy(Q1.clone().slerp(Q2.clone(), t2));
          times.push(initialTime + t2 * timeSpan);
          E3.setFromQuaternion(Q3, eulerOrder);
          values.push(E3.x);
          values.push(E3.y);
          values.push(E3.z);
        }
      } else {
        times.push(curvex.times[i]);
        values.push(MathUtils.degToRad(curvex.values[i]));
        values.push(MathUtils.degToRad(curvey.values[i]));
        values.push(MathUtils.degToRad(curvez.values[i]));
      }
    }
    return [times, values];
  }
};
var TextParser = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }
  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope = this;
    const split = text.split(/[\r\n]+/);
    split.forEach(function(line, i) {
      const matchComment = line.match(/^[\s\t]*;/);
      const matchEmpty = line.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty) return;
      const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope.parseNodeBegin(line, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line, matchProperty, split[++i]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line.match(/^[^\s\t}]/)) {
        scope.parseNodePropertyContinued(line);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line, property) {
    const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node = { name: nodeName };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "") currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode") currentNode[nodeName] = [node];
        else currentNode[nodeName] = node;
      }
    }
    if (typeof attrs.id === "number") node.id = attrs.id;
    if (attrs.name !== "") node.attrName = attrs.name;
    if (attrs.type !== "") node.attrType = attrs.type;
    this.pushStack(node);
  }
  parseNodeAttr(attrs) {
    let id = attrs[0];
    if (attrs[0] !== "") {
      id = parseInt(attrs[0]);
      if (isNaN(id)) {
        id = attrs[0];
      }
    }
    let name = "", type = "";
    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, "");
      type = attrs[2];
    }
    return { id, name, type };
  }
  parseNodeProperty(line, property, contentLine) {
    let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(",").slice(3);
      rest = rest.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append(propValue, rest);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node") currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a") currentNode[propName] = propValue;
      else currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(propValue);
    }
  }
  parseNodePropertyContinued(line) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line;
    if (line.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(currentNode.a);
    }
  }
  // parse "Property70"
  parseNodeSpecialProperty(line, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      "type": innerPropType1,
      "type2": innerPropType2,
      "flag": innerPropFlag,
      "value": innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
};
var BinaryParser = class {
  parse(buffer) {
    const reader = new BinaryReader(buffer);
    reader.skip(23);
    const version = reader.getUint32();
    if (version < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
    }
    const allNodes = new FBXTree();
    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version);
      if (node !== null) allNodes.add(node.name, node);
    }
    return allNodes;
  }
  // Check if reader has reached the end of content.
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & -16) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(reader, version) {
    const node = {};
    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
    version >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);
    if (endOffset === 0) return null;
    const propertyList = [];
    for (let i = 0; i < numProperties; i++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version);
      if (subNode !== null) this.parseSubNode(name, node, subNode);
    }
    node.propertyList = propertyList;
    if (typeof id === "number") node.id = id;
    if (attrName !== "") node.attrName = attrName;
    if (attrType !== "") node.attrType = attrType;
    if (name !== "") node.name = name;
    return node;
  }
  parseSubNode(name, node, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node[subNode.name] = value;
      }
    } else if (name === "Connections" && subNode.name === "C") {
      const array = [];
      subNode.propertyList.forEach(function(property, i) {
        if (i !== 0) array.push(property);
      });
      if (node.connections === void 0) {
        node.connections = [];
      }
      node.connections.push(array);
    } else if (subNode.name === "Properties70") {
      const keys = Object.keys(subNode);
      keys.forEach(function(key) {
        node[key] = subNode[key];
      });
    } else if (name === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0) innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0) innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [
          subNode.propertyList[4],
          subNode.propertyList[5],
          subNode.propertyList[6]
        ];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node[innerPropName] = {
        "type": innerPropType1,
        "type2": innerPropType2,
        "flag": innerPropFlag,
        "value": innerPropValue
      };
    } else if (node[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }
        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === void 0) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type = reader.getString(1);
    let length;
    switch (type) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length = reader.getUint32();
        return reader.getArrayBuffer(length);
      case "S":
        length = reader.getUint32();
        return reader.getString(length);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader(data.buffer);
        switch (type) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
        break;
      // cannot happen but is required by the DeepScan
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type);
    }
  }
};
var BinaryReader = class {
  constructor(buffer, littleEndian) {
    this.dv = new DataView(buffer);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length) {
    this.offset += length;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getBoolean());
    }
    return a;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getInt32());
    }
    return a;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295) high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getInt64());
    }
    return a;
  }
  // Note: see getInt64() comment
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getFloat32());
    }
    return a;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getFloat64());
    }
    return a;
  }
  getArrayBuffer(size) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size);
    this.offset += size;
    return value;
  }
  getString(size) {
    const start = this.offset;
    let a = new Uint8Array(this.dv.buffer, start, size);
    this.skip(size);
    const nullByte = a.indexOf(0);
    if (nullByte >= 0) a = new Uint8Array(this.dv.buffer, start, nullByte);
    return this._textDecoder.decode(a);
  }
};
var FBXTree = class {
  add(key, val) {
    this[key] = val;
  }
};
function isFbxFormatBinary(buffer) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i = 0; i < CORRECT.length; ++i) {
    const num = read(1);
    if (num === CORRECT[i]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
var dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect") index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
var tempEuler = new Euler();
var tempVec = new Vector3();
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  const defaultEulerOrder = getEulerOrder(0);
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(defaultEulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || defaultEulerOrder);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(defaultEulerOrder);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer, from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = buffer.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer, from, to));
}
function append(a, b) {
  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
    a[j] = b[i];
  }
}
function slice(a, b, from, to) {
  for (let i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }
  return a;
}
var MeshoptDecoder = function() {
  var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
  var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly !== "object") {
    return {
      supported: false
    };
  }
  var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;
  var instance;
  var ready = WebAssembly.instantiate(unpack(wasm), {}).then(function(result) {
    instance = result.instance;
    instance.exports.__wasm_call_ctors();
  });
  function unpack(data) {
    var result = new Uint8Array(data.length);
    for (var i = 0; i < data.length; ++i) {
      var ch = data.charCodeAt(i);
      result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
    }
    var write = 0;
    for (var i = 0; i < data.length; ++i) {
      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
    }
    return result.buffer.slice(0, write);
  }
  function decode(fun, target, count, size, source, filter) {
    var sbrk = instance.exports.sbrk;
    var count4 = count + 3 & -4;
    var tp = sbrk(count4 * size);
    var sp = sbrk(source.length);
    var heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    var res = fun(tp, count, size, sp, source.length);
    if (res == 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res != 0) {
      throw new Error("Malformed buffer data: " + res);
    }
  }
  var filters = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var decoders = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  var workers = [];
  var requestId = 0;
  function createWorker(url2) {
    var worker2 = {
      object: new Worker(url2),
      pending: 0,
      requests: {}
    };
    worker2.object.onmessage = function(event) {
      var data = event.data;
      worker2.pending -= data.count;
      worker2.requests[data.id][data.action](data.value);
      delete worker2.requests[data.id];
    };
    return worker2;
  }
  function initWorkers(count) {
    var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + decode.toString() + workerProcess.toString();
    var blob = new Blob([source], { type: "text/javascript" });
    var url2 = URL.createObjectURL(blob);
    for (var i = 0; i < count; ++i) {
      workers[i] = createWorker(url2);
    }
    URL.revokeObjectURL(url2);
  }
  function decodeWorker(count, size, source, mode, filter) {
    var worker2 = workers[0];
    for (var i = 1; i < workers.length; ++i) {
      if (workers[i].pending < worker2.pending) {
        worker2 = workers[i];
      }
    }
    return new Promise(function(resolve, reject) {
      var data = new Uint8Array(source);
      var id = requestId++;
      worker2.pending += count;
      worker2.requests[id] = { resolve, reject };
      worker2.object.postMessage({ id, count, size, source: data, mode, filter }, [data.buffer]);
    });
  }
  function workerProcess(event) {
    ready.then(function() {
      var data = event.data;
      try {
        var target = new Uint8Array(data.count * data.size);
        decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);
        self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);
      } catch (error) {
        self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
      }
    });
  }
  return {
    ready,
    supported: true,
    useWorkers: function(count) {
      initWorkers(count);
    },
    decodeVertexBuffer: function(target, count, size, source, filter) {
      decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
    },
    decodeIndexBuffer: function(target, count, size, source) {
      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
    },
    decodeIndexSequence: function(target, count, size, source) {
      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
    },
    decodeGltfBuffer: function(target, count, size, source, mode, filter) {
      decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
    },
    decodeGltfBufferAsync: function(count, size, source, mode, filter) {
      if (workers.length > 0) {
        return decodeWorker(count, size, source, decoders[mode], filters[filter]);
      }
      return ready.then(function() {
        var target = new Uint8Array(count * size);
        decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
        return target;
      });
    }
  };
}();
var _object_pattern = /^[og]\s*(.+)?/;
var _material_library_pattern = /^mtllib /;
var _material_use_pattern = /^usemtl /;
var _map_use_pattern = /^usemap /;
var _face_vertex_data_separator_pattern = /\s+/;
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _ab = new Vector3();
var _cb = new Vector3();
var _color = new Color();
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name2, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = {
            index: this.materials.length,
            name: name2 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addVertexPoint: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addVertexLine: function(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addNormal: function(a, b, c) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addFaceNormal: function(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA.fromArray(src, a);
      _vB.fromArray(src, b);
      _vC.fromArray(src, c);
      _cb.subVectors(_vC, _vB);
      _ab.subVectors(_vA, _vB);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a, b, c) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a] !== void 0) dst.push(src[a + 0], src[a + 1], src[a + 2]);
      if (src[b] !== void 0) dst.push(src[b + 0], src[b + 1], src[b + 2]);
      if (src[c] !== void 0) dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addUV: function(a, b, c) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c + 0], src[c + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    },
    addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a, vLen);
      let ib = this.parseVertexIndex(b, vLen);
      let ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic);
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      }
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        const index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }
      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
var OBJLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = null;
  }
  load(url2, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url2, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url2);
      }
    }, onProgress, onError);
  }
  setMaterials(materials2) {
    this.materials = materials2;
    return this;
  }
  parse(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let result = [];
    for (let i = 0, l = lines.length; i < l; i++) {
      const line = lines[i].trimStart();
      if (line.length === 0) continue;
      const lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#") continue;
      if (lineFirstChar === "v") {
        const data = line.split(_face_vertex_data_separator_pattern);
        switch (data[0]) {
          case "v":
            state.vertices.push(
              parseFloat(data[1]),
              parseFloat(data[2]),
              parseFloat(data[3])
            );
            if (data.length >= 7) {
              _color.setRGB(
                parseFloat(data[4]),
                parseFloat(data[5]),
                parseFloat(data[6]),
                SRGBColorSpace
              );
              state.colors.push(_color.r, _color.g, _color.b);
            } else {
              state.colors.push(void 0, void 0, void 0);
            }
            break;
          case "vn":
            state.normals.push(
              parseFloat(data[1]),
              parseFloat(data[2]),
              parseFloat(data[3])
            );
            break;
          case "vt":
            state.uvs.push(
              parseFloat(data[1]),
              parseFloat(data[2])
            );
            break;
        }
      } else if (lineFirstChar === "f") {
        const lineData = line.slice(1).trim();
        const vertexData = lineData.split(_face_vertex_data_separator_pattern);
        const faceVertices = [];
        for (let j = 0, jl = vertexData.length; j < jl; j++) {
          const vertex = vertexData[j];
          if (vertex.length > 0) {
            const vertexParts = vertex.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v1 = faceVertices[0];
        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
          const v2 = faceVertices[j];
          const v3 = faceVertices[j + 1];
          state.addFace(
            v1[0],
            v2[0],
            v3[0],
            v1[1],
            v2[1],
            v3[1],
            v1[2],
            v2[2],
            v3[2]
          );
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line.substring(1).trim().split(" ");
        let lineVertices = [];
        const lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "") lineVertices.push(parts[0]);
            if (parts[1] !== "") lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line.slice(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = _object_pattern.exec(line)) !== null) {
        const name = (" " + result[0].slice(1).trim()).slice(1);
        state.startObject(name);
      } else if (_material_use_pattern.test(line)) {
        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      } else if (_material_library_pattern.test(line)) {
        state.materialLibraries.push(line.substring(7).trim());
      } else if (_map_use_pattern.test(line)) {
        console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
      } else if (lineFirstChar === "s") {
        result = line.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material) material.smooth = state.object.smooth;
      } else {
        if (line === "\0") continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
      }
    }
    state.finalize();
    const container = new Group();
    container.materialLibraries = [].concat(state.materialLibraries);
    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
    if (hasPrimitives === true) {
      for (let i = 0, l = state.objects.length; i < l; i++) {
        const object = state.objects[i];
        const geometry = object.geometry;
        const materials2 = object.materials;
        const isLine = geometry.type === "Line";
        const isPoints = geometry.type === "Points";
        let hasVertexColors = false;
        if (geometry.vertices.length === 0) continue;
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(geometry.vertices, 3));
        if (geometry.normals.length > 0) {
          buffergeometry.setAttribute("normal", new Float32BufferAttribute(geometry.normals, 3));
        }
        if (geometry.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute("color", new Float32BufferAttribute(geometry.colors, 3));
        }
        if (geometry.hasUVIndices === true) {
          buffergeometry.setAttribute("uv", new Float32BufferAttribute(geometry.uvs, 2));
        }
        const createdMaterials = [];
        for (let mi = 0, miLen = materials2.length; mi < miLen; mi++) {
          const sourceMaterial = materials2[mi];
          const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
          let material = state.materials[materialHash];
          if (this.materials !== null) {
            material = this.materials.create(sourceMaterial.name);
            if (isLine && material && !(material instanceof LineBasicMaterial)) {
              const materialLine = new LineBasicMaterial();
              Material.prototype.copy.call(materialLine, material);
              materialLine.color.copy(material.color);
              material = materialLine;
            } else if (isPoints && material && !(material instanceof PointsMaterial)) {
              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });
              Material.prototype.copy.call(materialPoints, material);
              materialPoints.color.copy(material.color);
              materialPoints.map = material.map;
              material = materialPoints;
            }
          }
          if (material === void 0) {
            if (isLine) {
              material = new LineBasicMaterial();
            } else if (isPoints) {
              material = new PointsMaterial({ size: 1, sizeAttenuation: false });
            } else {
              material = new MeshPhongMaterial();
            }
            material.name = sourceMaterial.name;
            material.flatShading = sourceMaterial.smooth ? false : true;
            material.vertexColors = hasVertexColors;
            state.materials[materialHash] = material;
          }
          createdMaterials.push(material);
        }
        let mesh;
        if (createdMaterials.length > 1) {
          for (let mi = 0, miLen = materials2.length; mi < miLen; mi++) {
            const sourceMaterial = materials2[mi];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
          }
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials[0]);
          }
        }
        mesh.name = object.name;
        container.add(mesh);
      }
    } else {
      if (state.vertices.length > 0) {
        const material = new PointsMaterial({ size: 1, sizeAttenuation: false });
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(state.vertices, 3));
        if (state.colors.length > 0 && state.colors[0] !== void 0) {
          buffergeometry.setAttribute("color", new Float32BufferAttribute(state.colors, 3));
          material.vertexColors = true;
        }
        const points = new Points(buffergeometry, material);
        container.add(points);
      }
    }
    return container;
  }
};
var STLLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url2, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url2, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url2);
      }
    }, onProgress, onError);
  }
  parse(data) {
    function isBinary(data2) {
      const reader = new DataView(data2);
      const face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
      const n_faces = reader.getUint32(80, true);
      const expect = 80 + 32 / 8 + n_faces * face_size;
      if (expect === reader.byteLength) {
        return true;
      }
      const solid = [115, 111, 108, 105, 100];
      for (let off = 0; off < 5; off++) {
        if (matchDataViewAt(solid, reader, off)) return false;
      }
      return true;
    }
    function matchDataViewAt(query, reader, offset) {
      for (let i = 0, il = query.length; i < il; i++) {
        if (query[i] !== reader.getUint8(offset + i)) return false;
      }
      return true;
    }
    function parseBinary(data2) {
      const reader = new DataView(data2);
      const faces = reader.getUint32(80, true);
      let r, g2, b, hasColors = false, colors;
      let defaultR, defaultG, defaultB, alpha;
      for (let index = 0; index < 80 - 10; index++) {
        if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {
          hasColors = true;
          colors = new Float32Array(faces * 3 * 3);
          defaultR = reader.getUint8(index + 6) / 255;
          defaultG = reader.getUint8(index + 7) / 255;
          defaultB = reader.getUint8(index + 8) / 255;
          alpha = reader.getUint8(index + 9) / 255;
        }
      }
      const dataOffset = 84;
      const faceLength = 12 * 4 + 2;
      const geometry = new BufferGeometry();
      const vertices = new Float32Array(faces * 3 * 3);
      const normals = new Float32Array(faces * 3 * 3);
      const color = new Color();
      for (let face = 0; face < faces; face++) {
        const start = dataOffset + face * faceLength;
        const normalX = reader.getFloat32(start, true);
        const normalY = reader.getFloat32(start + 4, true);
        const normalZ = reader.getFloat32(start + 8, true);
        if (hasColors) {
          const packedColor = reader.getUint16(start + 48, true);
          if ((packedColor & 32768) === 0) {
            r = (packedColor & 31) / 31;
            g2 = (packedColor >> 5 & 31) / 31;
            b = (packedColor >> 10 & 31) / 31;
          } else {
            r = defaultR;
            g2 = defaultG;
            b = defaultB;
          }
        }
        for (let i = 1; i <= 3; i++) {
          const vertexstart = start + i * 12;
          const componentIdx = face * 3 * 3 + (i - 1) * 3;
          vertices[componentIdx] = reader.getFloat32(vertexstart, true);
          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);
          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);
          normals[componentIdx] = normalX;
          normals[componentIdx + 1] = normalY;
          normals[componentIdx + 2] = normalZ;
          if (hasColors) {
            color.setRGB(r, g2, b, SRGBColorSpace);
            colors[componentIdx] = color.r;
            colors[componentIdx + 1] = color.g;
            colors[componentIdx + 2] = color.b;
          }
        }
      }
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("normal", new BufferAttribute(normals, 3));
      if (hasColors) {
        geometry.setAttribute("color", new BufferAttribute(colors, 3));
        geometry.hasColors = true;
        geometry.alpha = alpha;
      }
      return geometry;
    }
    function parseASCII(data2) {
      const geometry = new BufferGeometry();
      const patternSolid = /solid([\s\S]*?)endsolid/g;
      const patternFace = /facet([\s\S]*?)endfacet/g;
      const patternName = /solid\s(.+)/;
      let faceCounter = 0;
      const patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
      const patternVertex = new RegExp("vertex" + patternFloat + patternFloat + patternFloat, "g");
      const patternNormal = new RegExp("normal" + patternFloat + patternFloat + patternFloat, "g");
      const vertices = [];
      const normals = [];
      const groupNames = [];
      const normal = new Vector3();
      let result;
      let groupCount = 0;
      let startVertex = 0;
      let endVertex = 0;
      while ((result = patternSolid.exec(data2)) !== null) {
        startVertex = endVertex;
        const solid = result[0];
        const name = (result = patternName.exec(solid)) !== null ? result[1] : "";
        groupNames.push(name);
        while ((result = patternFace.exec(solid)) !== null) {
          let vertexCountPerFace = 0;
          let normalCountPerFace = 0;
          const text = result[0];
          while ((result = patternNormal.exec(text)) !== null) {
            normal.x = parseFloat(result[1]);
            normal.y = parseFloat(result[2]);
            normal.z = parseFloat(result[3]);
            normalCountPerFace++;
          }
          while ((result = patternVertex.exec(text)) !== null) {
            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
            normals.push(normal.x, normal.y, normal.z);
            vertexCountPerFace++;
            endVertex++;
          }
          if (normalCountPerFace !== 1) {
            console.error("THREE.STLLoader: Something isn't right with the normal of face number " + faceCounter);
          }
          if (vertexCountPerFace !== 3) {
            console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + faceCounter);
          }
          faceCounter++;
        }
        const start = startVertex;
        const count = endVertex - startVertex;
        geometry.userData.groupNames = groupNames;
        geometry.addGroup(start, count, groupCount);
        groupCount++;
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      return geometry;
    }
    function ensureString(buffer) {
      if (typeof buffer !== "string") {
        return new TextDecoder().decode(buffer);
      }
      return buffer;
    }
    function ensureBinary(buffer) {
      if (typeof buffer === "string") {
        const array_buffer = new Uint8Array(buffer.length);
        for (let i = 0; i < buffer.length; i++) {
          array_buffer[i] = buffer.charCodeAt(i) & 255;
        }
        return array_buffer.buffer || array_buffer;
      } else {
        return buffer;
      }
    }
    const binData = ensureBinary(data);
    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));
  }
};
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(buffer) {
    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
        case rgbe_write_error:
          throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
        case rgbe_format_error:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
        default:
        case rgbe_memory_error:
          throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
      }
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p2 = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p2, p2 + chunkSize)));
      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p2 < buffer2.byteLength) {
        s += chunk;
        len += chunk.length;
        p2 += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p2, p2 + chunkSize)));
      }
      if (-1 < i) {
        buffer2.pos += len + i + 1;
        return s + chunk.slice(0, i);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let line, match;
      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
        rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line.match(magic_token_re))) {
        rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line + "\n";
      while (true) {
        line = fgets(buffer2);
        if (false === line) break;
        header.string += line + "\n";
        if ("#" === line.charAt(0)) {
          header.comments += line + "\n";
          continue;
        }
        if (match = line.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {
      const scanline_width = w2;
      if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
        (2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128)
      ) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w2 * h2);
      if (!data_rgba.length) {
        rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h2;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun) count -= 128;
          if (0 === count || ptr + count > ptr_end) {
            rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i = 0; i < count; i++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i = 0; i < l; i++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
    let data, type;
    let numElements;
    switch (this.type) {
      case FloatType:
        numElements = image_rgba_data.length / 4;
        const floatArray = new Float32Array(numElements * 4);
        for (let j = 0; j < numElements; j++) {
          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
        }
        data = floatArray;
        type = FloatType;
        break;
      case HalfFloatType:
        numElements = image_rgba_data.length / 4;
        const halfArray = new Uint16Array(numElements * 4);
        for (let j = 0; j < numElements; j++) {
          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
        }
        data = halfArray;
        type = HalfFloatType;
        break;
      default:
        throw new Error("THREE.RGBELoader: unsupported type: ", this.type);
    }
    return {
      width: w,
      height: h,
      data,
      header: rgbe_header_info.string,
      gamma: rgbe_header_info.gamma,
      exposure: rgbe_header_info.exposure,
      type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url2, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case FloatType:
        case HalfFloatType:
          texture.colorSpace = LinearSRGBColorSpace;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad) onLoad(texture, texData);
    }
    return super.load(url2, onLoadCallback, onProgress, onError);
  }
};
var EXRLoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer) {
    const USHORT_RANGE = 1 << 16;
    const BITMAP_SIZE = USHORT_RANGE >> 3;
    const HUF_ENCBITS = 16;
    const HUF_DECBITS = 14;
    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
    const HUF_DECSIZE = 1 << HUF_DECBITS;
    const HUF_DECMASK = HUF_DECSIZE - 1;
    const NBITS = 16;
    const A_OFFSET = 1 << NBITS - 1;
    const MOD_MASK = (1 << NBITS) - 1;
    const SHORT_ZEROCODE_RUN = 59;
    const LONG_ZEROCODE_RUN = 63;
    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
    const ULONG_SIZE = 8;
    const FLOAT32_SIZE = 4;
    const INT32_SIZE = 4;
    const INT16_SIZE = 2;
    const INT8_SIZE = 1;
    const STATIC_HUFFMAN = 0;
    const DEFLATE = 1;
    const UNKNOWN = 0;
    const LOSSY_DCT = 1;
    const RLE = 2;
    const logBase = Math.pow(2.7182818, 2.2);
    function reverseLutFromBitmap(bitmap, lut) {
      let k = 0;
      for (let i = 0; i < USHORT_RANGE; ++i) {
        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {
          lut[k++] = i;
        }
      }
      const n2 = k - 1;
      while (k < USHORT_RANGE) lut[k++] = 0;
      return n2;
    }
    function hufClearDecTable(hdec) {
      for (let i = 0; i < HUF_DECSIZE; i++) {
        hdec[i] = {};
        hdec[i].len = 0;
        hdec[i].lit = 0;
        hdec[i].p = null;
      }
    }
    const getBitsReturn = { l: 0, c: 0, lc: 0 };
    function getBits(nBits, c, lc, uInt8Array2, inOffset) {
      while (lc < nBits) {
        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
        lc += 8;
      }
      lc -= nBits;
      getBitsReturn.l = c >> lc & (1 << nBits) - 1;
      getBitsReturn.c = c;
      getBitsReturn.lc = lc;
    }
    const hufTableBuffer = new Array(59);
    function hufCanonicalCodeTable(hcode) {
      for (let i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;
      for (let i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;
      let c = 0;
      for (let i = 58; i > 0; --i) {
        const nc = c + hufTableBuffer[i] >> 1;
        hufTableBuffer[i] = c;
        c = nc;
      }
      for (let i = 0; i < HUF_ENCSIZE; ++i) {
        const l = hcode[i];
        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;
      }
    }
    function hufUnpackEncTable(uInt8Array2, inOffset, ni, im, iM, hcode) {
      const p2 = inOffset;
      let c = 0;
      let lc = 0;
      for (; im <= iM; im++) {
        if (p2.value - inOffset.value > ni) return false;
        getBits(6, c, lc, uInt8Array2, p2);
        const l = getBitsReturn.l;
        c = getBitsReturn.c;
        lc = getBitsReturn.lc;
        hcode[im] = l;
        if (l == LONG_ZEROCODE_RUN) {
          if (p2.value - inOffset.value > ni) {
            throw new Error("Something wrong with hufUnpackEncTable");
          }
          getBits(8, c, lc, uInt8Array2, p2);
          let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
          c = getBitsReturn.c;
          lc = getBitsReturn.lc;
          if (im + zerun > iM + 1) {
            throw new Error("Something wrong with hufUnpackEncTable");
          }
          while (zerun--) hcode[im++] = 0;
          im--;
        } else if (l >= SHORT_ZEROCODE_RUN) {
          let zerun = l - SHORT_ZEROCODE_RUN + 2;
          if (im + zerun > iM + 1) {
            throw new Error("Something wrong with hufUnpackEncTable");
          }
          while (zerun--) hcode[im++] = 0;
          im--;
        }
      }
      hufCanonicalCodeTable(hcode);
    }
    function hufLength(code) {
      return code & 63;
    }
    function hufCode(code) {
      return code >> 6;
    }
    function hufBuildDecTable(hcode, im, iM, hdecod) {
      for (; im <= iM; im++) {
        const c = hufCode(hcode[im]);
        const l = hufLength(hcode[im]);
        if (c >> l) {
          throw new Error("Invalid table entry");
        }
        if (l > HUF_DECBITS) {
          const pl = hdecod[c >> l - HUF_DECBITS];
          if (pl.len) {
            throw new Error("Invalid table entry");
          }
          pl.lit++;
          if (pl.p) {
            const p2 = pl.p;
            pl.p = new Array(pl.lit);
            for (let i = 0; i < pl.lit - 1; ++i) {
              pl.p[i] = p2[i];
            }
          } else {
            pl.p = new Array(1);
          }
          pl.p[pl.lit - 1] = im;
        } else if (l) {
          let plOffset = 0;
          for (let i = 1 << HUF_DECBITS - l; i > 0; i--) {
            const pl = hdecod[(c << HUF_DECBITS - l) + plOffset];
            if (pl.len || pl.p) {
              throw new Error("Invalid table entry");
            }
            pl.len = l;
            pl.lit = im;
            plOffset++;
          }
        }
      }
      return true;
    }
    const getCharReturn = { c: 0, lc: 0 };
    function getChar(c, lc, uInt8Array2, inOffset) {
      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
      lc += 8;
      getCharReturn.c = c;
      getCharReturn.lc = lc;
    }
    const getCodeReturn = { c: 0, lc: 0 };
    function getCode(po, rlc, c, lc, uInt8Array2, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
      if (po == rlc) {
        if (lc < 8) {
          getChar(c, lc, uInt8Array2, inOffset);
          c = getCharReturn.c;
          lc = getCharReturn.lc;
        }
        lc -= 8;
        let cs = c >> lc;
        cs = new Uint8Array([cs])[0];
        if (outBufferOffset.value + cs > outBufferEndOffset) {
          return false;
        }
        const s = outBuffer[outBufferOffset.value - 1];
        while (cs-- > 0) {
          outBuffer[outBufferOffset.value++] = s;
        }
      } else if (outBufferOffset.value < outBufferEndOffset) {
        outBuffer[outBufferOffset.value++] = po;
      } else {
        return false;
      }
      getCodeReturn.c = c;
      getCodeReturn.lc = lc;
    }
    function UInt16(value) {
      return value & 65535;
    }
    function Int16(value) {
      const ref = UInt16(value);
      return ref > 32767 ? ref - 65536 : ref;
    }
    const wdec14Return = { a: 0, b: 0 };
    function wdec14(l, h) {
      const ls = Int16(l);
      const hs = Int16(h);
      const hi = hs;
      const ai = ls + (hi & 1) + (hi >> 1);
      const as = ai;
      const bs = ai - hi;
      wdec14Return.a = as;
      wdec14Return.b = bs;
    }
    function wdec16(l, h) {
      const m2 = UInt16(l);
      const d = UInt16(h);
      const bb = m2 - (d >> 1) & MOD_MASK;
      const aa = d + bb - A_OFFSET & MOD_MASK;
      wdec14Return.a = aa;
      wdec14Return.b = bb;
    }
    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {
      const w14 = mx < 1 << 14;
      const n2 = nx > ny ? ny : nx;
      let p2 = 1;
      let p22;
      let py;
      while (p2 <= n2) p2 <<= 1;
      p2 >>= 1;
      p22 = p2;
      p2 >>= 1;
      while (p2 >= 1) {
        py = 0;
        const ey = py + oy * (ny - p22);
        const oy1 = oy * p2;
        const oy2 = oy * p22;
        const ox1 = ox * p2;
        const ox2 = ox * p22;
        let i00, i01, i10, i11;
        for (; py <= ey; py += oy2) {
          let px = py;
          const ex = py + ox * (nx - p22);
          for (; px <= ex; px += ox2) {
            const p01 = px + ox1;
            const p10 = px + oy1;
            const p11 = p10 + ox1;
            if (w14) {
              wdec14(buffer2[px + j], buffer2[p10 + j]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec14(buffer2[p01 + j], buffer2[p11 + j]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec14(i00, i01);
              buffer2[px + j] = wdec14Return.a;
              buffer2[p01 + j] = wdec14Return.b;
              wdec14(i10, i11);
              buffer2[p10 + j] = wdec14Return.a;
              buffer2[p11 + j] = wdec14Return.b;
            } else {
              wdec16(buffer2[px + j], buffer2[p10 + j]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec16(buffer2[p01 + j], buffer2[p11 + j]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec16(i00, i01);
              buffer2[px + j] = wdec14Return.a;
              buffer2[p01 + j] = wdec14Return.b;
              wdec16(i10, i11);
              buffer2[p10 + j] = wdec14Return.a;
              buffer2[p11 + j] = wdec14Return.b;
            }
          }
          if (nx & p2) {
            const p10 = px + oy1;
            if (w14)
              wdec14(buffer2[px + j], buffer2[p10 + j]);
            else
              wdec16(buffer2[px + j], buffer2[p10 + j]);
            i00 = wdec14Return.a;
            buffer2[p10 + j] = wdec14Return.b;
            buffer2[px + j] = i00;
          }
        }
        if (ny & p2) {
          let px = py;
          const ex = py + ox * (nx - p22);
          for (; px <= ex; px += ox2) {
            const p01 = px + ox1;
            if (w14)
              wdec14(buffer2[px + j], buffer2[p01 + j]);
            else
              wdec16(buffer2[px + j], buffer2[p01 + j]);
            i00 = wdec14Return.a;
            buffer2[p01 + j] = wdec14Return.b;
            buffer2[px + j] = i00;
          }
        }
        p22 = p2;
        p2 >>= 1;
      }
      return py;
    }
    function hufDecode(encodingTable, decodingTable, uInt8Array2, inOffset, ni, rlc, no, outBuffer, outOffset) {
      let c = 0;
      let lc = 0;
      const outBufferEndOffset = no;
      const inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
      while (inOffset.value < inOffsetEnd) {
        getChar(c, lc, uInt8Array2, inOffset);
        c = getCharReturn.c;
        lc = getCharReturn.lc;
        while (lc >= HUF_DECBITS) {
          const index = c >> lc - HUF_DECBITS & HUF_DECMASK;
          const pl = decodingTable[index];
          if (pl.len) {
            lc -= pl.len;
            getCode(pl.lit, rlc, c, lc, uInt8Array2, inOffset, outBuffer, outOffset, outBufferEndOffset);
            c = getCodeReturn.c;
            lc = getCodeReturn.lc;
          } else {
            if (!pl.p) {
              throw new Error("hufDecode issues");
            }
            let j;
            for (j = 0; j < pl.lit; j++) {
              const l = hufLength(encodingTable[pl.p[j]]);
              while (lc < l && inOffset.value < inOffsetEnd) {
                getChar(c, lc, uInt8Array2, inOffset);
                c = getCharReturn.c;
                lc = getCharReturn.lc;
              }
              if (lc >= l) {
                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {
                  lc -= l;
                  getCode(pl.p[j], rlc, c, lc, uInt8Array2, inOffset, outBuffer, outOffset, outBufferEndOffset);
                  c = getCodeReturn.c;
                  lc = getCodeReturn.lc;
                  break;
                }
              }
            }
            if (j == pl.lit) {
              throw new Error("hufDecode issues");
            }
          }
        }
      }
      const i = 8 - ni & 7;
      c >>= i;
      lc -= i;
      while (lc > 0) {
        const pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];
        if (pl.len) {
          lc -= pl.len;
          getCode(pl.lit, rlc, c, lc, uInt8Array2, inOffset, outBuffer, outOffset, outBufferEndOffset);
          c = getCodeReturn.c;
          lc = getCodeReturn.lc;
        } else {
          throw new Error("hufDecode issues");
        }
      }
      return true;
    }
    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
      const outOffset = { value: 0 };
      const initialInOffset = inOffset.value;
      const im = parseUint32(inDataView, inOffset);
      const iM = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      const nBits = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
        throw new Error("Something wrong with HUF_ENCSIZE");
      }
      const freq = new Array(HUF_ENCSIZE);
      const hdec = new Array(HUF_DECSIZE);
      hufClearDecTable(hdec);
      const ni = nCompressed - (inOffset.value - initialInOffset);
      hufUnpackEncTable(uInt8Array2, inOffset, ni, im, iM, freq);
      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
        throw new Error("Something wrong with hufUncompress");
      }
      hufBuildDecTable(freq, im, iM, hdec);
      hufDecode(freq, hdec, uInt8Array2, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
    }
    function applyLut(lut, data, nData) {
      for (let i = 0; i < nData; ++i) {
        data[i] = lut[data[i]];
      }
    }
    function predictor(source) {
      for (let t2 = 1; t2 < source.length; t2++) {
        const d = source[t2 - 1] + source[t2] - 128;
        source[t2] = d;
      }
    }
    function interleaveScalar(source, out) {
      let t1 = 0;
      let t2 = Math.floor((source.length + 1) / 2);
      let s = 0;
      const stop = source.length - 1;
      while (true) {
        if (s > stop) break;
        out[s++] = source[t1++];
        if (s > stop) break;
        out[s++] = source[t2++];
      }
    }
    function decodeRunLength(source) {
      let size = source.byteLength;
      const out = new Array();
      let p2 = 0;
      const reader = new DataView(source);
      while (size > 0) {
        const l = reader.getInt8(p2++);
        if (l < 0) {
          const count = -l;
          size -= count + 1;
          for (let i = 0; i < count; i++) {
            out.push(reader.getUint8(p2++));
          }
        } else {
          const count = l;
          size -= 2;
          const value = reader.getUint8(p2++);
          for (let i = 0; i < count + 1; i++) {
            out.push(value);
          }
        }
      }
      return out;
    }
    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
      let dataView = new DataView(outBuffer.buffer);
      const width = channelData[cscSet.idx[0]].width;
      const height = channelData[cscSet.idx[0]].height;
      const numComp = 3;
      const numFullBlocksX = Math.floor(width / 8);
      const numBlocksX = Math.ceil(width / 8);
      const numBlocksY = Math.ceil(height / 8);
      const leftoverX = width - (numBlocksX - 1) * 8;
      const leftoverY = height - (numBlocksY - 1) * 8;
      const currAcComp = { value: 0 };
      const currDcComp = new Array(numComp);
      const dctData = new Array(numComp);
      const halfZigBlock = new Array(numComp);
      const rowBlock = new Array(numComp);
      const rowOffsets = new Array(numComp);
      for (let comp = 0; comp < numComp; ++comp) {
        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];
        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;
        dctData[comp] = new Float32Array(64);
        halfZigBlock[comp] = new Uint16Array(64);
        rowBlock[comp] = new Uint16Array(numBlocksX * 64);
      }
      for (let blocky = 0; blocky < numBlocksY; ++blocky) {
        let maxY = 8;
        if (blocky == numBlocksY - 1)
          maxY = leftoverY;
        let maxX = 8;
        for (let blockx = 0; blockx < numBlocksX; ++blockx) {
          if (blockx == numBlocksX - 1)
            maxX = leftoverX;
          for (let comp = 0; comp < numComp; ++comp) {
            halfZigBlock[comp].fill(0);
            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++];
            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]);
            unZigZag(halfZigBlock[comp], dctData[comp]);
            dctInverse(dctData[comp]);
          }
          {
            csc709Inverse(dctData);
          }
          for (let comp = 0; comp < numComp; ++comp) {
            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);
          }
        }
        let offset2 = 0;
        for (let comp = 0; comp < numComp; ++comp) {
          const type = channelData[cscSet.idx[comp]].type;
          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {
            offset2 = rowOffsets[comp][y];
            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {
              const src = blockx * 64 + (y & 7) * 8;
              dataView.setUint16(offset2 + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);
              dataView.setUint16(offset2 + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);
              dataView.setUint16(offset2 + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);
              dataView.setUint16(offset2 + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);
              dataView.setUint16(offset2 + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);
              dataView.setUint16(offset2 + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);
              dataView.setUint16(offset2 + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);
              dataView.setUint16(offset2 + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);
              offset2 += 8 * INT16_SIZE * type;
            }
          }
          if (numFullBlocksX != numBlocksX) {
            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {
              const offset3 = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;
              const src = numFullBlocksX * 64 + (y & 7) * 8;
              for (let x2 = 0; x2 < maxX; ++x2) {
                dataView.setUint16(offset3 + x2 * INT16_SIZE * type, rowBlock[comp][src + x2], true);
              }
            }
          }
        }
      }
      const halfRow = new Uint16Array(width);
      dataView = new DataView(outBuffer.buffer);
      for (let comp = 0; comp < numComp; ++comp) {
        channelData[cscSet.idx[comp]].decoded = true;
        const type = channelData[cscSet.idx[comp]].type;
        if (channelData[comp].type != 2) continue;
        for (let y = 0; y < height; ++y) {
          const offset2 = rowOffsets[comp][y];
          for (let x2 = 0; x2 < width; ++x2) {
            halfRow[x2] = dataView.getUint16(offset2 + x2 * INT16_SIZE * type, true);
          }
          for (let x2 = 0; x2 < width; ++x2) {
            dataView.setFloat32(offset2 + x2 * INT16_SIZE * type, decodeFloat16(halfRow[x2]), true);
          }
        }
      }
    }
    function unRleAC(currAcComp, acBuffer, halfZigBlock) {
      let acValue;
      let dctComp = 1;
      while (dctComp < 64) {
        acValue = acBuffer[currAcComp.value];
        if (acValue == 65280) {
          dctComp = 64;
        } else if (acValue >> 8 == 255) {
          dctComp += acValue & 255;
        } else {
          halfZigBlock[dctComp] = acValue;
          dctComp++;
        }
        currAcComp.value++;
      }
    }
    function unZigZag(src, dst) {
      dst[0] = decodeFloat16(src[0]);
      dst[1] = decodeFloat16(src[1]);
      dst[2] = decodeFloat16(src[5]);
      dst[3] = decodeFloat16(src[6]);
      dst[4] = decodeFloat16(src[14]);
      dst[5] = decodeFloat16(src[15]);
      dst[6] = decodeFloat16(src[27]);
      dst[7] = decodeFloat16(src[28]);
      dst[8] = decodeFloat16(src[2]);
      dst[9] = decodeFloat16(src[4]);
      dst[10] = decodeFloat16(src[7]);
      dst[11] = decodeFloat16(src[13]);
      dst[12] = decodeFloat16(src[16]);
      dst[13] = decodeFloat16(src[26]);
      dst[14] = decodeFloat16(src[29]);
      dst[15] = decodeFloat16(src[42]);
      dst[16] = decodeFloat16(src[3]);
      dst[17] = decodeFloat16(src[8]);
      dst[18] = decodeFloat16(src[12]);
      dst[19] = decodeFloat16(src[17]);
      dst[20] = decodeFloat16(src[25]);
      dst[21] = decodeFloat16(src[30]);
      dst[22] = decodeFloat16(src[41]);
      dst[23] = decodeFloat16(src[43]);
      dst[24] = decodeFloat16(src[9]);
      dst[25] = decodeFloat16(src[11]);
      dst[26] = decodeFloat16(src[18]);
      dst[27] = decodeFloat16(src[24]);
      dst[28] = decodeFloat16(src[31]);
      dst[29] = decodeFloat16(src[40]);
      dst[30] = decodeFloat16(src[44]);
      dst[31] = decodeFloat16(src[53]);
      dst[32] = decodeFloat16(src[10]);
      dst[33] = decodeFloat16(src[19]);
      dst[34] = decodeFloat16(src[23]);
      dst[35] = decodeFloat16(src[32]);
      dst[36] = decodeFloat16(src[39]);
      dst[37] = decodeFloat16(src[45]);
      dst[38] = decodeFloat16(src[52]);
      dst[39] = decodeFloat16(src[54]);
      dst[40] = decodeFloat16(src[20]);
      dst[41] = decodeFloat16(src[22]);
      dst[42] = decodeFloat16(src[33]);
      dst[43] = decodeFloat16(src[38]);
      dst[44] = decodeFloat16(src[46]);
      dst[45] = decodeFloat16(src[51]);
      dst[46] = decodeFloat16(src[55]);
      dst[47] = decodeFloat16(src[60]);
      dst[48] = decodeFloat16(src[21]);
      dst[49] = decodeFloat16(src[34]);
      dst[50] = decodeFloat16(src[37]);
      dst[51] = decodeFloat16(src[47]);
      dst[52] = decodeFloat16(src[50]);
      dst[53] = decodeFloat16(src[56]);
      dst[54] = decodeFloat16(src[59]);
      dst[55] = decodeFloat16(src[61]);
      dst[56] = decodeFloat16(src[35]);
      dst[57] = decodeFloat16(src[36]);
      dst[58] = decodeFloat16(src[48]);
      dst[59] = decodeFloat16(src[49]);
      dst[60] = decodeFloat16(src[57]);
      dst[61] = decodeFloat16(src[58]);
      dst[62] = decodeFloat16(src[62]);
      dst[63] = decodeFloat16(src[63]);
    }
    function dctInverse(data) {
      const a = 0.5 * Math.cos(3.14159 / 4);
      const b = 0.5 * Math.cos(3.14159 / 16);
      const c = 0.5 * Math.cos(3.14159 / 8);
      const d = 0.5 * Math.cos(3 * 3.14159 / 16);
      const e = 0.5 * Math.cos(5 * 3.14159 / 16);
      const f = 0.5 * Math.cos(3 * 3.14159 / 8);
      const g2 = 0.5 * Math.cos(7 * 3.14159 / 16);
      const alpha = new Array(4);
      const beta = new Array(4);
      const theta = new Array(4);
      const gamma = new Array(4);
      for (let row = 0; row < 8; ++row) {
        const rowPtr = row * 8;
        alpha[0] = c * data[rowPtr + 2];
        alpha[1] = f * data[rowPtr + 2];
        alpha[2] = c * data[rowPtr + 6];
        alpha[3] = f * data[rowPtr + 6];
        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g2 * data[rowPtr + 7];
        beta[1] = d * data[rowPtr + 1] - g2 * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];
        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g2 * data[rowPtr + 5] + d * data[rowPtr + 7];
        beta[3] = g2 * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];
        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);
        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[rowPtr + 0] = gamma[0] + beta[0];
        data[rowPtr + 1] = gamma[1] + beta[1];
        data[rowPtr + 2] = gamma[2] + beta[2];
        data[rowPtr + 3] = gamma[3] + beta[3];
        data[rowPtr + 4] = gamma[3] - beta[3];
        data[rowPtr + 5] = gamma[2] - beta[2];
        data[rowPtr + 6] = gamma[1] - beta[1];
        data[rowPtr + 7] = gamma[0] - beta[0];
      }
      for (let column = 0; column < 8; ++column) {
        alpha[0] = c * data[16 + column];
        alpha[1] = f * data[16 + column];
        alpha[2] = c * data[48 + column];
        alpha[3] = f * data[48 + column];
        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g2 * data[56 + column];
        beta[1] = d * data[8 + column] - g2 * data[24 + column] - b * data[40 + column] - e * data[56 + column];
        beta[2] = e * data[8 + column] - b * data[24 + column] + g2 * data[40 + column] + d * data[56 + column];
        beta[3] = g2 * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];
        theta[0] = a * (data[column] + data[32 + column]);
        theta[3] = a * (data[column] - data[32 + column]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[0 + column] = gamma[0] + beta[0];
        data[8 + column] = gamma[1] + beta[1];
        data[16 + column] = gamma[2] + beta[2];
        data[24 + column] = gamma[3] + beta[3];
        data[32 + column] = gamma[3] - beta[3];
        data[40 + column] = gamma[2] - beta[2];
        data[48 + column] = gamma[1] - beta[1];
        data[56 + column] = gamma[0] - beta[0];
      }
    }
    function csc709Inverse(data) {
      for (let i = 0; i < 64; ++i) {
        const y = data[0][i];
        const cb = data[1][i];
        const cr = data[2][i];
        data[0][i] = y + 1.5747 * cr;
        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;
        data[2][i] = y + 1.8556 * cb;
      }
    }
    function convertToHalf(src, dst, idx) {
      for (let i = 0; i < 64; ++i) {
        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));
      }
    }
    function toLinear(float) {
      if (float <= 1) {
        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);
      } else {
        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);
      }
    }
    function uncompressRAW(info) {
      return new DataView(info.array.buffer, info.offset.value, info.size);
    }
    function uncompressRLE(info) {
      const compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
      const rawBuffer = new Uint8Array(decodeRunLength(compressed));
      const tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressZIP(info) {
      const compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      const rawBuffer = unzlibSync(compressed);
      const tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPIZ(info) {
      const inDataView = info.viewer;
      const inOffset = { value: info.offset.value };
      const outBuffer = new Uint16Array(info.columns * info.lines * (info.inputChannels.length * info.type));
      const bitmap = new Uint8Array(BITMAP_SIZE);
      let outBufferEnd = 0;
      const pizChannelData = new Array(info.inputChannels.length);
      for (let i = 0, il = info.inputChannels.length; i < il; i++) {
        pizChannelData[i] = {};
        pizChannelData[i]["start"] = outBufferEnd;
        pizChannelData[i]["end"] = pizChannelData[i]["start"];
        pizChannelData[i]["nx"] = info.columns;
        pizChannelData[i]["ny"] = info.lines;
        pizChannelData[i]["size"] = info.type;
        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
      }
      const minNonZero = parseUint16(inDataView, inOffset);
      const maxNonZero = parseUint16(inDataView, inOffset);
      if (maxNonZero >= BITMAP_SIZE) {
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      }
      if (minNonZero <= maxNonZero) {
        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {
          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);
        }
      }
      const lut = new Uint16Array(USHORT_RANGE);
      const maxValue = reverseLutFromBitmap(bitmap, lut);
      const length = parseUint32(inDataView, inOffset);
      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
      for (let i = 0; i < info.inputChannels.length; ++i) {
        const cd = pizChannelData[i];
        for (let j = 0; j < pizChannelData[i].size; ++j) {
          wav2Decode(
            outBuffer,
            cd.start + j,
            cd.nx,
            cd.size,
            cd.ny,
            cd.nx * cd.size,
            maxValue
          );
        }
      }
      applyLut(lut, outBuffer, outBufferEnd);
      let tmpOffset = 0;
      const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
      for (let y = 0; y < info.lines; y++) {
        for (let c = 0; c < info.inputChannels.length; c++) {
          const cd = pizChannelData[c];
          const n2 = cd.nx * cd.size;
          const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n2 * INT16_SIZE);
          tmpBuffer.set(cp, tmpOffset);
          tmpOffset += n2 * INT16_SIZE;
          cd.end += n2;
        }
      }
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPXR(info) {
      const compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      const rawBuffer = unzlibSync(compressed);
      const byteSize = info.inputChannels.length * info.lines * info.columns * info.totalBytes;
      const tmpBuffer = new ArrayBuffer(byteSize);
      const viewer = new DataView(tmpBuffer);
      let tmpBufferEnd = 0;
      let writePtr = 0;
      const ptr = new Array(4);
      for (let y = 0; y < info.lines; y++) {
        for (let c = 0; c < info.inputChannels.length; c++) {
          let pixel = 0;
          const type = info.inputChannels[c].pixelType;
          switch (type) {
            case 1:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.columns;
              tmpBufferEnd = ptr[1] + info.columns;
              for (let j = 0; j < info.columns; ++j) {
                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                pixel += diff;
                viewer.setUint16(writePtr, pixel, true);
                writePtr += 2;
              }
              break;
            case 2:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.columns;
              ptr[2] = ptr[1] + info.columns;
              tmpBufferEnd = ptr[2] + info.columns;
              for (let j = 0; j < info.columns; ++j) {
                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                pixel += diff;
                viewer.setUint32(writePtr, pixel, true);
                writePtr += 4;
              }
              break;
          }
        }
      }
      return viewer;
    }
    function uncompressDWA(info) {
      const inDataView = info.viewer;
      const inOffset = { value: info.offset.value };
      const outBuffer = new Uint8Array(info.columns * info.lines * (info.inputChannels.length * info.type * INT16_SIZE));
      const dwaHeader = {
        version: parseInt64(inDataView, inOffset),
        unknownUncompressedSize: parseInt64(inDataView, inOffset),
        unknownCompressedSize: parseInt64(inDataView, inOffset),
        acCompressedSize: parseInt64(inDataView, inOffset),
        dcCompressedSize: parseInt64(inDataView, inOffset),
        rleCompressedSize: parseInt64(inDataView, inOffset),
        rleUncompressedSize: parseInt64(inDataView, inOffset),
        rleRawSize: parseInt64(inDataView, inOffset),
        totalAcUncompressedCount: parseInt64(inDataView, inOffset),
        totalDcUncompressedCount: parseInt64(inDataView, inOffset),
        acCompression: parseInt64(inDataView, inOffset)
      };
      if (dwaHeader.version < 2)
        throw new Error("EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported");
      const channelRules = new Array();
      let ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
      while (ruleSize > 0) {
        const name = parseNullTerminatedString(inDataView.buffer, inOffset);
        const value = parseUint8(inDataView, inOffset);
        const compression = value >> 2 & 3;
        const csc = (value >> 4) - 1;
        const index = new Int8Array([csc])[0];
        const type = parseUint8(inDataView, inOffset);
        channelRules.push({
          name,
          index,
          type,
          compression
        });
        ruleSize -= name.length + 3;
      }
      const channels = EXRHeader.channels;
      const channelData = new Array(info.inputChannels.length);
      for (let i = 0; i < info.inputChannels.length; ++i) {
        const cd = channelData[i] = {};
        const channel = channels[i];
        cd.name = channel.name;
        cd.compression = UNKNOWN;
        cd.decoded = false;
        cd.type = channel.pixelType;
        cd.pLinear = channel.pLinear;
        cd.width = info.columns;
        cd.height = info.lines;
      }
      const cscSet = {
        idx: new Array(3)
      };
      for (let offset2 = 0; offset2 < info.inputChannels.length; ++offset2) {
        const cd = channelData[offset2];
        for (let i = 0; i < channelRules.length; ++i) {
          const rule = channelRules[i];
          if (cd.name == rule.name) {
            cd.compression = rule.compression;
            if (rule.index >= 0) {
              cscSet.idx[rule.index] = offset2;
            }
            cd.offset = offset2;
          }
        }
      }
      let acBuffer, dcBuffer, rleBuffer;
      if (dwaHeader.acCompressedSize > 0) {
        switch (dwaHeader.acCompression) {
          case STATIC_HUFFMAN:
            acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
            hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);
            break;
          case DEFLATE:
            const compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
            const data = unzlibSync(compressed);
            acBuffer = new Uint16Array(data.buffer);
            inOffset.value += dwaHeader.totalAcUncompressedCount;
            break;
        }
      }
      if (dwaHeader.dcCompressedSize > 0) {
        const zlibInfo = {
          array: info.array,
          offset: inOffset,
          size: dwaHeader.dcCompressedSize
        };
        dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
        inOffset.value += dwaHeader.dcCompressedSize;
      }
      if (dwaHeader.rleRawSize > 0) {
        const compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
        const data = unzlibSync(compressed);
        rleBuffer = decodeRunLength(data.buffer);
        inOffset.value += dwaHeader.rleCompressedSize;
      }
      let outBufferEnd = 0;
      const rowOffsets = new Array(channelData.length);
      for (let i = 0; i < rowOffsets.length; ++i) {
        rowOffsets[i] = new Array();
      }
      for (let y = 0; y < info.lines; ++y) {
        for (let chan = 0; chan < channelData.length; ++chan) {
          rowOffsets[chan].push(outBufferEnd);
          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
        }
      }
      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
      for (let i = 0; i < channelData.length; ++i) {
        const cd = channelData[i];
        if (cd.decoded) continue;
        switch (cd.compression) {
          case RLE:
            let row = 0;
            let rleOffset = 0;
            for (let y = 0; y < info.lines; ++y) {
              let rowOffsetBytes = rowOffsets[i][row];
              for (let x2 = 0; x2 < cd.width; ++x2) {
                for (let byte = 0; byte < INT16_SIZE * cd.type; ++byte) {
                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];
                }
                rleOffset++;
              }
              row++;
            }
            break;
          case LOSSY_DCT:
          // skip
          default:
            throw new Error("EXRLoader.parse: unsupported channel compression");
        }
      }
      return new DataView(outBuffer.buffer);
    }
    function parseNullTerminatedString(buffer2, offset2) {
      const uintBuffer = new Uint8Array(buffer2);
      let endOffset = 0;
      while (uintBuffer[offset2.value + endOffset] != 0) {
        endOffset += 1;
      }
      const stringValue = new TextDecoder().decode(
        uintBuffer.slice(offset2.value, offset2.value + endOffset)
      );
      offset2.value = offset2.value + endOffset + 1;
      return stringValue;
    }
    function parseFixedLengthString(buffer2, offset2, size) {
      const stringValue = new TextDecoder().decode(
        new Uint8Array(buffer2).slice(offset2.value, offset2.value + size)
      );
      offset2.value = offset2.value + size;
      return stringValue;
    }
    function parseRational(dataView, offset2) {
      const x2 = parseInt32(dataView, offset2);
      const y = parseUint32(dataView, offset2);
      return [x2, y];
    }
    function parseTimecode(dataView, offset2) {
      const x2 = parseUint32(dataView, offset2);
      const y = parseUint32(dataView, offset2);
      return [x2, y];
    }
    function parseInt32(dataView, offset2) {
      const Int32 = dataView.getInt32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Int32;
    }
    function parseUint32(dataView, offset2) {
      const Uint32 = dataView.getUint32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Uint32;
    }
    function parseUint8Array(uInt8Array2, offset2) {
      const Uint8 = uInt8Array2[offset2.value];
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    function parseUint8(dataView, offset2) {
      const Uint8 = dataView.getUint8(offset2.value);
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    const parseInt64 = function(dataView, offset2) {
      let int;
      if ("getBigInt64" in DataView.prototype) {
        int = Number(dataView.getBigInt64(offset2.value, true));
      } else {
        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
      }
      offset2.value += ULONG_SIZE;
      return int;
    };
    function parseFloat32(dataView, offset2) {
      const float = dataView.getFloat32(offset2.value, true);
      offset2.value += FLOAT32_SIZE;
      return float;
    }
    function decodeFloat32(dataView, offset2) {
      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));
    }
    function decodeFloat16(binary) {
      const exponent = (binary & 31744) >> 10, fraction = binary & 1023;
      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
    }
    function parseUint16(dataView, offset2) {
      const Uint16 = dataView.getUint16(offset2.value, true);
      offset2.value += INT16_SIZE;
      return Uint16;
    }
    function parseFloat16(buffer2, offset2) {
      return decodeFloat16(parseUint16(buffer2, offset2));
    }
    function parseChlist(dataView, buffer2, offset2, size) {
      const startOffset = offset2.value;
      const channels = [];
      while (offset2.value < startOffset + size - 1) {
        const name = parseNullTerminatedString(buffer2, offset2);
        const pixelType = parseInt32(dataView, offset2);
        const pLinear = parseUint8(dataView, offset2);
        offset2.value += 3;
        const xSampling = parseInt32(dataView, offset2);
        const ySampling = parseInt32(dataView, offset2);
        channels.push({
          name,
          pixelType,
          pLinear,
          xSampling,
          ySampling
        });
      }
      offset2.value += 1;
      return channels;
    }
    function parseChromaticities(dataView, offset2) {
      const redX = parseFloat32(dataView, offset2);
      const redY = parseFloat32(dataView, offset2);
      const greenX = parseFloat32(dataView, offset2);
      const greenY = parseFloat32(dataView, offset2);
      const blueX = parseFloat32(dataView, offset2);
      const blueY = parseFloat32(dataView, offset2);
      const whiteX = parseFloat32(dataView, offset2);
      const whiteY = parseFloat32(dataView, offset2);
      return { redX, redY, greenX, greenY, blueX, blueY, whiteX, whiteY };
    }
    function parseCompression(dataView, offset2) {
      const compressionCodes = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ];
      const compression = parseUint8(dataView, offset2);
      return compressionCodes[compression];
    }
    function parseBox2i(dataView, offset2) {
      const xMin = parseInt32(dataView, offset2);
      const yMin = parseInt32(dataView, offset2);
      const xMax = parseInt32(dataView, offset2);
      const yMax = parseInt32(dataView, offset2);
      return { xMin, yMin, xMax, yMax };
    }
    function parseLineOrder(dataView, offset2) {
      const lineOrders = [
        "INCREASING_Y",
        "DECREASING_Y",
        "RANDOM_Y"
      ];
      const lineOrder = parseUint8(dataView, offset2);
      return lineOrders[lineOrder];
    }
    function parseEnvmap(dataView, offset2) {
      const envmaps = [
        "ENVMAP_LATLONG",
        "ENVMAP_CUBE"
      ];
      const envmap = parseUint8(dataView, offset2);
      return envmaps[envmap];
    }
    function parseTiledesc(dataView, offset2) {
      const levelModes = [
        "ONE_LEVEL",
        "MIPMAP_LEVELS",
        "RIPMAP_LEVELS"
      ];
      const roundingModes = [
        "ROUND_DOWN",
        "ROUND_UP"
      ];
      const xSize = parseUint32(dataView, offset2);
      const ySize = parseUint32(dataView, offset2);
      const modes = parseUint8(dataView, offset2);
      return {
        xSize,
        ySize,
        levelMode: levelModes[modes & 15],
        roundingMode: roundingModes[modes >> 4]
      };
    }
    function parseV2f(dataView, offset2) {
      const x2 = parseFloat32(dataView, offset2);
      const y = parseFloat32(dataView, offset2);
      return [x2, y];
    }
    function parseV3f(dataView, offset2) {
      const x2 = parseFloat32(dataView, offset2);
      const y = parseFloat32(dataView, offset2);
      const z = parseFloat32(dataView, offset2);
      return [x2, y, z];
    }
    function parseValue(dataView, buffer2, offset2, type, size) {
      if (type === "string" || type === "stringvector" || type === "iccProfile") {
        return parseFixedLengthString(buffer2, offset2, size);
      } else if (type === "chlist") {
        return parseChlist(dataView, buffer2, offset2, size);
      } else if (type === "chromaticities") {
        return parseChromaticities(dataView, offset2);
      } else if (type === "compression") {
        return parseCompression(dataView, offset2);
      } else if (type === "box2i") {
        return parseBox2i(dataView, offset2);
      } else if (type === "envmap") {
        return parseEnvmap(dataView, offset2);
      } else if (type === "tiledesc") {
        return parseTiledesc(dataView, offset2);
      } else if (type === "lineOrder") {
        return parseLineOrder(dataView, offset2);
      } else if (type === "float") {
        return parseFloat32(dataView, offset2);
      } else if (type === "v2f") {
        return parseV2f(dataView, offset2);
      } else if (type === "v3f") {
        return parseV3f(dataView, offset2);
      } else if (type === "int") {
        return parseInt32(dataView, offset2);
      } else if (type === "rational") {
        return parseRational(dataView, offset2);
      } else if (type === "timecode") {
        return parseTimecode(dataView, offset2);
      } else if (type === "preview") {
        offset2.value += size;
        return "skipped";
      } else {
        offset2.value += size;
        return void 0;
      }
    }
    function roundLog2(x2, mode) {
      const log2 = Math.log2(x2);
      return mode == "ROUND_DOWN" ? Math.floor(log2) : Math.ceil(log2);
    }
    function calculateTileLevels(tiledesc, w, h) {
      let num = 0;
      switch (tiledesc.levelMode) {
        case "ONE_LEVEL":
          num = 1;
          break;
        case "MIPMAP_LEVELS":
          num = roundLog2(Math.max(w, h), tiledesc.roundingMode) + 1;
          break;
        case "RIPMAP_LEVELS":
          throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.");
      }
      return num;
    }
    function calculateTiles(count, dataSize, size, roundingMode) {
      const tiles = new Array(count);
      for (let i = 0; i < count; i++) {
        const b = 1 << i;
        let s = dataSize / b | 0;
        if (roundingMode == "ROUND_UP" && s * b < dataSize) s += 1;
        const l = Math.max(s, 1);
        tiles[i] = (l + size - 1) / size | 0;
      }
      return tiles;
    }
    function parseTiles() {
      const EXRDecoder2 = this;
      const offset2 = EXRDecoder2.offset;
      const tmpOffset = { value: 0 };
      for (let tile = 0; tile < EXRDecoder2.tileCount; tile++) {
        const tileX = parseInt32(EXRDecoder2.viewer, offset2);
        const tileY = parseInt32(EXRDecoder2.viewer, offset2);
        offset2.value += 8;
        EXRDecoder2.size = parseUint32(EXRDecoder2.viewer, offset2);
        const startX = tileX * EXRDecoder2.blockWidth;
        const startY = tileY * EXRDecoder2.blockHeight;
        EXRDecoder2.columns = startX + EXRDecoder2.blockWidth > EXRDecoder2.width ? EXRDecoder2.width - startX : EXRDecoder2.blockWidth;
        EXRDecoder2.lines = startY + EXRDecoder2.blockHeight > EXRDecoder2.height ? EXRDecoder2.height - startY : EXRDecoder2.blockHeight;
        const bytesBlockLine = EXRDecoder2.columns * EXRDecoder2.totalBytes;
        const isCompressed = EXRDecoder2.size < EXRDecoder2.lines * bytesBlockLine;
        const viewer = isCompressed ? EXRDecoder2.uncompress(EXRDecoder2) : uncompressRAW(EXRDecoder2);
        offset2.value += EXRDecoder2.size;
        for (let line = 0; line < EXRDecoder2.lines; line++) {
          const lineOffset = line * EXRDecoder2.columns * EXRDecoder2.totalBytes;
          for (let channelID = 0; channelID < EXRDecoder2.inputChannels.length; channelID++) {
            const name = EXRHeader.channels[channelID].name;
            const lOff = EXRDecoder2.channelByteOffsets[name] * EXRDecoder2.columns;
            const cOff = EXRDecoder2.decodeChannels[name];
            if (cOff === void 0) continue;
            tmpOffset.value = lineOffset + lOff;
            const outLineOffset = (EXRDecoder2.height - (1 + startY + line)) * EXRDecoder2.outLineWidth;
            for (let x2 = 0; x2 < EXRDecoder2.columns; x2++) {
              const outIndex = outLineOffset + (x2 + startX) * EXRDecoder2.outputChannels + cOff;
              EXRDecoder2.byteArray[outIndex] = EXRDecoder2.getter(viewer, tmpOffset);
            }
          }
        }
      }
    }
    function parseScanline() {
      const EXRDecoder2 = this;
      const offset2 = EXRDecoder2.offset;
      const tmpOffset = { value: 0 };
      for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder2.height / EXRDecoder2.blockHeight; scanlineBlockIdx++) {
        const line = parseInt32(EXRDecoder2.viewer, offset2) - EXRHeader.dataWindow.yMin;
        EXRDecoder2.size = parseUint32(EXRDecoder2.viewer, offset2);
        EXRDecoder2.lines = line + EXRDecoder2.blockHeight > EXRDecoder2.height ? EXRDecoder2.height - line : EXRDecoder2.blockHeight;
        const bytesPerLine = EXRDecoder2.columns * EXRDecoder2.totalBytes;
        const isCompressed = EXRDecoder2.size < EXRDecoder2.lines * bytesPerLine;
        const viewer = isCompressed ? EXRDecoder2.uncompress(EXRDecoder2) : uncompressRAW(EXRDecoder2);
        offset2.value += EXRDecoder2.size;
        for (let line_y = 0; line_y < EXRDecoder2.blockHeight; line_y++) {
          const scan_y = scanlineBlockIdx * EXRDecoder2.blockHeight;
          const true_y = line_y + EXRDecoder2.scanOrder(scan_y);
          if (true_y >= EXRDecoder2.height) continue;
          const lineOffset = line_y * bytesPerLine;
          const outLineOffset = (EXRDecoder2.height - 1 - true_y) * EXRDecoder2.outLineWidth;
          for (let channelID = 0; channelID < EXRDecoder2.inputChannels.length; channelID++) {
            const name = EXRHeader.channels[channelID].name;
            const lOff = EXRDecoder2.channelByteOffsets[name] * EXRDecoder2.columns;
            const cOff = EXRDecoder2.decodeChannels[name];
            if (cOff === void 0) continue;
            tmpOffset.value = lineOffset + lOff;
            for (let x2 = 0; x2 < EXRDecoder2.columns; x2++) {
              const outIndex = outLineOffset + x2 * EXRDecoder2.outputChannels + cOff;
              EXRDecoder2.byteArray[outIndex] = EXRDecoder2.getter(viewer, tmpOffset);
            }
          }
        }
      }
    }
    function parseHeader(dataView, buffer2, offset2) {
      const EXRHeader2 = {};
      if (dataView.getUint32(0, true) != 20000630) {
        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
      }
      EXRHeader2.version = dataView.getUint8(4);
      const spec = dataView.getUint8(5);
      EXRHeader2.spec = {
        singleTile: !!(spec & 2),
        longName: !!(spec & 4),
        deepFormat: !!(spec & 8),
        multiPart: !!(spec & 16)
      };
      offset2.value = 8;
      let keepReading = true;
      while (keepReading) {
        const attributeName = parseNullTerminatedString(buffer2, offset2);
        if (attributeName == 0) {
          keepReading = false;
        } else {
          const attributeType = parseNullTerminatedString(buffer2, offset2);
          const attributeSize = parseUint32(dataView, offset2);
          const attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);
          if (attributeValue === void 0) {
            console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${attributeType}'.`);
          } else {
            EXRHeader2[attributeName] = attributeValue;
          }
        }
      }
      if ((spec & -7) != 0) {
        console.error("THREE.EXRHeader:", EXRHeader2);
        throw new Error("THREE.EXRLoader: Provided file is currently unsupported.");
      }
      return EXRHeader2;
    }
    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
      const EXRDecoder2 = {
        size: 0,
        viewer: dataView,
        array: uInt8Array2,
        offset: offset2,
        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
        inputChannels: EXRHeader2.channels,
        channelByteOffsets: {},
        scanOrder: null,
        totalBytes: null,
        columns: null,
        lines: null,
        type: null,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: LinearSRGBColorSpace
      };
      switch (EXRHeader2.compression) {
        case "NO_COMPRESSION":
          EXRDecoder2.blockHeight = 1;
          EXRDecoder2.uncompress = uncompressRAW;
          break;
        case "RLE_COMPRESSION":
          EXRDecoder2.blockHeight = 1;
          EXRDecoder2.uncompress = uncompressRLE;
          break;
        case "ZIPS_COMPRESSION":
          EXRDecoder2.blockHeight = 1;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "ZIP_COMPRESSION":
          EXRDecoder2.blockHeight = 16;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "PIZ_COMPRESSION":
          EXRDecoder2.blockHeight = 32;
          EXRDecoder2.uncompress = uncompressPIZ;
          break;
        case "PXR24_COMPRESSION":
          EXRDecoder2.blockHeight = 16;
          EXRDecoder2.uncompress = uncompressPXR;
          break;
        case "DWAA_COMPRESSION":
          EXRDecoder2.blockHeight = 32;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        case "DWAB_COMPRESSION":
          EXRDecoder2.blockHeight = 256;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        default:
          throw new Error("EXRLoader.parse: " + EXRHeader2.compression + " is unsupported");
      }
      const channels = {};
      for (const channel of EXRHeader2.channels) {
        switch (channel.name) {
          case "Y":
          case "R":
          case "G":
          case "B":
          case "A":
            channels[channel.name] = true;
            EXRDecoder2.type = channel.pixelType;
        }
      }
      let fillAlpha = false;
      if (channels.R && channels.G && channels.B) {
        fillAlpha = !channels.A;
        EXRDecoder2.outputChannels = 4;
        EXRDecoder2.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
      } else if (channels.Y) {
        EXRDecoder2.outputChannels = 1;
        EXRDecoder2.decodeChannels = { Y: 0 };
      } else {
        throw new Error("EXRLoader.parse: file contains unsupported data channels.");
      }
      if (EXRDecoder2.type == 1) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat16;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = parseUint16;
            break;
        }
      } else if (EXRDecoder2.type == 2) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat32;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = decodeFloat32;
        }
      } else {
        throw new Error("EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".");
      }
      EXRDecoder2.columns = EXRDecoder2.width;
      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
      switch (outputType) {
        case FloatType:
          EXRDecoder2.byteArray = new Float32Array(size);
          if (fillAlpha)
            EXRDecoder2.byteArray.fill(1, 0, size);
          break;
        case HalfFloatType:
          EXRDecoder2.byteArray = new Uint16Array(size);
          if (fillAlpha)
            EXRDecoder2.byteArray.fill(15360, 0, size);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", outputType);
          break;
      }
      let byteOffset = 0;
      for (const channel of EXRHeader2.channels) {
        if (EXRDecoder2.decodeChannels[channel.name] !== void 0) {
          EXRDecoder2.channelByteOffsets[channel.name] = byteOffset;
        }
        byteOffset += channel.pixelType * 2;
      }
      EXRDecoder2.totalBytes = byteOffset;
      EXRDecoder2.outLineWidth = EXRDecoder2.width * EXRDecoder2.outputChannels;
      if (EXRHeader2.lineOrder === "INCREASING_Y") {
        EXRDecoder2.scanOrder = (y) => y;
      } else {
        EXRDecoder2.scanOrder = (y) => EXRDecoder2.height - 1 - y;
      }
      if (EXRDecoder2.outputChannels == 4) {
        EXRDecoder2.format = RGBAFormat;
        EXRDecoder2.colorSpace = LinearSRGBColorSpace;
      } else {
        EXRDecoder2.format = RedFormat;
        EXRDecoder2.colorSpace = NoColorSpace;
      }
      if (EXRHeader2.spec.singleTile) {
        EXRDecoder2.blockHeight = EXRHeader2.tiles.ySize;
        EXRDecoder2.blockWidth = EXRHeader2.tiles.xSize;
        const numXLevels = calculateTileLevels(EXRHeader2.tiles, EXRDecoder2.width, EXRDecoder2.height);
        const numXTiles = calculateTiles(numXLevels, EXRDecoder2.width, EXRHeader2.tiles.xSize, EXRHeader2.tiles.roundingMode);
        const numYTiles = calculateTiles(numXLevels, EXRDecoder2.height, EXRHeader2.tiles.ySize, EXRHeader2.tiles.roundingMode);
        EXRDecoder2.tileCount = numXTiles[0] * numYTiles[0];
        for (let l = 0; l < numXLevels; l++)
          for (let y = 0; y < numYTiles[l]; y++)
            for (let x2 = 0; x2 < numXTiles[l]; x2++)
              parseInt64(dataView, offset2);
        EXRDecoder2.decode = parseTiles.bind(EXRDecoder2);
      } else {
        EXRDecoder2.blockWidth = EXRDecoder2.width;
        const blockCount = Math.ceil(EXRDecoder2.height / EXRDecoder2.blockHeight);
        for (let i = 0; i < blockCount; i++)
          parseInt64(dataView, offset2);
        EXRDecoder2.decode = parseScanline.bind(EXRDecoder2);
      }
      return EXRDecoder2;
    }
    const offset = { value: 0 };
    const bufferDataView = new DataView(buffer);
    const uInt8Array = new Uint8Array(buffer);
    const EXRHeader = parseHeader(bufferDataView, buffer, offset);
    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
    EXRDecoder.decode();
    return {
      header: EXRHeader,
      width: EXRDecoder.width,
      height: EXRDecoder.height,
      data: EXRDecoder.byteArray,
      format: EXRDecoder.format,
      colorSpace: EXRDecoder.colorSpace,
      type: this.type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url2, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      texture.colorSpace = texData.colorSpace;
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.flipY = false;
      if (onLoad) onLoad(texture, texData);
    }
    return super.load(url2, onLoadCallback, onProgress, onError);
  }
};
var WorkerPool = class {
  constructor(pool2 = 4) {
    this.pool = pool2;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker2 = this.workerCreator();
      worker2.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker2;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i)) return i;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool2) {
    this.pool = pool2;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker2) => worker2.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};
var t = 0;
var n = 2;
var p = 1;
var x = 2;
var E = 0;
var F = 1;
var X = 10;
var nt = 0;
var ct = 9;
var gt = 15;
var yt = 16;
var dt = 22;
var Ot = 37;
var Ft = 43;
var $t = 76;
var se = 83;
var pe = 97;
var xe = 100;
var de = 103;
var Ae = 109;
var Sn = 165;
var In = 166;
var _i = 1000066e3;
var Si = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var Ii = class {
  constructor(t2, e, n2, i) {
    this._dataView = new DataView(t2.buffer, t2.byteOffset + e, n2), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _nextInt32() {
    const t2 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e = 0) {
    const n2 = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== e && i < t2; ) i++, this._offset++;
    return i < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i);
  }
};
var Ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ei(t2) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
}
function Pi(t2) {
  const e = new Uint8Array(t2.buffer, t2.byteOffset, Ti.length);
  if (e[0] !== Ti[0] || e[1] !== Ti[1] || e[2] !== Ti[2] || e[3] !== Ti[3] || e[4] !== Ti[4] || e[5] !== Ti[5] || e[6] !== Ti[6] || e[7] !== Ti[7] || e[8] !== Ti[8] || e[9] !== Ti[9] || e[10] !== Ti[10] || e[11] !== Ti[11]) throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Si(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Ii(t2, Ti.length, i, true);
  n2.vkFormat = s._nextUint32(), n2.typeSize = s._nextUint32(), n2.pixelWidth = s._nextUint32(), n2.pixelHeight = s._nextUint32(), n2.pixelDepth = s._nextUint32(), n2.layerCount = s._nextUint32(), n2.faceCount = s._nextUint32();
  const a = s._nextUint32();
  n2.supercompressionScheme = s._nextUint32();
  const r = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f = s._nextUint32(), U = s._nextUint64(), c = s._nextUint64(), h = new Ii(t2, Ti.length + i, 3 * a * 8, true);
  for (let e2 = 0; e2 < a; e2++) n2.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + h._nextUint64(), h._nextUint64()), uncompressedByteLength: h._nextUint64() });
  const _ = new Ii(t2, r, o, true), p2 = { vendorId: _._skip(4)._nextUint16(), descriptorType: _._nextUint16(), versionNumber: _._nextUint16(), descriptorBlockSize: _._nextUint16(), colorModel: _._nextUint8(), colorPrimaries: _._nextUint8(), transferFunction: _._nextUint8(), flags: _._nextUint8(), texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], samples: [] }, g2 = (p2.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g2; t3++) {
    const e2 = { bitOffset: _._nextUint16(), bitLength: _._nextUint8(), channelType: _._nextUint8(), samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e2.channelType ? (e2.sampleLower = _._nextInt32(), e2.sampleUpper = _._nextInt32()) : (e2.sampleLower = _._nextUint32(), e2.sampleUpper = _._nextUint32()), p2.samples[t3] = e2;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p2);
  const y = new Ii(t2, l, f, true);
  for (; y._offset < f; ) {
    const t3 = y._nextUint32(), e2 = y._scan(t3), i2 = Ei(e2), s2 = y._scan(t3 - e2.byteLength);
    n2.keyValue[i2] = i2.match(/^ktx/i) ? Ei(s2) : s2, y._offset % 4 && y._skip(4 - y._offset % 4);
  }
  if (c <= 0) return n2;
  const x2 = new Ii(t2, U, c, true), u = x2._nextUint16(), b = x2._nextUint16(), d = x2._nextUint32(), m2 = x2._nextUint32(), w = x2._nextUint32(), D = x2._nextUint32(), B2 = [];
  for (let t3 = 0; t3 < a; t3++) B2.push({ imageFlags: x2._nextUint32(), rgbSliceByteOffset: x2._nextUint32(), rgbSliceByteLength: x2._nextUint32(), alphaSliceByteOffset: x2._nextUint32(), alphaSliceByteLength: x2._nextUint32() });
  const L = U + x2._offset, A2 = L + d, k = A2 + m2, v = k + w, S = new Uint8Array(t2.buffer, t2.byteOffset + L, d), I2 = new Uint8Array(t2.buffer, t2.byteOffset + A2, m2), O = new Uint8Array(t2.buffer, t2.byteOffset + k, w), T = new Uint8Array(t2.buffer, t2.byteOffset + v, D);
  return n2.globalData = { endpointCount: u, selectorCount: b, imageDescs: B2, endpointsData: S, selectorsData: I2, tablesData: O, extendedData: T }, n2;
}
var A;
var I;
var B;
var g = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g2 = 0) {
    if (!I) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
    B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
    const E2 = I.exports.malloc(g2), i = I.exports.ZSTD_decompress(E2, g2, C2, Q2), D = B.slice(E2, E2 + i);
    return I.exports.free(C2), I.exports.free(E2), D;
  }
};
var C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
var DisplayP3ColorSpace = "display-p3";
var LinearDisplayP3ColorSpace = "display-p3-linear";
var _taskCache = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class _KTX2Loader extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  async detectSupportAsync(renderer2) {
    this.workerConfig = {
      astcSupported: await renderer2.hasFeatureAsync("texture-compression-astc"),
      astcHDRSupported: false,
      // https://github.com/gpuweb/gpuweb/issues/3856
      etc1Supported: await renderer2.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await renderer2.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await renderer2.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await renderer2.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await renderer2.hasFeatureAsync("texture-compression-pvrtc")
    };
    return this;
  }
  detectSupport(renderer2) {
    if (renderer2.isWebGPURenderer === true) {
      this.workerConfig = {
        astcSupported: renderer2.hasFeature("texture-compression-astc"),
        astcHDRSupported: false,
        // https://github.com/gpuweb/gpuweb/issues/3856
        etc1Supported: renderer2.hasFeature("texture-compression-etc1"),
        etc2Supported: renderer2.hasFeature("texture-compression-etc2"),
        dxtSupported: renderer2.hasFeature("texture-compression-bc"),
        bptcSupported: renderer2.hasFeature("texture-compression-bptc"),
        pvrtcSupported: renderer2.hasFeature("texture-compression-pvrtc")
      };
    } else {
      this.workerConfig = {
        astcSupported: renderer2.extensions.has("WEBGL_compressed_texture_astc"),
        astcHDRSupported: renderer2.extensions.has("WEBGL_compressed_texture_astc") && renderer2.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
        etc1Supported: renderer2.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: renderer2.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: renderer2.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: renderer2.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: renderer2.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer2.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      };
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = _KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(_KTX2Loader.EngineFormat),
          "let _EngineType = " + JSON.stringify(_KTX2Loader.EngineType),
          "let _TranscoderFormat = " + JSON.stringify(_KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(_KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker2 = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker2.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker2;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url2, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url2, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      return cachedTask.promise.then(onLoad).catch(onError);
    }
    this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
  }
  _createTextureFrom(transcodeResult, container) {
    const { type: messageType, error, data: { faces, width, height, format, type, dfdFlags } } = transcodeResult;
    if (messageType === "error") return Promise.reject(error);
    let texture;
    if (container.faceCount === 6) {
      texture = new CompressedCubeTexture(faces, format, type);
    } else {
      const mipmaps = faces[0].mipmaps;
      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, type) : new CompressedTexture(mipmaps, width, height, format, type);
    }
    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = parseColorSpace(container);
    texture.premultiplyAlpha = !!(dfdFlags & p);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {?Object} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer, config = {}) {
    const container = Pi(new Uint8Array(buffer));
    const isBasisHDR = container.vkFormat === _i && container.dataFormatDescriptor[0].colorModel === 167;
    const needsTranscoder = container.vkFormat === nt || isBasisHDR && !this.workerConfig.astcHDRSupported;
    if (!needsTranscoder) {
      return createRawTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache.set(buffer, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC: 1,
  UASTC_HDR: 2
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
  BC6H: 22,
  RGB_HALF: 24,
  RGBA_HALF: 25
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format
};
KTX2Loader.EngineType = {
  UnsignedByteType,
  HalfFloatType,
  FloatType
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const EngineType = _EngineType;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { faces, buffers, width, height, hasAlpha, format, type, dfdFlags } = transcode(message.buffer);
            self.postMessage({ type: "transcode", id: message.id, data: { faces, width, height, hasAlpha, format, type, dfdFlags } }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    let basisFormat;
    if (ktx2File.isUASTC()) {
      basisFormat = BasisFormat.UASTC;
    } else if (ktx2File.isETC1S()) {
      basisFormat = BasisFormat.ETC1S;
    } else if (ktx2File.isHDR()) {
      basisFormat = BasisFormat.UASTC_HDR;
    } else {
      throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
    }
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layerCount = ktx2File.getLayers() || 1;
    const levelCount = ktx2File.getLevels();
    const faceCount = ktx2File.getFaces();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat, engineType } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levelCount) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const faces = [];
    const buffers = [];
    for (let face = 0; face < faceCount; face++) {
      const mipmaps = [];
      for (let mip = 0; mip < levelCount; mip++) {
        const layerMips = [];
        let mipWidth, mipHeight;
        for (let layer = 0; layer < layerCount; layer++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
          }
          if (levelCount > 1) {
            mipWidth = levelInfo.origWidth;
            mipHeight = levelInfo.origHeight;
          } else {
            mipWidth = levelInfo.width;
            mipHeight = levelInfo.height;
          }
          let dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
          if (engineType === EngineType.HalfFloatType) {
            dst = new Uint16Array(dst.buffer, dst.byteOffset, dst.byteLength / Uint16Array.BYTES_PER_ELEMENT);
          }
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          layerMips.push(dst);
        }
        const mipData = concat(layerMips);
        mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });
        buffers.push(mipData.buffer);
      }
      faces.push({ mipmaps, width, height, format: engineFormat, type: engineType });
    }
    cleanup();
    return { faces, buffers, width, height, hasAlpha, dfdFlags, format: engineFormat, type: engineType };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      engineType: [EngineType.UnsignedByteType],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.UASTC_HDR],
      transcoderFormat: [TranscoderFormat.BC6H],
      engineFormat: [EngineFormat.RGB_BPTC_UNSIGNED_Format],
      engineType: [EngineType.HalfFloatType],
      priorityHDR: 1,
      needsPowerOfTwo: false
    },
    // Uncompressed fallbacks.
    {
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC],
      transcoderFormat: [TranscoderFormat.RGBA32, TranscoderFormat.RGBA32],
      engineFormat: [EngineFormat.RGBAFormat, EngineFormat.RGBAFormat],
      engineType: [EngineType.UnsignedByteType, EngineType.UnsignedByteType],
      priorityETC1S: 100,
      priorityUASTC: 100,
      needsPowerOfTwo: false
    },
    {
      basisFormat: [BasisFormat.UASTC_HDR],
      transcoderFormat: [TranscoderFormat.RGBA_HALF],
      engineFormat: [EngineFormat.RGBAFormat],
      engineType: [EngineType.HalfFloatType],
      priorityHDR: 100,
      needsPowerOfTwo: false
    }
  ];
  const OPTIONS = {
    // TODO: For ETC1S we intentionally sort by _UASTC_ priority, preserving
    // a historical accident shown to avoid performance pitfalls for Linux with
    // Firefox & AMD GPU (RadeonSI). Further work needed.
    // See https://github.com/mrdoob/three.js/pull/29730.
    [BasisFormat.ETC1S]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.ETC1S)).sort((a, b) => a.priorityUASTC - b.priorityUASTC),
    [BasisFormat.UASTC]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.UASTC)).sort((a, b) => a.priorityUASTC - b.priorityUASTC),
    [BasisFormat.UASTC_HDR]: FORMAT_OPTIONS.filter((opt) => opt.basisFormat.includes(BasisFormat.UASTC_HDR)).sort((a, b) => a.priorityHDR - b.priorityHDR)
  };
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    const options = OPTIONS[basisFormat];
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (opt.if && !config[opt.if]) continue;
      if (!opt.basisFormat.includes(basisFormat)) continue;
      if (hasAlpha && opt.transcoderFormat.length < 2) continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;
      const transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      const engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      const engineType = opt.engineType[0];
      return { transcoderFormat, engineFormat, engineType };
    }
    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
  }
  function isPowerOfTwo(value) {
    if (value <= 2) return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    if (arrays.length === 1) return arrays[0];
    let totalByteLength = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
};
var UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([RGBAFormat, RGFormat, RedFormat]);
var FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [pe]: RGBAFormat,
  [Ot]: RGBAFormat,
  [Ft]: RGBAFormat,
  [de]: RGFormat,
  [se]: RGFormat,
  [yt]: RGFormat,
  [dt]: RGFormat,
  [xe]: RedFormat,
  [$t]: RedFormat,
  [gt]: RedFormat,
  [ct]: RedFormat,
  [_i]: RGBA_ASTC_4x4_Format,
  [In]: RGBA_ASTC_6x6_Format,
  [Sn]: RGBA_ASTC_6x6_Format
};
var TYPE_MAP = {
  [Ae]: FloatType,
  [pe]: HalfFloatType,
  [Ot]: UnsignedByteType,
  [Ft]: UnsignedByteType,
  [de]: FloatType,
  [se]: HalfFloatType,
  [yt]: UnsignedByteType,
  [dt]: UnsignedByteType,
  [xe]: FloatType,
  [$t]: HalfFloatType,
  [gt]: UnsignedByteType,
  [ct]: UnsignedByteType,
  [_i]: HalfFloatType,
  [In]: UnsignedByteType,
  [Sn]: UnsignedByteType
};
async function createRawTexture(container) {
  const { vkFormat } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  let zstd;
  if (container.supercompressionScheme === n) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd2 = new Q();
        await zstd2.init();
        resolve(zstd2);
      });
    }
    zstd = await _zstd;
  }
  const mipmaps = [];
  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);
    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);
    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;
    const level = container.levels[levelIndex];
    let levelData;
    if (container.supercompressionScheme === t) {
      levelData = level.levelData;
    } else if (container.supercompressionScheme === n) {
      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
    } else {
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    }
    let data;
    if (TYPE_MAP[vkFormat] === FloatType) {
      data = new Float32Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
      );
    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
      data = new Uint16Array(
        levelData.buffer,
        levelData.byteOffset,
        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT
      );
    } else {
      data = levelData;
    }
    mipmaps.push({
      data,
      width: levelWidth,
      height: levelHeight,
      depth: levelDepth
    });
  }
  let texture;
  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {
    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
  } else {
    if (container.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);
    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
  }
  texture.mipmaps = mipmaps;
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.colorSpace = parseColorSpace(container);
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}
function parseColorSpace(container) {
  const dfd = container.dataFormatDescriptor[0];
  if (dfd.colorPrimaries === F) {
    return dfd.transferFunction === x ? SRGBColorSpace : LinearSRGBColorSpace;
  } else if (dfd.colorPrimaries === X) {
    return dfd.transferFunction === x ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;
  } else if (dfd.colorPrimaries === E) {
    return NoColorSpace;
  } else {
    console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`);
    return NoColorSpace;
  }
}
var lzma = /* @__PURE__ */ function() {
  var pp, n0 = 18446744073709552e3, n1 = 4294967295, n2 = 2147483647, n3 = 2147483648;
  function r(e, r2) {
    pp({ action: nr, cbn: r2, result: e });
  }
  function o(e) {
    var r2 = [];
    return r2[e - 1] = void 0, r2;
  }
  function n4(e, r2) {
    return i(e[0] + r2[0], e[1] + r2[1]);
  }
  function t2(e, r2) {
    var o2, n5;
    return e[0] == r2[0] && e[1] == r2[1] ? 0 : (o2 = 0 > e[1], n5 = 0 > r2[1], o2 && !n5 ? -1 : !o2 && n5 ? 1 : d(e, r2)[1] < 0 ? -1 : 1);
  }
  function i(e, r2) {
    var o2, n5;
    for (r2 %= n0, e %= n0, o2 = r2 % ir, n5 = Math.floor(e / ir) * ir, r2 = r2 - o2 + n5, e = e - n5 + o2; 0 > e; ) e += ir, r2 -= ir;
    for (; e > n1; ) e -= ir, r2 += ir;
    for (r2 %= n0; r2 > 9223372032559809e3; ) r2 -= n0;
    for (; -18446744073709552e3 > r2; ) r2 += n0;
    return [e, r2];
  }
  function u(e) {
    return e >= 0 ? [e, 0] : [e + ir, -4294967296];
  }
  function s(e) {
    return e[0] >= n3 ? ~~Math.max(Math.min(e[0] - ir, n2), -2147483648) : ~~Math.max(Math.min(e[0], n2), -2147483648);
  }
  function d(e, r2) {
    return i(e[0] - r2[0], e[1] - r2[1]);
  }
  function c(e, r2) {
    return e.ab = r2, e.cb = 0, e.O = r2.length, e;
  }
  function m2(e) {
    return e.cb >= e.O ? -1 : 255 & e.ab[e.cb++];
  }
  function a(e) {
    return e.ab = o(32), e.O = 0, e;
  }
  function _(e) {
    var r2 = e.ab;
    return r2.length = e.O, r2;
  }
  function f(e, r2, o2, n5) {
    p2(r2, o2, e.ab, e.O, n5), e.O += n5;
  }
  function p2(e, r2, o2, n5, t3) {
    for (var i2 = 0; t3 > i2; ++i2) o2[n5 + i2] = e[r2 + i2];
  }
  function D(e, r2, o2) {
    var n5, t3, i2, s2, d2 = "", c2 = [];
    for (t3 = 0; 5 > t3; ++t3) {
      if (i2 = m2(r2), -1 == i2) throw Error("truncated input");
      c2[t3] = i2 << 24 >> 24;
    }
    if (n5 = N({}), !z(n5, c2)) throw Error("corrupted input");
    for (t3 = 0; 64 > t3; t3 += 8) {
      if (i2 = m2(r2), -1 == i2) throw Error("truncated input");
      i2 = i2.toString(16), 1 == i2.length && (i2 = "0" + i2), d2 = i2 + "" + d2;
    }
    /^0+$|^f+$/i.test(d2) ? e.N = ur : (s2 = parseInt(d2, 16), e.N = s2 > n1 ? ur : u(s2)), e.Q = B2(n5, r2, o2, e.N);
  }
  function l(e, r2) {
    return e.S = a({}), D(e, c({}, r2), e.S), e;
  }
  function g2(e, r2, o2) {
    var n5 = e.D - r2 - 1;
    for (0 > n5 && (n5 += e.c); 0 != o2; --o2) n5 >= e.c && (n5 = 0), e.x[e.D++] = e.x[n5++], e.D >= e.c && w(e);
  }
  function v(e, r2) {
    (null == e.x || e.c != r2) && (e.x = o(r2)), e.c = r2, e.D = 0, e.w = 0;
  }
  function w(e) {
    var r2 = e.D - e.w;
    r2 && (f(e.V, e.x, e.w, r2), e.D >= e.c && (e.D = 0), e.w = e.D);
  }
  function R(e, r2) {
    var o2 = e.D - r2 - 1;
    return 0 > o2 && (o2 += e.c), e.x[o2];
  }
  function h(e, r2) {
    e.x[e.D++] = r2, e.D >= e.c && w(e);
  }
  function P(e) {
    w(e), e.V = null;
  }
  function C2(e) {
    return e -= 2, 4 > e ? e : 3;
  }
  function S(e) {
    return 4 > e ? 0 : 10 > e ? e - 3 : e - 6;
  }
  function M2(e, r2) {
    return e.h = r2, e.bb = null, e.X = 1, e;
  }
  function L(e) {
    if (!e.X) throw Error("bad state");
    if (e.bb) throw Error("No encoding");
    return y(e), e.X;
  }
  function y(e) {
    var r2 = I2(e.h);
    if (-1 == r2) throw Error("corrupted input");
    e.$ = ur, e.Z = e.h.d, (r2 || t2(e.h.U, sr) >= 0 && t2(e.h.d, e.h.U) >= 0) && (w(e.h.b), P(e.h.b), e.h.a.K = null, e.X = 0);
  }
  function B2(e, r2, o2, n5) {
    return e.a.K = r2, P(e.b), e.b.V = o2, b(e), e.f = 0, e.l = 0, e.T = 0, e.R = 0, e._ = 0, e.U = n5, e.d = sr, e.I = 0, M2({}, e);
  }
  function I2(e) {
    var r2, o2, i2, d2, c2, m3;
    if (m3 = s(e.d) & e.P, Q2(e.a, e.q, (e.f << 4) + m3)) {
      if (Q2(e.a, e.E, e.f)) i2 = 0, Q2(e.a, e.s, e.f) ? (Q2(e.a, e.u, e.f) ? (Q2(e.a, e.r, e.f) ? (o2 = e._, e._ = e.R) : o2 = e.R, e.R = e.T) : o2 = e.T, e.T = e.l, e.l = o2) : Q2(e.a, e.n, (e.f << 4) + m3) || (e.f = 7 > e.f ? 9 : 11, i2 = 1), i2 || (i2 = x2(e.o, e.a, m3) + 2, e.f = 7 > e.f ? 8 : 11);
      else if (e._ = e.R, e.R = e.T, e.T = e.l, i2 = 2 + x2(e.C, e.a, m3), e.f = 7 > e.f ? 7 : 10, c2 = q(e.j[C2(i2)], e.a), c2 >= 4) {
        if (d2 = (c2 >> 1) - 1, e.l = (2 | 1 & c2) << d2, 14 > c2) e.l += J(e.J, e.l - c2 - 1, e.a, d2);
        else if (e.l += U(e.a, d2 - 4) << 4, e.l += F2(e.t, e.a), 0 > e.l) return -1 == e.l ? 1 : -1;
      } else e.l = c2;
      if (t2(u(e.l), e.d) >= 0 || e.l >= e.m) return -1;
      g2(e.b, e.l, i2), e.d = n4(e.d, u(i2)), e.I = R(e.b, 0);
    } else r2 = Z(e.k, s(e.d), e.I), e.I = 7 > e.f ? T(r2, e.a) : $(r2, e.a, R(e.b, e.l)), h(e.b, e.I), e.f = S(e.f), e.d = n4(e.d, dr);
    return 0;
  }
  function N(e) {
    e.b = {}, e.a = {}, e.q = o(192), e.E = o(12), e.s = o(12), e.u = o(12), e.r = o(12), e.n = o(192), e.j = o(4), e.J = o(114), e.t = K2({}, 4), e.C = G({}), e.o = G({}), e.k = {};
    for (var r2 = 0; 4 > r2; ++r2) e.j[r2] = K2({}, 6);
    return e;
  }
  function b(e) {
    e.b.w = 0, e.b.D = 0, X2(e.q), X2(e.n), X2(e.E), X2(e.s), X2(e.u), X2(e.r), X2(e.J), H(e.k);
    for (var r2 = 0; 4 > r2; ++r2) X2(e.j[r2].B);
    A2(e.C), A2(e.o), X2(e.t.B), V2(e.a);
  }
  function z(e, r2) {
    var o2, n5, t3, i2, u2, s2, d2;
    if (5 > r2.length) return 0;
    for (d2 = 255 & r2[0], t3 = d2 % 9, s2 = ~~(d2 / 9), i2 = s2 % 5, u2 = ~~(s2 / 5), o2 = 0, n5 = 0; 4 > n5; ++n5) o2 += (255 & r2[1 + n5]) << 8 * n5;
    return o2 > 99999999 || !W(e, t3, i2, u2) ? 0 : O(e, o2);
  }
  function O(e, r2) {
    return 0 > r2 ? 0 : (e.z != r2 && (e.z = r2, e.m = Math.max(e.z, 1), v(e.b, Math.max(e.m, 4096))), 1);
  }
  function W(e, r2, o2, n5) {
    if (r2 > 8 || o2 > 4 || n5 > 4) return 0;
    E2(e.k, o2, r2);
    var t3 = 1 << n5;
    return k(e.C, t3), k(e.o, t3), e.P = t3 - 1, 1;
  }
  function k(e, r2) {
    for (; r2 > e.e; ++e.e) e.G[e.e] = K2({}, 3), e.H[e.e] = K2({}, 3);
  }
  function x2(e, r2, o2) {
    if (!Q2(r2, e.M, 0)) return q(e.G[o2], r2);
    var n5 = 8;
    return n5 += Q2(r2, e.M, 1) ? 8 + q(e.L, r2) : q(e.H[o2], r2);
  }
  function G(e) {
    return e.M = o(2), e.G = o(16), e.H = o(16), e.L = K2({}, 8), e.e = 0, e;
  }
  function A2(e) {
    X2(e.M);
    for (var r2 = 0; e.e > r2; ++r2) X2(e.G[r2].B), X2(e.H[r2].B);
    X2(e.L.B);
  }
  function E2(e, r2, n5) {
    var t3, i2;
    if (null == e.F || e.g != n5 || e.y != r2) for (e.y = r2, e.Y = (1 << r2) - 1, e.g = n5, i2 = 1 << e.g + e.y, e.F = o(i2), t3 = 0; i2 > t3; ++t3) e.F[t3] = j({});
  }
  function Z(e, r2, o2) {
    return e.F[((r2 & e.Y) << e.g) + ((255 & o2) >>> 8 - e.g)];
  }
  function H(e) {
    var r2, o2;
    for (o2 = 1 << e.g + e.y, r2 = 0; o2 > r2; ++r2) X2(e.F[r2].v);
  }
  function T(e, r2) {
    var o2 = 1;
    do
      o2 = o2 << 1 | Q2(r2, e.v, o2);
    while (256 > o2);
    return o2 << 24 >> 24;
  }
  function $(e, r2, o2) {
    var n5, t3, i2 = 1;
    do
      if (t3 = o2 >> 7 & 1, o2 <<= 1, n5 = Q2(r2, e.v, (1 + t3 << 8) + i2), i2 = i2 << 1 | n5, t3 != n5) {
        for (; 256 > i2; ) i2 = i2 << 1 | Q2(r2, e.v, i2);
        break;
      }
    while (256 > i2);
    return i2 << 24 >> 24;
  }
  function j(e) {
    return e.v = o(768), e;
  }
  function K2(e, r2) {
    return e.A = r2, e.B = o(1 << r2), e;
  }
  function q(e, r2) {
    var o2, n5 = 1;
    for (o2 = e.A; 0 != o2; --o2) n5 = (n5 << 1) + Q2(r2, e.B, n5);
    return n5 - (1 << e.A);
  }
  function F2(e, r2) {
    var o2, n5, t3 = 1, i2 = 0;
    for (n5 = 0; e.A > n5; ++n5) o2 = Q2(r2, e.B, t3), t3 <<= 1, t3 += o2, i2 |= o2 << n5;
    return i2;
  }
  function J(e, r2, o2, n5) {
    var t3, i2, u2 = 1, s2 = 0;
    for (i2 = 0; n5 > i2; ++i2) t3 = Q2(o2, e, r2 + u2), u2 <<= 1, u2 += t3, s2 |= t3 << i2;
    return s2;
  }
  function Q2(e, r2, o2) {
    var n5, t3 = r2[o2];
    return n5 = (e.i >>> 11) * t3, (-2147483648 ^ n5) > (-2147483648 ^ e.p) ? (e.i = n5, r2[o2] = t3 + (2048 - t3 >>> 5) << 16 >> 16, -16777216 & e.i || (e.p = e.p << 8 | m2(e.K), e.i <<= 8), 0) : (e.i -= n5, e.p -= n5, r2[o2] = t3 - (t3 >>> 5) << 16 >> 16, -16777216 & e.i || (e.p = e.p << 8 | m2(e.K), e.i <<= 8), 1);
  }
  function U(e, r2) {
    var o2, n5, t3 = 0;
    for (o2 = r2; 0 != o2; --o2) e.i >>>= 1, n5 = e.p - e.i >>> 31, e.p -= e.i & n5 - 1, t3 = t3 << 1 | 1 - n5, -16777216 & e.i || (e.p = e.p << 8 | m2(e.K), e.i <<= 8);
    return t3;
  }
  function V2(e) {
    e.p = 0, e.i = -1;
    for (var r2 = 0; 5 > r2; ++r2) e.p = e.p << 8 | m2(e.K);
  }
  function X2(e) {
    for (var r2 = e.length - 1; r2 >= 0; --r2) e[r2] = 1024;
  }
  function Y(e) {
    for (var r2, o2, n5, t3 = 0, i2 = 0, u2 = e.length, s2 = [], d2 = []; u2 > t3; ++t3, ++i2) {
      if (r2 = 255 & e[t3], 128 & r2) if (192 == (224 & r2)) {
        if (t3 + 1 >= u2) return e;
        if (o2 = 255 & e[++t3], 128 != (192 & o2)) return e;
        d2[i2] = (31 & r2) << 6 | 63 & o2;
      } else {
        if (224 != (240 & r2)) return e;
        if (t3 + 2 >= u2) return e;
        if (o2 = 255 & e[++t3], 128 != (192 & o2)) return e;
        if (n5 = 255 & e[++t3], 128 != (192 & n5)) return e;
        d2[i2] = (15 & r2) << 12 | (63 & o2) << 6 | 63 & n5;
      }
      else {
        if (!r2) return e;
        d2[i2] = r2;
      }
      16383 == i2 && (s2.push(String.fromCharCode.apply(String, d2)), i2 = -1);
    }
    return i2 > 0 && (d2.length = i2, s2.push(String.fromCharCode.apply(String, d2))), s2.join("");
  }
  function er(e) {
    return e[1] + e[0];
  }
  function rr(e, o2, n5) {
    function t3() {
      try {
        for (var e2, r2 = 0, u3 = (/* @__PURE__ */ new Date()).getTime(); L(c2.d.Q); ) if (++r2 % 1e3 == 0 && (/* @__PURE__ */ new Date()).getTime() - u3 > 200) return s2 && (i2 = er(c2.d.Q.h.d) / d2, n5(i2)), tr(t3, 0), 0;
        n5(1), e2 = Y(_(c2.d.S)), tr(o2.bind(null, e2), 0);
      } catch (m4) {
        o2(null, m4);
      }
    }
    var i2, u2, s2, d2, c2 = {}, m3 = void 0 === o2 && void 0 === n5;
    if ("function" != typeof o2 && (u2 = o2, o2 = n5 = 0), n5 = n5 || function(e2) {
      return void 0 !== u2 ? r(s2 ? e2 : -1, u2) : void 0;
    }, o2 = o2 || function(e2, r2) {
      return void 0 !== u2 ? pp({ action: or, cbn: u2, result: e2, error: r2 }) : void 0;
    }, m3) {
      for (c2.d = l({}, e); L(c2.d.Q); ) ;
      return Y(_(c2.d.S));
    }
    try {
      c2.d = l({}, e), d2 = er(c2.d.N), s2 = d2 > -1, n5(0);
    } catch (a2) {
      return o2(null, a2);
    }
    tr(t3, 0);
  }
  var or = 2, nr = 3, tr = "function" == typeof setImmediate ? setImmediate : setTimeout, ir = 4294967296, ur = [n1, -4294967296], sr = [0, 0], dr = [1, 0];
  return { decompress: rr };
}();
var LZMA = {
  decompress: (r, callback) => {
    lzma.decompress(new Uint8Array(r), callback);
  }
};
var isGL2 = true;
var isInit = false;
var renderer$1 = null;
var materials = /* @__PURE__ */ new Map();
var uniforms = {
  renderMode: { value: 0 },
  fogMode: { value: 1 },
  depthPacking: { value: 1 },
  time: { value: 0 },
  shadow: { value: 0.5 },
  shadowGamma: { value: 0.25 },
  //1
  shadowLuma: { value: 0 },
  //0.75
  shadowContrast: { value: 1 },
  //2.5
  //shadowAlpha: { value: 1.0 }
  lightSizeUV: { value: 1 },
  //3
  nearPlane: { value: 1 },
  //9.5
  rings: { value: 4 },
  //11
  nSample: { value: 16 },
  //17
  noiseIntensity: { value: 1 },
  softness: { value: 1.6 },
  noiseMap: { value: null },
  useNoiseMap: { value: 0 }
};
var Shader = class _Shader {
  get renderer() {
    return renderer$1;
  }
  set renderer(r) {
    renderer$1 = r;
  }
  static setGl2(b) {
    isGL2 = b;
  }
  static getGl2(b) {
    return isGL2;
  }
  static setting() {
    return uniforms;
  }
  static getRandomUv() {
    return randomUV;
  }
  static addParsFragment(s, adds) {
    s.fragmentShader = s.fragmentShader.replace("#include <clipping_planes_pars_fragment>", "#include <clipping_planes_pars_fragment>" + adds);
  }
  /*static addToParsFragment( fragment, adds ){
      return fragment.replace( '#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>' + adds );
  }*/
  static init(o = {}) {
    const activeShadowPCSS = o.shadowType === "PCSS";
    ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace(
      "vec3 CustomToneMapping( vec3 color ) { return color; }",
      `#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
            float toneMappingWhitePoint = 1.0;
            vec3 CustomToneMapping( vec3 color ) {
                color *= toneMappingExposure;
                return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
            }`
    );
    if (!activeShadowPCSS) return;
    let s;
    this.up(o);
    if (activeShadowPCSS) {
      s = ShaderChunk.shadowmap_pars_fragment;
      s = s.replace(
        "#ifdef USE_SHADOWMAP",
        shadowPCSS
      );
      s = s.replace(
        //BasicShadowMap
        "shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );",
        `
                return PCSS( shadowMap, shadowCoord );
            `
      );
      ShaderChunk.shadowmap_pars_fragment = s;
    }
    s = ShaderChunk.common;
    s = s.replace("#define EPSILON 1e-6", `
        	#define EPSILON 1e-6
        	uniform float shadow;
            uniform float shadowLuma;
            uniform float shadowContrast;
            uniform float shadowGamma;

            uniform int renderMode;
            uniform int fogMode;
            uniform int depthPacking;

            varying vec2 vZW;
            varying vec3 rayDir;
            varying vec3 rayDir2;
            varying vec3 rayOri;
            //varying float fDist;

            float shadowValue = 1.0;
            float shadowTmp = 1.0;
            vec3 shadowColor = vec3(1.0);
            
            float color_distance( vec3 a, vec3 b){
                vec3 s = vec3( a - b );
                float dist = sqrt( s.r * s.r + s.g * s.g + s.b * s.b );
                return clamp(dist, 0.0, 1.0);
            }

            vec3 adjustContrast(vec3 color, float value) {
                const vec3 zero = vec3(0.);
                return max(zero, 0.5 + value * (color - 0.5));
            }

            vec3 hsv2rgb(vec3 c){
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            vec3 rgb2hsv(vec3 rgb) {
                float Cmax = max(rgb.r, max(rgb.g, rgb.b));
                float Cmin = min(rgb.r, min(rgb.g, rgb.b));
                float delta = Cmax - Cmin;
                vec3 hsv = vec3(0., 0., Cmax);
                if (Cmax > Cmin) {
                    hsv.y = delta / Cmax;
                    if (rgb.r == Cmax) hsv.x = (rgb.g - rgb.b) / delta;
                    else {
                        if (rgb.g == Cmax) hsv.x = 2. + (rgb.b - rgb.r) / delta;
                        else hsv.x = 4. + (rgb.r - rgb.g) / delta;
                    }
                    hsv.x = fract(hsv.x / 6.);
                }
                return hsv;
            }

            /*
            vec3 rgb2hsv(vec3 c){
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }

            vec3 brightnessContrastCorrection(vec3 value, float brightness, float contrast){
                return (value - 0.5) * contrast + 0.5 + brightness;
            }

            vec3 GammaCorrection(vec3 value, float param){
                return vec3(pow(abs(value.r), param),pow(abs(value.g), param),pow(abs(value.b), param));
            }
            */
            

        `);
    ShaderChunk.common = s;
    ShaderChunk.clipping_planes_vertex = `
            #if NUM_CLIPPING_PLANES > 0
                vClipPosition = - mvPosition.xyz;
            #endif
            vZW = gl_Position.zw;
        `;
    s = ShaderChunk.lights_fragment_begin;
    s = s.replace("directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;", `
            shadowTmp = 1.0;
            shadowTmp *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;;
            //directLight.color *= shadowTmp;
            shadowValue *= shadowTmp;
        `);
    s = s.replace("directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;", `
            shadowTmp = 1.0;
            shadowTmp *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
            //directLight.color *= shadowTmp;
            shadowValue *= shadowTmp;
        `);
    s = s.replace("directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", `
            shadowTmp = 1.0;
            shadowTmp *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
            //directLight.color *= shadowTmp;
            shadowValue *= shadowTmp;
        `);
    ShaderChunk.lights_fragment_begin = s;
    {
      ShaderChunk.fog_vertex = FogVertex;
      ShaderChunk.fog_fragment = FogFragment;
    }
    s = ShaderChunk.opaque_fragment;
    s = s.replace("gl_FragColor = vec4( outgoingLight, diffuseColor.a );", `

            gl_FragColor = vec4( outgoingLight, diffuseColor.a );

        	#if defined( USE_SHADOWMAP )

            shadowValue = (shadowValue - 0.5) * shadowContrast + 0.5 + shadowLuma;
            shadowValue = pow(abs(shadowValue), shadowGamma );
            shadowValue = clamp( shadowValue, 0.0, 1.0 );

            shadowColor = vec3( shadowValue );

            ///shadowColor = vec3( 0.0,0.0,1.0-shadowValue );

            //vec3 sColor = vec3( 0.1, 0.1, 0.8 );
            //shadowColor.b += 1.0-shadowValue ;



            // TODO find better shadow variation

            vec3 invert = vec3( 1.0 - gl_FragColor.rgb );
            vec3 dd = vec3(0.38,0.42,0.63);
            float gray = ((gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0);
            vec3 invColor = gray * dd;
            invColor = invColor * mix( invColor, invert, 1.0-gray*0.5 );




                    


            //gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * shadowColor, (1.0-shadowValue) * shadow );

            //gl_FragColor.rgb *= ((1.0-shadowValue) * (1.0-shadow)) + shadowColor;

            //gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * invColor, (1.0-shadowValue) * shadow );

            gl_FragColor.rgb = mix( gl_FragColor.rgb, invColor, (1.0-shadowValue) * shadow );

            //gl_FragColor.rgb = invColor;

            //gl_FragColor.rgb = gl_FragColor.rgb * shadowColor;

            //gl_FragColor.rgb *= ((1.0-shadowValue) * shadow) * invColor;


        	#endif
            
        `);
    ShaderChunk.opaque_fragment = s;
    s = ShaderChunk.dithering_fragment;
    s = s.replace("#endif", `

            #endif

            #ifdef STANDARD

            if( renderMode == 1 ){ 
                float fz = 0.5 * vZW[0] / vZW[1] + 0.5;
                gl_FragColor = depthPacking == 1 ? packDepthToRGBA( fz ) : vec4( vec3( 1.0 - fz ), opacity );// depth render
            }
            if( renderMode == 2 ) gl_FragColor = vec4(  packNormalToRGB( normal ), opacity );// normal render
            if( renderMode == 3 ) gl_FragColor = vec4(  shadowColor, opacity );// normal render

            #else

            if( renderMode != 0 ) discard;

            #endif

        `);
    ShaderChunk.dithering_fragment = s;
    s = ShaderChunk.color_vertex;
    s = s.replace("vColor.xyz *= instanceColor.xyz;", `vColor.xyz = instanceColor.xyz;`);
    ShaderChunk.color_vertex = s;
    isInit = true;
  }
  static add(m2, beforeCompile = null) {
    if (!isInit) return;
    if (!m2) return;
    let name = m2.name;
    if (materials.has(name)) {
      console.log("already add", name);
      return;
    }
    materials.set(name, true);
    if (m2.shadowSide === null) m2.shadowSide = DoubleSide;
    m2.onBeforeCompile = function(shader) {
      _Shader.modify(shader);
      if (beforeCompile) beforeCompile(shader);
    };
  }
  static refresh() {
  }
  static setDefines(m2) {
  }
  static modify(s) {
    if (!isInit) return;
    for (let n2 in uniforms) {
      s.uniforms[n2] = uniforms[n2];
    }
  }
  static up(o) {
    for (let n2 in o) {
      if (uniforms[n2]) {
        if (uniforms[n2].value.isColor) uniforms[n2].value.setHex(o[n2]);
        else uniforms[n2].value = o[n2];
      }
    }
  }
  static reset() {
    materials.clear();
  }
};
var FogVertex = (
  /* glsl */
  `

#ifdef USE_FOG

    vFogDepth = - mvPosition.z;

    rayDir2 = normalize( worldPosition.xyz - cameraPosition );
    rayDir = normalize( mvPosition.xyz );
    rayOri = cameraPosition.xyz;

    //rayOri = worldPosition.xyz; //( cameraPosition-worldPosition.xyz  );
    //vec3 tt = vec3(cameraPosition-mvPosition);
    //float fDist = sqrt(tt.x*tt.x+tt.y*tt.y+tt.z*tt.z);
    //fDist = distance(cameraPosition.xyz, mvPosition.xyz);

#endif
`
);
var FogFragment = (
  /* glsl */
  `

#ifdef USE_FOG

    #ifdef FOG_EXP2

        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

    #else

        float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
        float fogDensity = 0.01;

    #endif

    

    /*vec4 CCF = vec4(fogColor, 1.0);
    #if defined( TONE_MAPPING )
        CCF.rgb = toneMapping( CCF.rgb );
        //CCF = linearToOutputTexel( CCF );
    #endif*/

    if( fogMode == 0 ){

        gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    } 

    if( fogMode == 1 ){

        vec3 fcolor = fogColor;

        #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

            float aa = fogDensity * fogDensity * 1.0;
            float bb = fogDensity * fogDensity * 12.0;
            //bb = pow(bb, 0.8);
            float distance = vFogDepth * vFogDepth;

            fogFactor = 1.0 - exp( -distance*bb );
            fogFactor = (aa/bb) * exp(-rayOri.y*bb) * (1.0-exp( -distance*rayDir2.y*bb ))/rayDir2.y;
            fogFactor = clamp( fogFactor, 0.0, 1.0 );

            vec3 sunDir = normalize( directionalLights[ 0 ].direction );
            vec3 sunColor = directionalLights[ 0 ].color;
            // sunColor = vec3(1,0,0);
            float sunAmount = max( dot( rayDir, sunDir ), 0.0 );
            //float sunAdd = clamp( pow(sunAmount, 60.0), 0.0, 1.0 );
            float sunAdd = pow(sunAmount, 16.0);
            fcolor = mix( fogColor, sunColor, sunAdd ); // 8.0

        #endif

        gl_FragColor.rgb = gl_FragColor.rgb * (1.0-fogFactor) + fcolor * fogFactor;

    }

#endif
`
);
var shadowPCSS = (
  /* glsl */
  `

#ifdef USE_SHADOWMAP

uniform float lightSizeUV;
uniform float nearPlane;
uniform float rings;
uniform int nSample;
uniform float noiseIntensity;
uniform float softness;

//#define LIGHT_WORLD_SIZE 0.005
//#define LIGHT_FRUSTUM_WIDTH 3.75
//#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)
//#define NEAR_PLANE 9.5

#define SAMPLE 16
#define RINGS 4

vec2 poissonDisk[32];

void initPoissonSamples( const in vec2 randomSeed ) {

    float ANGLE_STEP = PI2 * float(rings) / float( nSample );
    float INV_NUM_SAMPLES = 1.0 / float( nSample );

    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
    float angle = rand( randomSeed ) * PI2;
    float radius = INV_NUM_SAMPLES;
    float radiusStep = radius;

    for( int i = 0; i < nSample; i ++ ) {
        poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );
        radius += radiusStep;
        angle += ANGLE_STEP;
    }
}

float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
    return (zReceiver - zBlocker) / zBlocker;
}

float findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver, float ls ) {

    // This uses similar triangles to compute what
    // area of the shadow map we should search
    float searchRadius = ls * ( zReceiver - nearPlane ) / zReceiver;
    float blockerDepthSum = 0.0;
    int numBlockers = 0;
    float shadowMapDepth = 0.0;

    for( int i = 0; i < nSample; i++ ) {
        shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
        if ( shadowMapDepth < zReceiver ) {
            blockerDepthSum += shadowMapDepth;
            numBlockers ++;
        }
    }

    if( numBlockers == 0 ) return -1.0;

    return blockerDepthSum / float( numBlockers );

}

float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {
    
    /*
    int numSample = nSample;
    float sum = 0.0;
    float depth;
    #pragma unroll_loop_start
    for( int i = 0; i < nSample; i ++ ) {
        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );
        if( zReceiver <= depth ) sum += 1.0;
    }
    #pragma unroll_loop_end
    #pragma unroll_loop_start
    for( int i = 0; i < nSample; i ++ ) {
        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );
        if( zReceiver <= depth ) sum += 1.0;
    }
    #pragma unroll_loop_end
    return sum / ( 2.0 * float( nSample ) );
    */

    
    float sum = 0.0;
    float top = 0.0;
    float low = 0.0;
    #pragma unroll_loop_start
    for( int i = 0; i < 16; i ++ ) {
        top = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );
        low = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );
        if( zReceiver <= top ) sum += 1.0;
        if( zReceiver <= low ) sum += 1.0;
    }
    #pragma unroll_loop_end
    return sum / ( 2.0 * float( nSample ) );
}

float PCSS ( sampler2D shadowMap, vec4 coords ) {

    vec2 uv = coords.xy;
    float zReceiver = coords.z; // Assumed to be eye-space z in this code
    //float lightSizeUV = LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH;

    float ls = lightSizeUV * 0.001;

    initPoissonSamples( uv );
    // STEP 1: blocker search
    float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver, ls );

    //There are no occluders so early out (this saves filtering)
    if( avgBlockerDepth == -1.0 ) return 1.0;

    // STEP 2: penumbra size
    float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );
    float filterRadius = penumbraRatio * ls * nearPlane / zReceiver;

    // STEP 3: filtering
    //return avgBlockerDepth;
    return PCF_Filter( shadowMap, uv, zReceiver, filterRadius * softness );
}


`
);
var randomUV = (
  /* glsl */
  `

uniform sampler2D noiseMap;
uniform float useNoiseMap;

float directNoise(vec2 p){
    vec2 ip = floor(p);
    vec2 u = fract(p);
    u = u*u*(3.0-2.0*u);
    
    float res = mix(
        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
    return res*res;
}

float sum( vec4 v ) { return v.x+v.y+v.z; }

vec4 textureNoTile( sampler2D mapper, in vec2 uv ){

    // sample variation pattern
    float k = 0.0;
    if( useNoiseMap == 1.0 ) k = texture2D( noiseMap, 0.005*uv ).x;
    else k = directNoise( uv );
    
    // compute index    
    float index = k*8.0;
    float f = fract( index );

    float ia = floor( index );
    float ib = ia + 1.0;
    // or
    //float ia = floor(index+0.5); // suslik's method (see comments)
    //float ib = floor(index);
    //f = min(f, 1.0-f)*2.0;

    // offsets for the different virtual patterns    
    vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash    
    vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash    

    // compute derivatives for mip-mapping    
    vec2 dx = dFdx(uv);
    vec2 dy = dFdy(uv);
    
    // sample the two closest virtual patterns    
    vec4 cola = textureGrad( mapper, uv + offa, dx, dy );
    vec4 colb = textureGrad( mapper, uv + offb, dx, dy );

    // interpolate between the two virtual patterns    
    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );

}
`
);
var GlbTool = {
  getMesh: (scene2, multyMaterialGroup) => {
    let meshs = {};
    if (multyMaterialGroup) {
      let oldGroup = [];
      let nMesh = [];
      scene2.traverse((child) => {
        if (child.isGroup) {
          let m2 = GlbTool.groupToMesh(child);
          if (m2) {
            oldGroup.push(child);
            nMesh.push(m2);
          }
        }
      });
      let i = oldGroup.length, p2;
      while (i--) {
        p2 = oldGroup[i].parent;
        p2.remove(oldGroup[i]);
        p2.add(nMesh[i]);
      }
    }
    scene2.traverse((child) => {
      if (child.isMesh) meshs[child.name] = child;
    });
    return meshs;
  },
  keepMaterial: (scene2) => {
    let Mats = {}, m2;
    scene2.traverse((child) => {
      if (child.isMesh) {
        m2 = child.material;
        if (!Mats[m2.name]) {
          Shader.add(m2);
          console.log(m2.name);
          Mats[m2.name] = true;
        }
      }
    });
  },
  getGroup: (scene2, autoMesh, autoMaterial) => {
    const groups = {};
    let mats = null;
    scene2.traverse((child) => {
      if (child.isGroup) {
        groups[child.name] = autoMesh ? GlbTool.groupToMesh(child, mats) : child;
      }
    });
    return groups;
  },
  // Material should be name like 
  // 0_concret
  // 10_silver ...
  getMaterial: (scene2) => {
    const Mats = {};
    let names = [];
    let m2;
    scene2.traverse((child) => {
      if (child.isMesh) {
        m2 = child.material;
        if (names.indexOf(m2.name) === -1) {
          names.push(m2.name);
          Shader.add(m2);
          Mats[m2.name] = m2;
          if (m2.color) m2.color.convertSRGBToLinear();
          if (m2.vertexColors) m2.vertexColors = false;
        }
      }
    });
    return Mats;
  },
  // convert multymaterial group to mesh
  groupToMesh: (group) => {
    if (group.children[0].name !== group.name + "_1") return false;
    if (!group.children[0].isMesh) return false;
    let geometry = [];
    let material = [];
    let i = group.children.length;
    while (i--) {
      material[i] = group.children[i].material;
      geometry[i] = group.children[i].geometry;
      geometry[i].group = i;
    }
    let mesh = new THREE.Mesh(new mergeGeometries(geometry, true), material);
    mesh.name = group.name;
    return mesh;
  },
  symetric: (g2) => {
    if (g2.isMesh) g2 = g2.geometry;
    let uv = g2.attributes.uv.array;
    let i = uv.length * 0.5;
    while (i--) {
      if (uv[i * 2] < 0) uv[i * 2] *= -1;
    }
    g2.attributes.uv.needsUpdate = true;
  },
  uv2: (g2) => {
    if (g2.isMesh) g2 = g2.geometry;
    g2.setAttribute("uv2", g2.attributes.uv);
  },
  autoMorph: (mod, meshs, normal = true, relative = false) => {
    let morph = {};
    let tmpMesh = [];
    mod.traverse((node) => {
      if (node.isMesh && node.name.search("__M__") !== -1) {
        morph[node.name] = node.geometry;
        tmpMesh.push(node);
      }
    });
    let oName, tName, target, id, g2, gm, j, dp, dn, ar, m2;
    for (let name in morph) {
      oName = name.substring(0, name.indexOf("__"));
      tName = name.substring(name.lastIndexOf("__") + 2);
      target = meshs[oName];
      if (target) {
        g2 = target.geometry;
        gm = morph[name];
        g2.morphTargetsRelative = relative;
        if (g2.attributes.position.count === gm.attributes.position.count) {
          if (!g2.morphAttributes.position) {
            g2.morphAttributes.position = [];
            if (normal) g2.morphAttributes.normal = [];
            target.morphTargetInfluences = [];
            target.morphTargetDictionary = {};
          }
          id = g2.morphAttributes.position.length;
          if (relative) {
            j = gm.attributes.position.array.length;
            ar = [];
            while (j--) ar[j] = gm.attributes.position.array[j] - g2.attributes.position.array[j];
            dp = new Float32BufferAttribute(ar, 3);
          } else {
            dp = new Float32BufferAttribute(gm.attributes.position.array, 3);
          }
          g2.morphAttributes.position.push(dp);
          if (normal) {
            dn = new Float32BufferAttribute(gm.attributes.normal.array, 3);
            g2.morphAttributes.normal.push(dn);
          }
          target.morphTargetInfluences.push(0);
          target.morphTargetDictionary[tName] = id;
        } else {
          console.warn("Morph " + tName + " target is no good on " + target.name);
        }
      }
    }
    morph = {};
    j = tmpMesh.length;
    while (j--) {
      m2 = tmpMesh[j];
      if (m2.parent) m2.parent.remove(m2);
      if (m2.material) m2.material.dispose();
      if (m2.geometry) m2.geometry.dispose();
    }
  }
};
var Pool = {
  manager: new LoadingManager(),
  renderer: null,
  msg: "",
  inLoad: false,
  clip: [],
  data: /* @__PURE__ */ new Map(),
  tmp: [],
  lzma: null,
  //extraTexture: [],
  dracoLoader: null,
  //dracoLoaderType:'js',
  dracoPath: "./src/libs/draco/",
  basisPath: "./src/jsm/libs/basis/",
  maxAnisotropy: 1,
  onLoad: () => {
  },
  onEnd: () => {
  },
  log: (msg) => {
  },
  materialRoot: (n2) => {
    console.log(n2);
  },
  setLoadEvent: (onload, onend) => {
    Pool.onLoad = onload;
    Pool.onEnd = onend;
  },
  prefix: (type) => {
    let p2 = "";
    switch (type) {
      case "S":
      case "sound":
      case "mp3":
      case "wav":
      case "ogg":
        p2 = "S_";
        break;
      case "I":
      case "image":
      case "jpg":
      case "png":
        p2 = "I_";
        break;
      case "E":
      case "hdr":
      case "env":
        p2 = "T_";
        break;
      case "J":
      case "json":
        p2 = "J_";
        break;
      case "JS":
      case "js":
        p2 = "JS_";
        break;
      case "H":
      case "bin":
      case "hex":
        p2 = "H_";
        break;
      case "O":
      case "object3d":
        p2 = "O_";
        break;
      case "M":
      case "material":
        p2 = "M_";
        break;
      case "T":
      case "texture":
        p2 = "T_";
        break;
    }
    return p2;
  },
  dispose: () => {
    Pool.data.forEach(function(node, key) {
      if (node.isMaterial || node.isTexture) {
        node.dispose();
        Pool.data.delete(key);
      }
      if (node.isObject3D) {
        node.traverse(function(snode) {
          if (snode.isMesh) {
            if (snode.geometry) snode.geometry.dispose();
            if (snode.material) {
              if (snode.material.dispose) snode.material.dispose();
            }
          }
        });
        Pool.data.delete(key);
      }
    });
  },
  createElementNS: (name) => document.createElementNS("http://www.w3.org/1999/xhtml", name),
  exist: (name, type = "") => Pool.get(name, type) ? true : false,
  delete: (name, type = "") => Pool.data.delete(Pool.prefix(type) + name),
  get: (name, type = "") => Pool.data.get(Pool.prefix(type) + name),
  set: (name, node, type = "", direct) => {
    if (!node) {
      console.log("Loading error on " + name);
      return;
    }
    if (node.isMaterial) {
      type = "material";
      node.name = name;
      Pool.materialRoot(node, direct);
    }
    if (node.isTexture) type = "texture";
    if (node.isObject3D) type = "object3d";
    if (Pool.get(name, type)) return;
    Pool.data.set(Pool.prefix(type) + name, node);
  },
  getScript: (name) => Pool.data.get(Pool.prefix("js") + name),
  getMaterials: (obj) => {
    if (typeof obj === "string") obj = Pool.get(obj, "O");
    return GlbTool.getMaterial(obj);
  },
  getGLB: (obj, keepMaterial) => {
    if (typeof obj === "string") obj = Pool.get(obj, "O");
    if (!obj) return console.error("Not find Model ?");
    return obj;
  },
  /*getMaterialList:( obj, keepMaterial ) => {
      if( typeof obj === 'string' ) obj = Pool.get( obj, 'O' );
      if(!obj) return console.error('Not find Model ?')
      return GlbTool.getMesh( obj, keepMaterial )
  },*/
  getMesh: (obj, multyMaterialGroup) => {
    if (typeof obj === "string") obj = Pool.get(obj, "O");
    if (!obj) return console.error("Not find Model ?");
    return GlbTool.getMesh(obj, multyMaterialGroup);
  },
  getGroup: (obj, autoMesh, autoMaterial) => {
    if (typeof obj === "string") obj = Pool.get(obj, "O");
    return GlbTool.getGroup(obj, autoMesh, autoMaterial);
  },
  applyMorph(modelName, meshs = null, normal = true, relative = true) {
    let model2;
    if (modelName.isObject3D) model2 = modelName;
    else model2 = Pool.get(modelName, "O");
    if (!meshs) meshs = Pool.getMesh(modelName);
    if (!model2 || !meshs) return;
    GlbTool.autoMorph(model2, meshs, normal, relative);
  },
  uv2(model2) {
    GlbTool.uv2(model2);
  },
  symetric(model2) {
    GlbTool.symetric(model2);
  },
  objectSpaceNormal(model2) {
    model2.material.normalMapType = ObjectSpaceNormalMap;
  },
  add: (name, node, type) => {
    Pool.set(name, node, type);
    Pool.next();
  },
  getMaterial: (name) => Pool.data.get("M_" + name),
  //getMap:( name, o = {} ) => ( Pool.getTexture(name, o) ),
  //--------------------
  //   TEXTURES
  //--------------------
  texture: (o = {}) => {
    if (!Pool.loaderMap) Pool.loaderMap = new TextureLoader();
    let name = o.name || "";
    if (o.url) {
      if (o.url.lastIndexOf(".") !== -1) name = o.url.substring(o.url.lastIndexOf("/") + 1, o.url.lastIndexOf("."));
      else name = o.url.substring(o.url.lastIndexOf("/") + 1);
    }
    if (name.search("_c") !== -1 || name.search("_l") !== -1 || name.search("_u") !== -1 || name.search("_d") !== -1) o.srgb = true;
    if (Pool.exist(name, "texture")) return Pool.get(name, "texture");
    else if (Pool.exist(name, "image")) {
      return Pool.getTexture(name, o);
    } else {
      return Pool.loaderMap.load(o.url, function(t2) {
        Pool.setTextureOption(t2, o);
        Pool.data.set("T_" + name, t2);
        if (o.callback) o.callback();
        return t2;
      });
    }
  },
  getTexture: (name, o = {}) => {
    let k = o.quality ? o.quality + "k_" : "";
    name = k + name;
    let t2 = Pool.get(name, "texture");
    if (!t2) {
      let im = Pool.get(name, "image");
      if (!im) {
        return null;
      }
      t2 = new Texture(im);
      if (name.search("_c") !== -1 || name.search("_d") !== -1 || name.search("_l") !== -1 || name.search("_u") !== -1) o.srgb = true;
      Pool.data.set("T_" + name, t2);
    }
    Pool.setTextureOption(t2, o);
    return t2;
  },
  setTextureOption: (t2, o = {}) => {
    if (o.encoding) t2.colorSpace = SRGBColorSpace;
    if (o.srgb) t2.colorSpace = SRGBColorSpace;
    t2.flipY = o.flipY !== void 0 || o.flip !== void 0 ? o.flipY : false;
    t2.anisotropy = o.anisotropy !== void 0 ? o.anisotropy : Pool.maxAnisotropy;
    if (o.generateMipmaps !== void 0) t2.generateMipmaps = o.generateMipmaps;
    if (o.repeat) {
      t2.repeat.fromArray(o.repeat);
      t2.wrapS = t2.wrapT = RepeatWrapping;
    }
    if (o.center) t2.center.fromArray(o.center);
    if (o.offset) t2.offset.fromArray(o.offset);
    if (o.filter) {
      if (o.filter === "near") {
        t2.minFilter = NearestFilter;
        t2.magFilter = NearestFilter;
      }
    }
    if (o.channel) t2.channel = o.channel;
    t2.needsUpdate = true;
  },
  ///
  loadAsync: (Urls, Path2 = "", msg = "") => {
    return new Promise((resolve, reject) => {
      Pool.waiting = true;
      Pool.load(Urls, () => {
        Pool.waiting = false;
      }, Path2, msg);
    });
  },
  ///
  load: (Urls, Callback, Path2 = "", msg = "", quality = 0) => {
    Pool.msg = msg;
    let urls = [];
    let callback = Callback || function() {
    };
    let start = (typeof performance === "undefined" ? Date : performance).now();
    if (typeof Urls === "string" || Urls instanceof String) urls.push(Urls);
    else urls = urls.concat(Urls);
    Pool.tmp.push({ urls, path: Path2, callback, start, quality });
    if (!Pool.inLoad) Pool.loadOne();
  },
  loadOne: () => {
    Pool.inLoad = true;
    Pool.onLoad();
    let url2 = Pool.tmp[0].path + Pool.tmp[0].urls[0];
    let name = url2.substring(url2.lastIndexOf("/") + 1, url2.lastIndexOf("."));
    let type = url2.substring(url2.lastIndexOf(".") + 1).toLowerCase();
    if (type === "jpg" || type === "png") name = (Pool.tmp[0].quality ? Pool.tmp[0].quality + "k_" : "") + name;
    if (Pool.exist(name, type)) Pool.next();
    else Pool.loading(url2, name, type);
  },
  next: () => {
    Pool.tmp[0].urls.shift();
    if (Pool.tmp[0].urls.length === 0) {
      Math.floor((typeof performance === "undefined" ? Date : performance).now() - Pool.tmp[0].start);
      Pool.tmp[0].callback();
      Pool.tmp.shift();
      if (Pool.tmp.length > 0) Pool.loadOne();
      else {
        Pool.inLoad = false;
        Pool.clearDRACO();
        Pool.onEnd();
      }
    } else {
      Pool.loadOne();
    }
  },
  loading: (url2, name, type) => {
    Pool.log(Pool.msg);
    switch (type) {
      case "glb":
      case "gltf":
        Pool.load_GLTF(url2, name);
        break;
      case "fbx":
      case "FBX":
        Pool.load_FBX(url2, name);
        break;
      case "obj":
        Pool.load_OBJ(url2, name);
        break;
      case "stl":
        Pool.load_STL(url2, name);
        break;
      case "ktx2":
        Pool.load_KTX2(url2, name);
        break;
      case "hdr":
        Pool.load_RGBE(url2, name);
        break;
      case "exr":
        Pool.load_EXR(url2, name);
        break;
      default:
        Pool.extand(url2, name, type);
    }
  },
  extand: (url2, name, type) => {
    if (!Pool.XHTTP) Pool.XHTTP = new XMLHttpRequest();
    const xml = Pool.XHTTP;
    xml.open("GET", url2, true);
    if (type === "json") xml.overrideMimeType("application/json");
    switch (type) {
      case "bin":
      case "hex":
      case "wasm":
      case "mp3":
      case "wav":
      case "ogg":
        xml.responseType = "arraybuffer";
        break;
      case "jpg":
      case "png":
        xml.responseType = "blob";
        break;
      case "bvh":
      case "glsl":
      case "js":
      case "json":
        xml.responseType = "text";
        break;
    }
    xml.onreadystatechange = function() {
      if (xml.readyState === 4) {
        if (xml.status >= 300) {
          console.log("Error, status code = " + xml.status);
        } else {
          Pool.direct(xml.response, name, type);
        }
      }
    };
    if ("onprogress" in xml) {
      xml.onprogress = function(e) {
      };
    }
    xml.send(null);
  },
  direct: (response, name, type) => {
    switch (type) {
      case "jpg":
      case "png":
        let img = Pool.createElementNS("img");
        img.onload = function(e) {
          window.URL.revokeObjectURL(img.src);
          Pool.add(name, img, "image");
        };
        img.src = window.URL.createObjectURL(response);
        break;
      case "mp3":
      case "wav":
      case "ogg":
        AudioContext.getContext().decodeAudioData(
          response.slice(0),
          function(buffer) {
            Pool.add(name, buffer, "sound");
          },
          function(error) {
            console.error("decodeAudioData error", error);
          }
        );
        break;
      case "hex":
      case "bin":
        LZMA.decompress(response, (result) => {
          Pool.add(name, result, type);
        });
        break;
      case "wasm":
        Pool.add(name, new Uint8Array(response), type);
        break;
      case "json":
        Pool.add(name, JSON.parse(response), type);
        break;
      case "js":
        Pool.add(name, response, type);
        break;
      default:
        Pool.add(name, response, type);
    }
  },
  //////////////////////////////////
  clearDRACO: () => {
    if (Pool.dracoLoader) {
      Pool.dracoLoader.dispose();
      Pool.dracoLoader = null;
    }
    if (Pool.GLTF) {
      Pool.GLTF = null;
    }
  },
  loaderDRACO: () => {
    if (Pool.dracoLoader) return Pool.dracoLoader;
    if (!Pool.dracoLoaderType) {
      if (navigator.userAgentData) Pool.dracoLoaderType = "wasm";
      else {
        let ua = navigator.userAgent.toLowerCase();
        Pool.dracoLoaderType = ua.indexOf("safari") !== -1 && ua.indexOf("chrome") === -1 ? "js" : "wasm";
      }
    }
    Pool.dracoLoader = new DRACOLoader().setDecoderPath(Pool.dracoPath);
    Pool.dracoLoader.setDecoderConfig({ type: Pool.dracoLoaderType });
    return Pool.dracoLoader;
  },
  loaderKTX2: () => {
    if (!Pool.KTX2) {
      Pool.KTX2 = new KTX2Loader(Pool.manager).setTranscoderPath(Pool.basisPath).detectSupport(Pool.renderer);
    }
    return Pool.KTX2;
  },
  loaderGLTF: () => {
    if (!Pool.GLTF) {
      Pool.GLTF = new GLTFLoader(Pool.manager).setCrossOrigin("anonymous").setDRACOLoader(Pool.loaderDRACO()).setKTX2Loader(Pool.loaderKTX2()).setMeshoptDecoder(MeshoptDecoder);
    }
    return Pool.GLTF;
  },
  loaderFBX: () => {
    if (!Pool.FBX) Pool.FBX = new FBXLoader(Pool.manager);
    return Pool.FBX;
  },
  loaderSTL: () => {
    if (!Pool.STL) Pool.STL = new STLLoader(Pool.manager);
    return Pool.STL;
  },
  loaderOBJ: () => {
    if (!Pool.OBJ) Pool.OBJ = new OBJLoader(Pool.manager);
    return Pool.OBJ;
  },
  loaderRGBE: () => {
    if (!Pool.RGBE) Pool.RGBE = new RGBELoader(Pool.manager);
    return Pool.RGBE;
  },
  loaderEXR: () => {
    if (!Pool.EXR) Pool.EXR = new EXRLoader(Pool.manager);
    return Pool.EXR;
  },
  //////////////////////////////////
  load_GLTF: (url2, name) => {
    Pool.loaderGLTF().load(url2, function(gltf) {
      const model2 = gltf.scene;
      if (gltf.animations) {
        const animations = gltf.animations;
        const mixer = new AnimationMixer(gltf.scene);
        model2.mixer = mixer;
        model2.actions = {};
        for (let i = 0; i < animations.length; i++) {
          let anim = animations[i];
          model2.actions[anim.name] = mixer.clipAction(anim);
        }
        model2.play = (name2) => {
          if (model2.actions[name2]) {
            model2.actions[name2].paused = false;
            model2.actions[name2].time = 0;
            model2.actions[name2].play();
          }
        };
        model2.pause = (name2, v = true) => {
          if (model2.actions[name2]) model2.actions[name2].paused = v;
        };
      }
      Pool.add(name, model2);
    });
  },
  load_FBX: (url2, name) => {
    Pool.loaderFBX().load(url2, function(node) {
      Pool.add(name, node);
    });
  },
  load_OBJ: (url2, name) => {
    Pool.loaderOBJ().load(url2, function(node) {
      Pool.add(name, node);
    });
  },
  load_STL: (url2, name) => {
    Pool.loaderSTL().load(url2, function(node) {
      let object = new Mesh(node);
      Pool.add(name, object);
    });
  },
  load_KTX2: (url2, name, cb) => {
    Pool.loaderKTX2().load(url2, function(texture) {
      Pool.add(name, texture);
      return texture;
    });
  },
  load_RGBE: (url2, name) => {
    Pool.loaderRGBE().load(url2, function(texture) {
      texture.mapping = EquirectangularReflectionMapping;
      Pool.add(name, texture);
    });
  },
  load_EXR: (url2, name, cb) => {
    Pool.loaderEXR().load(url2, function(texture) {
      if (cb) cb(texture);
      return texture;
    });
  },
  direct_EXR: (data, name) => {
    Pool.loaderEXR().parse(url, function(texture) {
      Pool.add(name, texture);
      return texture;
    });
  }
};
var Tension = class {
  constructor(origin, target) {
    this.target = target || origin;
    this.baseGeometry = origin.geometry;
    this.geometry = this.target.geometry;
    this.V = [new Vector3(), new Vector3(), new Vector3()];
    this.X = [new Vector4(), new Vector4(), new Matrix4()];
    this.M = [new Vector3(), new Vector3(), new Vector3()];
    this.isMorph = this.target.morphTargetInfluences ? true : false;
    this.isSkin = this.target.isSkinnedMesh ? true : false;
    this.init();
  }
  init() {
    if (this.geometry.attributes.position.count !== this.baseGeometry.attributes.position.count) {
      console.log("object not have same number of vertices !!");
      return;
    }
    this.length = this.baseGeometry.attributes.position.count;
    this.indexLength = this.baseGeometry.index.count / 3;
    this.originEdges = new Array(this.length).fill(0);
    this.targetEdges = new Array(this.length).fill(0);
    if (this.isSkin || this.isMorph) this.back = new Array(this.length * 3).fill(0);
    this.num = new Array(this.length).fill(0);
    this.getEdge(this.baseGeometry, this.originEdges);
    this.addColor();
    setTimeout(this.start.bind(this), 100);
  }
  start() {
    this.ready = true;
    this.update();
  }
  addColor() {
    const g2 = this.geometry;
    let lng = g2.attributes.position.array.length;
    g2.setAttribute("color", new Float32BufferAttribute(new Array(lng).fill(0), 3));
  }
  resetEdge(edges) {
    let j = edges.length;
    while (j--) edges[j] = 0;
  }
  getEdge(g2, edges, isSkin = false, isMorph = false) {
    let positions = g2.attributes.position.array;
    const indices = g2.index.array;
    let vA = this.V[0], vB = this.V[1], vC = this.V[2];
    let j, i = 0, a, b, c, ab, ac, bc;
    if (isMorph) positions = this.getMorph();
    if (isSkin) positions = this.getSkinned(positions);
    if (isSkin || isMorph) this.resetEdge(edges);
    j = this.indexLength;
    while (j--) {
      a = indices[i];
      b = indices[i + 1];
      c = indices[i + 2];
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      ab = vA.distanceTo(vB);
      ac = vA.distanceTo(vC);
      bc = vB.distanceTo(vC);
      edges[a] += (ab + ac) * 0.5;
      edges[b] += (ab + bc) * 0.5;
      edges[c] += (ac + bc) * 0.5;
      i += 3;
    }
  }
  isZero(v) {
    if (v.x === 0 && v.y === 0 && v.z === 0) return true;
    return false;
  }
  getMorph() {
    const morphInfluences = this.target.morphTargetInfluences;
    const morphRef = this.geometry.morphAttributes.position;
    const morphsMax = morphInfluences.length;
    const position = this.geometry.attributes.position.array;
    let lng = this.geometry.attributes.position.count, id, i, j;
    let vertex = this.M[0];
    let base = this.M[1];
    let temp = this.M[2];
    let relative = this.geometry.morphTargetsRelative;
    let data;
    i = lng;
    while (i--) {
      id = i * 3;
      base.fromArray(position, id);
      vertex.set(0, 0, 0);
      j = morphsMax;
      while (j--) {
        if (morphInfluences[j] != 0) {
          data = morphRef[j].data ? morphRef[j].data.array : morphRef[j].array;
          if (relative) vertex.addScaledVector(temp.fromArray(data, id), morphInfluences[j]);
          else vertex.addScaledVector(temp.fromArray(data, id).sub(base), morphInfluences[j]);
        }
      }
      base.add(vertex);
      base.toArray(this.back, id);
    }
    return this.back;
  }
  getSkinned(position) {
    const skeleton = this.target.skeleton;
    skeleton.boneMatrices;
    const geometry = this.geometry;
    const skinIndex = geometry.attributes.skinIndex.array;
    const skinWeigth = geometry.attributes.skinWeight.array;
    const bindMatrix = this.target.bindMatrix;
    const bindMatrixInverse = this.target.bindMatrixInverse;
    let vertex = this.V[0];
    let skin = this.V[1];
    let temp = this.V[2];
    let skinIndices = this.X[0];
    let skinWeights = this.X[1];
    let boneMatrix = this.X[2];
    let lng = geometry.attributes.position.count;
    let i, j, boneIndex, weight, id;
    i = lng;
    while (i--) {
      id = i * 3;
      skinIndices.fromArray(skinIndex, i * 4);
      skinWeights.fromArray(skinWeigth, i * 4);
      vertex.fromArray(position, id).applyMatrix4(bindMatrix);
      skin.set(0, 0, 0);
      j = 4;
      while (j--) {
        weight = skinWeights.getComponent(j);
        if (weight > 0) {
          boneIndex = skinIndices.getComponent(j);
          boneMatrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          skin.addScaledVector(temp.copy(vertex).applyMatrix4(boneMatrix), weight);
        }
      }
      skin.applyMatrix4(bindMatrixInverse);
      skin.toArray(this.back, id);
    }
    return this.back;
  }
  update() {
    if (!this.ready) return;
    this.getEdge(this.geometry, this.targetEdges, this.isSkin, this.isMorph);
    const color = this.geometry.attributes.color.array;
    let o, delta, n2, i = this.length;
    while (i--) {
      o = this.originEdges[i];
      delta = (o - this.targetEdges[i]) / o + 0.5;
      n2 = i * 3;
      color[n2] = delta > 0.5 ? (delta - 0.5) * 2 : 0;
      color[n2 + 1] = 0;
      color[n2 + 2] = delta < 0.5 ? 1 - delta * 2 : 0;
    }
    this.geometry.attributes.color.needsUpdate = true;
  }
};
var ExoSkeleton = class extends Object3D {
  constructor(object, skeleton) {
    super();
    this.isReady = false;
    this.skeleton = skeleton;
    this.bones = this.skeleton.bones;
    this.root = object;
    this.box = new BoxGeometry();
    this.mtxr = new Matrix4();
    this.mtx0 = new Matrix4();
    this.mtx1 = new Matrix4();
    this.mtx = new Matrix4();
    this.mtx2 = new Matrix4();
    this.p = new Vector3();
    this.s = new Vector3();
    this.q = new Quaternion();
    this.e = new Euler();
    this.mat = new MeshBasicMaterial({ color: 13421696, wireframe: true, toneMapped: false });
    this.init();
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    if (!this.isReady) return;
    let nodes = this.children;
    let i = nodes.length, node, bone;
    this.mtxr.copy(this.root.matrixWorld).invert();
    while (i--) {
      node = nodes[i];
      bone = node.userData.bone;
      this.mtx0.multiplyMatrices(this.mtxr, bone.matrixWorld);
      this.mtx.multiplyMatrices(this.mtx0, node.userData.decal);
      this.mtx.decompose(this.p, this.q, this.s);
      node.position.copy(this.p);
      node.quaternion.copy(this.q);
      node.updateMatrix();
    }
    super.updateMatrixWorld(force);
  }
  init() {
    this.mtxr.copy(this.root.matrixWorld).invert();
    const bones = this.bones;
    let p1 = new Vector3();
    let p2 = new Vector3();
    let i, lng = bones.length, name, n2, bone, parent;
    let size, dist, type, translate, rot, fx;
    for (i = 0; i < lng; i++) {
      type = null;
      bone = bones[i];
      name = bone.name;
      parent = bone.parent;
      if (parent) {
        n2 = parent.name;
        p1.setFromMatrixPosition(parent.matrixWorld);
        p2.setFromMatrixPosition(bone.matrixWorld);
        dist = p1.distanceTo(p2);
        translate = [0, 0, dist * 0.5];
        size = [dist, 1, 1];
        rot = [0, 0, 0];
        fx = "_C";
        if (n2 === "head" && name === "End_head") {
          type = "box";
          size = [0.16, 0.2, dist];
          translate = [0, 0.025, -dist * 0.5];
        }
        if (n2 === "chest" && name === "neck") {
          type = "box";
          size = [0.3, 0.28, dist];
          translate = [0, 0, -dist * 0.5];
        }
        if (n2 === "abdomen") {
          type = "box";
          size = [0.28, 0.24, dist + 0.14];
          rot[2] = 0;
          translate = [0, 0, -dist * 0.5];
          translate[2] += 0.07;
        }
        if (n2 === "rThigh") {
          type = "box";
          size = [0.15, 0.15, dist];
        }
        if (n2 === "lThigh") {
          type = "box";
          size = [0.15, 0.15, dist];
        }
        if (n2 === "rShin") {
          type = "box";
          size = [0.12, 0.12, dist + 0.1];
          translate[2] += 0.05;
        }
        if (n2 === "lShin") {
          type = "box";
          size = [0.12, 0.12, dist + 0.1];
          translate[2] += 0.05;
        }
        if (n2 === "rShldr") {
          type = "box";
          size = [dist + 0.06, 0.12, 0.12];
          translate[0] = -translate[2] + 0.03;
          translate[2] = 0;
        }
        if (n2 === "lShldr") {
          type = "box";
          size = [dist + 0.06, 0.12, 0.12];
          translate[0] = translate[2] - 0.03;
          translate[2] = 0;
        }
        if (n2 === "rForeArm") {
          type = "box";
          size = [dist + 0.1, 0.1, 0.1];
          translate[0] = -translate[2] - 0.05;
          translate[2] = 0;
        }
        if (n2 === "lForeArm") {
          type = "box";
          size = [dist + 0.1, 0.1, 0.1];
          translate[0] = translate[2] + 0.05;
          translate[2] = 0;
        }
        if (type !== null) this.addMesh(parent, type, size, translate, rot, fx);
      }
    }
    this.isReady = true;
  }
  addMesh(parent, type, size, translate, rot, fx) {
    this.mtx.makeTranslation(translate[0], translate[1], translate[2]);
    var mesh = new Mesh(this.box, this.mat);
    mesh.scale.fromArray(size);
    mesh.userData.decal = this.mtx.clone();
    mesh.userData.bone = parent;
    mesh.userData.size = size;
    this.add(mesh);
  }
  dispose() {
    this.children = [];
    this.box.dispose();
    this.mat.dispose();
    this.isReady = false;
  }
};
var setting$3 = {
  mixRatio: 0,
  threshold: 0.1,
  normal: 0.25,
  hair: 7675906,
  //0xa43412,
  bow: 1049602,
  sheen: 1,
  //2.25,
  sheenRoughness: 1,
  //1.0,
  metalness: 0.6,
  roughness: 0.4,
  vertexColors: false,
  alphaTest: 0.1,
  //0.3,
  h_metal: 0,
  //0.4,
  h_rough: 0.5,
  //0.6,
  clearcoat: 1,
  wireframe: false,
  transparent: false,
  opacity: 1
};
var Human = {
  refSize: 1.81,
  isBreath: false,
  isEyeMove: false,
  haveHair: true,
  haveBlink: true,
  haveMorph: true,
  morphNormal: false,
  morphRelative: false,
  haveLOD: true,
  levelHigh: ["body", "Head", "crane", "eyelash", "eyebrow", "tear", "eye_l", "eye_r", "eye_l_s", "eye_r_s"],
  levelHair: ["hair", "hair_man"],
  levelLow: ["body_low"],
  skeletonRef: "body",
  fullMorph: ["MUSCLE", "LOW", "BIG", "MONSTER"],
  //, 
  textureQuality: 1,
  textureRef: "avatar_c",
  texturePath: "assets/textures/avatar_",
  textures: [
    "avatar_c.jpg",
    "avatar_n.jpg",
    "avatar_t.jpg",
    //'avatar_m.jpg', 'avatar_r.jpg', 'avatar_u.jpg',
    "mouth_c.jpg",
    "mouth_a.jpg",
    "mouth_n.jpg",
    "eye_c.jpg",
    "eye_n.jpg",
    "hair.jpg",
    "hair_a.jpg",
    "eyelash_c.jpg",
    "eyelash_a.jpg",
    "eyelash_n.jpg",
    "hair_man.jpg",
    "hair_man_a.jpg",
    "avatar_ao.jpg"
  ],
  modelPath: "assets/models/avatar/",
  forceModel: null,
  setting: setting$3,
  materialRef: "skin",
  materials: {
    skin: {
      type: "Sss",
      map: "avatar_c",
      normalMap: "avatar_n",
      //envMapIntensity:0.7,
      //reflectivity:1.0,
      roughness: 0.54,
      metalness: 0.14,
      /*roughness:1,
      metalness:1,
      metalnessMap:'avatar_m',
      roughnessMap:'avatar_r',*/
      normalScale: new Vector2(setting$3.normal, -setting$3.normal),
      /*sheen:setting.sheen,
      sheenColor:0xFFFFFF,
      sheenRoughness:setting.sheenRoughness,
      sheenColorMap:'avatar_c',
      /*sheenColor:0xff0000,
      sheenColorMap:'avatar_u',
      iridescence:0.1,*/
      wireframe: setting$3.wireframe,
      aoMap: "avatar_ao",
      aoMapIntensity: 1,
      //ior:1.4,
      vertexColors: false,
      sssMap: "avatar_t",
      sssColor: new Color(15606563),
      sssAmbient: 0.5,
      sssDistortion: 0.6,
      sssAttenuation: 0.1,
      sssScale: 6
    },
    mouth: {
      type: "Standard",
      map: "mouth_c",
      roughness: 0.02,
      metalness: 0,
      vertexColors: false,
      //shadowSide: BackSide,
      //roughness:0.6,
      //metalness:0.6,
      alphaMap: "mouth_a",
      alphaTest: 0.5,
      normalMap: "mouth_n",
      normalScale: new Vector2(0.5, -0.5)
    },
    sub_eye: {
      type: "Physical",
      roughness: 0,
      //0.568,
      metalness: 1,
      ior: 1.376,
      opacity: 0.1,
      //blending:AdditiveBlending,
      clearcoat: 1,
      transparent: true
      //envMapIntensity:0,
      //wireframe:true
    },
    eye: {
      type: "Physical",
      map: "eye_c",
      roughness: 0.7,
      metalness: 0.15,
      normalMap: "eye_n",
      normalScale: new Vector2(2, -2),
      clearcoat: 0.25
      //clearcoatRoughness:0.5,
    },
    hair: {
      type: "Standard",
      //map:'hair',
      color: setting$3.hair,
      aoMap: "hair",
      metalnessMap: "hair",
      //bumpScale:-5,
      roughness: 0.6,
      //setting.h_rough,
      metalness: 1,
      //setting.h_metal,
      alphaMap: "hair_a",
      //alphaTest:setting.alphaTest,
      side: DoubleSide,
      emissive: setting$3.hair,
      emissiveIntensity: 0.5,
      //opacity:1.0,
      transparent: true,
      blending: CustomBlending,
      blendDst: ZeroFactor,
      blendDstAlpha: SrcAlphaFactor,
      //forceSinglePass:true,
      //alphaHash:true,
      //premultipliedAlpha:true,
      alphaToCoverage: true
    },
    hair_man: {
      type: "Standard",
      color: setting$3.hair,
      //map:'hair_man',
      aoMap: "hair_man",
      metalnessMap: "hair_man",
      roughness: 0.6,
      metalness: 1,
      //setting.h_metal,
      alphaMap: "hair_man_a",
      side: DoubleSide,
      //alphaTest:setting.alphaTest,
      //opacity:1.0,
      //emissive:setting.hair,
      //emissiveIntensity:0.5,
      //sheen:1.0,
      //sheenColor:setting.hair,
      //sheenRoughness:1.0,
      transparent: true,
      blending: CustomBlending,
      blendDst: ZeroFactor,
      blendDstAlpha: SrcAlphaFactor,
      forceSinglePass: true,
      //alphaHash:true,
      //premultipliedAlpha:true,
      alphaToCoverage: true
    },
    eyelash: {
      type: "Standard",
      color: setting$3.hair,
      map: "eyelash_c",
      //roughness:setting.h_rough,
      // metalness:setting.h_metal,
      alphaMap: "eyelash_a",
      //alphaTest:setting.alphaTest,
      transparent: true,
      opacity: 1,
      side: DoubleSide,
      alphaToCoverage: true,
      polygonOffset: true,
      polygonOffsetFactor: -4
      //normalMap:'eyelash_n',
      //normalScale:new Vector2( 1, -1)
    },
    tear: {
      type: "Standard",
      map: "eyelash_c",
      roughness: 0,
      metalness: 1,
      alphaMap: "eyelash_a",
      transparent: true,
      alphaToCoverage: true,
      opacity: 1
    },
    low: {
      type: "Basic"
      //color:0x000000,
      //wireframe: true,
    }
  },
  changeMaterial: (sx = {}, def = false) => {
    if (!Pool.getMaterial(Human.materialRef)) return;
    const s = Human.setting;
    const defMat = Human.materials;
    let change = false;
    for (let v in sx) {
      if (s[v] !== void 0) {
        if (s[v] !== sx[v]) {
          s[v] = sx[v];
          change = true;
        }
      }
    }
    let m2;
    if (change) {
      for (let key in defMat) {
        m2 = Pool.getMaterial(key);
        for (let v in sx) {
          if (m2[v] !== void 0) {
            if (def && defMat[key][v]) m2[v] = defMat[key][v];
            else m2[v] = sx[v];
          }
        }
      }
    }
  },
  applyMaterial: (root2, model2) => {
    const startHigh = true;
    const def = Pool.getMaterial("skin");
    root2.traverse((node) => {
      if (node.isMesh) {
        switch (node.name) {
          case "body":
            node.material = def;
            node.receiveShadow = true;
            node.castShadow = true;
            node.visible = startHigh;
            break;
          case "body_low":
            node.material = def;
            node.receiveShadow = true;
            node.castShadow = true;
            node.visible = false;
            break;
          case "Head":
            node.material = def;
            node.receiveShadow = true;
            node.castShadow = true;
            node.visible = startHigh;
            break;
          case "crane":
            node.material = def;
            node.receiveShadow = true;
            node.castShadow = false;
            node.visible = !Human.haveHair;
            break;
          case "mouth":
            node.material = Pool.getMaterial("mouth") || def;
            node.receiveShadow = true;
            node.castShadow = false;
            node.visible = startHigh;
            node.geometry.computeVertexNormals();
            break;
          case "eyelash":
          case "eyebrow":
            node.material = Pool.getMaterial("eyelash") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            node.visible = startHigh;
            break;
          case "tear":
            node.material = Pool.getMaterial("tear") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            node.visible = startHigh;
            break;
          case "eye_l":
          case "eye_r":
            node.material = Pool.getMaterial("eye") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            break;
          case "eye_l_s":
          case "eye_r_s":
            node.material = Pool.getMaterial("sub_eye") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            node.visible = startHigh;
            break;
          case "hair":
            node.material = Pool.getMaterial("hair") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            node.visible = Human.haveHair ? startHigh : false;
            break;
          case "hair_man":
            node.material = Pool.getMaterial("hair_man") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            node.visible = Human.haveHair ? startHigh : false;
            break;
        }
      }
    });
  },
  /*lowMode:( b ) => {
  
          if(b){
              setVisible()
          }
  
  
      },*/
  adjustment: () => {
    return [
      //{name:'head', values:[-10,0,0]},
      { name: "neck", values: [-5, 0, 0] },
      { name: "chest", values: [5, 0, 0] },
      { name: "lCollar", values: [0, 0, -10] },
      { name: "rCollar", values: [0, 0, 10] },
      { name: "lShldr", values: [-20, 2, 5] },
      { name: "rShldr", values: [-20, -2, -5] },
      //{name:'lShldr', values:[-5,2,0]},
      //{name:'rShldr', values:[-5,-2,0]},
      { name: "lForeArm", values: [0, 0, 10] },
      { name: "rForeArm", values: [0, 0, -10] },
      { name: "lHand", values: [0, 15, 10] },
      { name: "rHand", values: [0, -15, -10] },
      //{name:'lThumb1', values:[0,-15,0]},
      //{name:'rThumb1', values:[0,15,0]},
      { name: "lThumb2", values: [0, 25, 10] },
      { name: "rThumb2", values: [0, -25, -10] }
    ];
  }
};
var setting$2 = {
  wireframe: false,
  normal: 0.25,
  hair: 2433041
};
var Human_low = {
  isBreath: false,
  isEyeMove: false,
  haveMorph: true,
  skeletonRef: "body_low",
  fullMorph: ["MUSCLE", "LOW", "BIG", "MONSTER"],
  //haveQuality: true,
  //textureQuality:0,
  textureRef: "avatar_c_0k",
  texturePath: "assets/textures/avatar/",
  textures: ["avatar_c_0k.jpg", "avatar_n_0k.jpg", "avatar_ao_0k.jpg", "hair_man_a_0k.jpg", "Hair_01_c.png", "Hair_01_n.png"],
  modelPath: "assets/models/avatar/",
  forceModel: null,
  setting: setting$2,
  materialRef: "skin_low",
  materials: {
    skin_low: {
      //color:0xE24C00,
      type: "Standard",
      //Physical',
      map: "avatar_c_0k",
      aoMap: "avatar_ao_0k",
      normalMap: "avatar_n_0k",
      normalScale: new Vector2(setting$2.normal, -setting$2.normal),
      //normalMapType: ObjectSpaceNormalMap,
      //normalMapType:TangentSpaceNormalMap,
      envMapIntensity: 0.3,
      roughness: 0.22,
      metalness: 0,
      //reflectivity:0.05,
      vertexColors: false
      /*sheen:1.0,
      sheenColor:0x692000,
      sheenRoughness:0.5,**/
      //side:DoubleSide,
    },
    hair_low: {
      //color:0xE24C00,
      type: "Standard",
      color: setting$2.hair,
      alphaMap: "hair_man_a_0k",
      transparent: true
      //blending:CustomBlending,
      //blendDst:ZeroFactor,
      //blendDstAlpha:SrcAlphaFactor,
      //alphaToCoverage:true,
    },
    hair_low_2: {
      //color:0xE24C00,
      type: "Standard",
      color: setting$2.hair,
      map: "Hair_01_c",
      normalMap: "Hair_01_n"
    }
  },
  changeMaterial: (sx = {}, def = false) => {
    if (!Pool.getMaterial(Human_low.materialRef)) return;
    const defMat = Lee.materials;
    let m2;
    for (let key in defMat) {
      m2 = Pool.getMaterial(key);
      for (let v in sx) {
        if (m2[v] !== void 0) {
          if (def && defMat[key][v]) m2[v] = defMat[key][v];
          else m2[v] = sx[v];
        }
      }
    }
  },
  applyMaterial: (root2, model2) => {
    const def = Pool.getMaterial(Human_low.materialRef);
    root2.traverse((node) => {
      if (node.isMesh) {
        switch (node.name) {
          case "body_low":
            node.material = def;
            node.receiveShadow = true;
            node.castShadow = true;
            break;
          case "hair_low":
            node.material = Pool.getMaterial("hair_low") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            break;
          case "hair_low_2":
            node.material = Pool.getMaterial("hair_low_2") || def;
            node.receiveShadow = false;
            node.castShadow = false;
            break;
        }
      }
    });
  },
  adjustment: () => {
    return [
      { name: "neck", values: [-5, 0, 0] },
      { name: "chest", values: [5, 0, 0] },
      { name: "lCollar", values: [0, 0, -10] },
      { name: "rCollar", values: [0, 0, 10] },
      { name: "lShldr", values: [-20, 2, 0] },
      { name: "rShldr", values: [-20, -2, 0] }
    ];
  }
};
var setting$1 = {
  metalness: 0.33,
  roughness: 0.11,
  clearcoat: 0,
  wireframe: false
};
var Eva = {
  decalY: 0.02,
  isBreath: false,
  isEyeMove: false,
  haveMorph: false,
  skeletonRef: "eva_SKIN",
  fullMorph: [],
  haveQuality: false,
  skinRef: "eva_00",
  texturePath: "assets/textures/eva/",
  textures: ["eva00_c.jpg", "eva01_c.jpg", "eva02_c.jpg", "eva_l.jpg", "eva_ao.jpg"],
  modelPath: "assets/models/",
  forceModel: "eva",
  setting: setting$1,
  materialRef: "eva00",
  materials: {
    eva00: {
      type: "Physical",
      map: "eva00_c",
      emissiveMap: "eva_l",
      emissive: 16777215,
      roughness: setting$1.roughness,
      metalness: setting$1.metalness,
      wireframe: setting$1.wireframe,
      clearcoat: setting$1.clearcoat,
      //iridescence:0.5,
      aoMap: "eva_ao"
    },
    eva01: {
      type: "Physical",
      map: "eva01_c",
      emissiveMap: "eva_l",
      emissive: 16777215,
      roughness: setting$1.roughness,
      metalness: setting$1.metalness,
      wireframe: setting$1.wireframe,
      clearcoat: setting$1.clearcoat,
      //iridescence:0.5,
      aoMap: "eva_ao"
    },
    eva02: {
      type: "Physical",
      map: "eva02_c",
      emissiveMap: "eva_l",
      emissive: 16777215,
      roughness: setting$1.roughness,
      metalness: setting$1.metalness,
      wireframe: setting$1.wireframe,
      clearcoat: setting$1.clearcoat,
      //iridescence:0.5,
      aoMap: "eva_ao"
    }
  },
  changeMaterial: (sx, def = false) => {
    if (!Pool.getMaterial(Eva.materialRef)) return;
    const defMat = Eva.materials;
    let m2;
    for (let key in defMat) {
      m2 = Pool.getMaterial(key);
      for (let v in sx) {
        if (m2[v] !== void 0) {
          if (def && defMat[key][v]) m2[v] = defMat[key][v];
          else m2[v] = sx[v];
        }
      }
      m2.needsUpdate = true;
    }
  },
  applyMaterial: (root2, model2) => {
    const def = Pool.getMaterial(model2);
    root2.traverse((node) => {
      if (node.isMesh) {
        node.material = def;
        node.receiveShadow = true;
        node.castShadow = true;
        switch (node.name) {
          case "eva_2_head":
          case "eva_2_mach":
            node.visible = model2 === "eva02" ? true : false;
            break;
          case "eva_L_COLLAR":
          case "eva_R_COLLAR":
            node.visible = model2 === "eva00" ? false : true;
            break;
          case "eva_HEAD":
          case "eva_MACHOIR":
            node.visible = model2 === "eva01" ? true : false;
            break;
          case "eva_0_R_COLLAR":
          case "eva_0_L_COLLAR":
          case "eva_0_head":
          case "eva_0_head2":
            node.visible = model2 === "eva00" ? true : false;
            break;
          case "eva_0_CHEST2":
            node.visible = model2 === "eva01" ? false : true;
            break;
        }
      }
    });
  }
};
var setting = {
  metalness: 0.2,
  roughness: 0.8,
  wireframe: false
};
var Lee$1 = {
  decalY: -0.06,
  isBreath: false,
  isEyeMove: false,
  haveMorph: false,
  skeletonRef: "leeSkin",
  fullMorph: [],
  haveQuality: false,
  //skinRef:'leeSkin',
  texturePath: "assets/textures/",
  textures: ["lee_c.jpg", "lee_ao.jpg"],
  modelPath: "assets/models/",
  forceModel: "lee",
  setting,
  materialRef: "lee_material",
  materials: {
    lee_material: {
      type: "Physical",
      map: "lee_c",
      roughness: 0.3,
      metalness: 0.08,
      //aoMap: 'lee_ao',
      wireframe: setting.wireframe,
      sheen: 2.2,
      //emissive:0xFFFFFF,
      //emissiveMap:'lee_c',
      sheenColorMap: "lee_c",
      sheenColor: 16777215,
      sheenRoughness: 0.4,
      envMapIntensity: 1
      //aoMapIntensity:0.5,
      //emissiveIntensity:0.25,
    }
  },
  /*changeMaterial:( Setting ) => {
  
          const s = Lee.setting;
  
          if(Setting){
              for(let o in Setting){
                  if( s[o] !== undefined) s[o] = Setting[o]
              }
          }
          
          let m = Pool.getMaterial( 'lee_material' );
          m.roughness = s.roughness;
          m.metalness = s.metalness;
          m.wireframe = s.wireframe;
  
      },*/
  changeMaterial: (sx, def = false) => {
    if (!Pool.getMaterial(Lee$1.materialRef)) return;
    const defMat = Lee$1.materials;
    let m2;
    for (let key in defMat) {
      m2 = Pool.getMaterial(key);
      for (let v in sx) {
        if (m2[v] !== void 0) {
          if (def && defMat[key][v]) m2[v] = defMat[key][v];
          else m2[v] = sx[v];
        }
      }
    }
  },
  applyMaterial: (root2, model2) => {
    const def = Pool.getMaterial("lee_material");
    root2.traverse((node) => {
      if (node.isMesh) {
        node.material = def;
        node.receiveShadow = true;
        node.castShadow = true;
      }
    });
  },
  adjustment: () => {
    return [
      //{name:'lShldr', values:[0,-70,0]},
      { name: "lHand", values: [-60, 0, 0] },
      //{name:'rShldr', values:[0,70,0]},
      { name: "rHand", values: [-60, 0, 0] }
    ];
  }
};
var FrameTime = 30;
var TimeFrame = 1 / 30;
var torad$2 = Math.PI / 180;
var todeg = 180 / Math.PI;
var V = new Vector3();
var preloadAvatar = {
  tmp: [],
  model: [],
  avatar: null,
  callback: () => {
  },
  add: (names, callback) => {
    preloadAvatar.tmp = [...names];
    preloadAvatar.callback = callback;
    if (preloadAvatar.tmp.length) {
      preloadAvatar.loadOne();
    }
  },
  loadOne: () => {
    let name = preloadAvatar.tmp[0];
    preloadAvatar.avatar = new Avatar({ type: name, callback: preloadAvatar.next, morph: true, isPreload: true });
  },
  next: (name) => {
    preloadAvatar.avatar.dispose();
    preloadAvatar.tmp.shift();
    if (preloadAvatar.tmp.length === 0) {
      preloadAvatar.callback();
    } else {
      preloadAvatar.loadOne();
    }
  }
};
var Avatar = class extends Group {
  constructor(o = {}) {
    super();
    this.isPreload = o.isPreload || false;
    this.fixWeight = o.fixWeight !== void 0 ? o.fixWeight : true;
    this.rootPath = o.path || "./";
    this.lzmaPath = this.rootPath + "src/libs/lzma_worker.js";
    Pool.dracoPath = this.rootPath + "src/libs/draco/";
    this.callback = o.callback || function() {
    };
    this.matrixAutoUpdate = false;
    this.isPause = true;
    this.randomMorph = o.randomMorph || false;
    this.randomSize = o.randomSize || false;
    this.actionPose = null;
    this.model = o.type || "man";
    this.startAnimation = o.anim || "idle";
    this.bodyMorph = [0, 0];
    this.faceMorph = [0, 0];
    this.ref = null;
    switch (this.model) {
      case "lee":
        this.ref = Lee$1;
        break;
      case "man":
      case "woman":
        this.ref = Human;
        break;
      case "man_low":
      case "woman_low":
        this.ref = Human_low;
        break;
      case "eva00":
      case "eva01":
      case "eva02":
        this.ref = Eva;
        break;
    }
    this.compact = o.compact !== void 0 ? o.compact : true;
    this.haveMorph = o.morph !== void 0 ? o.morph : false;
    this.fullMaterial = o.material !== void 0 ? o.material : true;
    this.size = o.size || 1;
    this.realSize = 0;
    this.baseSize = 0;
    this.fullMorph = this.ref.fullMorph || [];
    if (this.randomMorph && this.fullMorph.length) this.haveMorph = true;
    this.textureQuality = this.ref.textureQuality || 0;
    this.skeleton = null;
    this.mixer = null;
    this.mesh = {};
    this.bones = {};
    this.done = false;
    this.isClone = false;
    this.isBreath = this.ref.isBreath || false;
    this.isEyeMove = this.ref.isEyeMove || false;
    this.haveBlink = this.ref.haveBlink || false;
    this.haveLOD = this.ref.haveLOD || false;
    if (o.noLOD) {
      this.ref.haveLOD = false;
      this.haveLOD = false;
    }
    this.lod = -1;
    this.decalY = this.ref.decalY || 0;
    this.tensionTest = false;
    this.tensionActive = false;
    this.fixToe = false;
    this.clipsToesFix = [];
    this.n = Math.round(Math.random() * 1e3);
    this.actions = /* @__PURE__ */ new Map();
    this.current = null;
    this.old = null;
    this.breath = 0;
    this.breathSide = -1;
    this.q = new Quaternion().setFromAxisAngle({ x: 0, y: 1, z: 0 }, Math.PI * 0.5);
    this.headBoneLook = new Vector3();
    this.eyeTarget = new Group();
    this.eyeTarget.position.set(0, 1, 0);
    this.tmpMtx = new Matrix4();
    this.tmpQ = new Quaternion();
    this.setting = {};
    this.root = Pool.get(this.ref.forceModel ? this.ref.forceModel : this.model, "O");
    if (this.root) {
      this.isClone = true;
      this.tensionTest = false;
      this.root = clone(this.root);
      this.init();
    } else {
      if (this.fullMaterial) this.load();
      else this.loadModels();
    }
  }
  rand(low = 0, high = 1) {
    return low + Math.random() * (high - low);
  }
  load() {
    if (!this.ref.textures || !this.ref.textures.length) {
      this.loadModels();
      return;
    }
    this.skin = Pool.getTexture(this.ref.textureRef, { quality: this.textureQuality });
    if (!this.skin) {
      const path = this.rootPath + this.ref.texturePath + (this.textureQuality ? this.textureQuality + "k/" : "");
      Pool.load(this.ref.textures, this.loadModels.bind(this), path, "loading images...", this.textureQuality);
    } else {
      this.loadModels();
    }
  }
  loadModels() {
    const model2 = this.ref.forceModel ? this.ref.forceModel : this.model;
    const asset = [model2 + ".glb"];
    const path = this.rootPath + this.ref.modelPath;
    if (this.ref.haveMorph && this.haveMorph) asset.push(model2 + "_morph.glb");
    Pool.load(asset, this.init.bind(this), path, "loading models...");
  }
  update(delta) {
    if (!this.done) return;
    if (this.mixer) {
      this.mixer.update(delta);
      if (this.haveBlink) this.eyeBlink();
      if (!this.isClone) {
        this.look(delta * 10);
        this.breathing();
        this.autoToes();
      }
      if (this.tensionActive) {
        this.tension1.update();
        this.tension2.update();
      }
      if (this.actionPose) {
        this.actionPose.setEffectiveWeight(this.getAction("idle")._effectiveWeight);
      }
      if (window.gui && window.gui.updateTimeBarre && this.current) {
        window.gui.updateTimeBarre(Math.round(this.current.time * FrameTime), this.current.frameMax);
      }
    }
  }
  eyeBlink() {
    const n2 = this.n++;
    let v = 0;
    let t2 = 10;
    let s = 1 / t2;
    if (n2 <= t2) v = n2 * s;
    if (n2 > t2 && n2 <= t2 * 2) v = 1 - (n2 - t2) * s;
    if (this.n > 500) {
      this.n = 0;
    }
    this.setMorph("EyeBlink", v);
  }
  look(delta) {
    if (!this.isEyeMove) return;
    if (this.isPause) return;
    const v = window.mouse || { x: 0, y: 0 };
    if (delta > 1) delta = 1;
    this.headBoneLook.lerp({ x: -(v.y * 20) * torad$2, y: 0, z: -(v.x * 20) * torad$2 }, delta);
    this.eyeTarget.position.lerp({ x: v.x * 0.5, y: 1, z: -v.y * 0.25 }, delta);
    let e = this.headBoneLook;
    this.tmpQ.setFromEuler({ _x: e.x, _y: e.y, _z: e.z, _order: "XYZ" }, false);
    this.bones.head.quaternion.multiply(this.tmpQ);
    let ER = this.bones.ER;
    let EL = this.bones.EL;
    let up = { x: 0, y: 0, z: 1 };
    this.tmpMtx.lookAt(EL.position, this.eyeTarget.position.clone().add({ x: 0.03, y: 0, z: -0.074 }), up);
    EL.quaternion.setFromRotationMatrix(this.tmpMtx).multiply(this.q);
    this.tmpMtx.lookAt(ER.position, this.eyeTarget.position.clone().add({ x: -0.03, y: 0, z: -0.074 }), up);
    ER.quaternion.setFromRotationMatrix(this.tmpMtx).multiply(this.q);
  }
  breathing() {
    if (!this.bones) return;
    if (!this.isBreath) return;
    if (!this.skeleton.setScalling) return;
    let a = this.breath * 0.01;
    if (this.breathSide > 0) {
      this.skeleton.setScalling(this.bones.chest, this.lerp(1, 1.02, a), this.lerp(1, 1.04, a), 1);
      this.skeleton.setScalling(this.bones.abdomen, 1, this.lerp(1, 0.92, a), 1);
    } else {
      this.skeleton.setScalling(this.bones.chest, this.lerp(1.02, 1, a), this.lerp(1.04, 1, a), 1);
      this.skeleton.setScalling(this.bones.abdomen, 1, this.lerp(0.92, 1, a), 1);
    }
    this.breath++;
    if (this.breath === 100) {
      this.breath = 0;
      this.breathSide = this.breathSide > 0 ? -1 : 1;
    }
  }
  setPosition(x2, y, z) {
    this.position.set(x2, y, z);
    this.updateMatrix();
  }
  setRotation(x2, y, z, a) {
    let r = this.lerp(this.rotation.y, y, a);
    this.rotation.set(x2, r, z);
    this.updateMatrix();
  }
  lerp(x2, y, t2) {
    return (1 - t2) * x2 + t2 * y;
  }
  onReady() {
  }
  initMaterial() {
    if (Pool.getMaterial(this.ref.materialRef)) return;
    if (!this.fullMaterial) {
      Pool.set(this.ref.materialRef, new MeshStandardMaterial());
      return;
    }
    let m2, type, data;
    for (const name in this.ref.materials) {
      data = { ...this.ref.materials[name] };
      type = data.type;
      delete data.type;
      for (const t2 in data) {
        if (t2 !== "envMapIntensity" && t2 !== "normalMapType" && t2 !== "aoMapIntensity" && t2 !== "aoMapIntensity") {
          if (t2 === "map" || t2.search("Map") !== -1) data[t2] = Pool.getTexture(data[t2], { quality: this.textureQuality });
        }
      }
      if (type === "Basic") m2 = new MeshBasicMaterial(data);
      else if (type === "Standard") m2 = new MeshStandardMaterial(data);
      else if (type === "Physical") m2 = new MeshPhysicalMaterial(data);
      else if (type === "Sss") m2 = new MeshSssMaterial(data);
      m2.name = name;
      Pool.set(name, m2);
    }
    this.setting = this.ref.setting;
  }
  setMaterial(s, b) {
    let m2 = Pool.getMaterial(this.ref.materialRef);
    if (!m2) return;
    for (let p2 in s) {
      if (m2[p2] !== void 0) m2[p2] = s[p2];
    }
  }
  setMaterialNormal(v) {
    let m2 = Pool.getMaterial("skin");
    if (!m2) return;
    if (v < 0) v = 0;
    m2.normalScale.set(v, -v);
  }
  getMaterial(name) {
    return Pool.getMaterial(name);
  }
  init() {
    this.initMaterial();
    if (!this.isClone) {
      this.root = Pool.get(this.ref.forceModel ? this.ref.forceModel : this.model, "O");
      this.ref.applyMaterial(this.root, this.model);
    }
    if (this.ref.forceModel && this.isClone) this.ref.applyMaterial(this.root, this.model);
    this.realSize = 0;
    this.root.traverse((function(node) {
      node.raycast = function() {
        return;
      };
      if (node.isMesh) {
        if (node.name === this.ref.skeletonRef) {
          node.matrixAutoUpdate = false;
          this.skeleton = node.skeleton;
          if (this.skeleton.resetScalling) this.skeleton.resetScalling();
          this.realSize = node.geometry.boundingBox.max.y;
        }
        if (node.name === "Head") this.realSize = node.geometry.boundingBox.max.y;
        this.mesh[node.name] = node;
      }
      if (node.isBone) {
        this.bones[node.name] = node;
      }
    }).bind(this));
    this.realSizeRatio = 1 / this.realSize;
    this.baseSize = this.realSize;
    if (this.ref.isEyeMove) {
      this.bones.neck.add(this.eyeTarget);
    }
    for (let m2 in this.mesh) {
      if (this.mesh[m2].isSkinnedMesh && m2 !== this.ref.skeletonRef) {
        this.mesh[m2].skeleton = this.skeleton;
      }
    }
    if (!this.isClone) {
      if (this.haveMorph) Pool.applyMorph(this.model + "_morph", this.mesh, this.ref.morphNormal, this.ref.morphRelative);
      Pool.set(this.model, this.root, "O");
    }
    if (this.size !== 1) this.root.scale.set(1, 1, 1).multiplyScalar(this.size);
    this.mixer = new AnimationMixer(this);
    if (Pool.clip.length === 0) {
      if (this.compact) this.loadCompactAnimation(this.rootPath + "assets/animation/animations.bin");
      else this.loadAnimationJson(this.rootPath + "assets/animation/animations.json", this.start.bind(this));
    } else {
      let i = Pool.clip.length;
      while (i--) this.addAction(Pool.clip[i]);
      this.start();
    }
  }
  setRealSize(s) {
    this.realSize = s;
    let r = 0.5 + this.baseSize / this.realSize * 0.5;
    this.setSize(this.realSize * this.realSizeRatio);
    this.setHeadSize(r);
  }
  setSize(s) {
    this.size = s;
    this.root.scale.set(1, 1, 1).multiplyScalar(this.size);
  }
  setHeadSize(s) {
    this.bones.head.scale.set(1, 1, 1).multiplyScalar(s);
  }
  addTensionMap() {
    this.tension1 = new Tension(this.mesh.body);
    this.tension2 = new Tension(this.mesh.Head);
  }
  setBounding(r) {
    for (let m2 in this.mesh) {
      if (this.mesh[m2].isMesh) {
        this.mesh[m2].geometry.boundingSphere.radius = r;
      }
    }
  }
  /*setBoneScale( v ){
  
          const ingnor = [ 'head', 'lToes', 'rToes', 'rCollar', 'lCollar', 'rBreast', 'lBreast', 'neck'];
          const center = ['hip', 'abdomen', 'chest'];
          const legs = ['lThigh', 'rThigh', 'lShin', 'rShin'];
          const b = this.bones
  
          for( let n in b ){
              if(ingnor.indexOf(n) === -1) {
                  if(center.indexOf(n) !== -1) b[n].scalling.z = v
                  else if(legs.indexOf(n) !== -1) b[n].scalling.z = v
                  else if( n === 'root' ) b[n].scalling.y = v
                  else if( n === 'rFoot' || n === 'lFoot') b[n].scalling.y = v
                  else b[n].scalling.x = v
              } 
          }
  
          this.setBounding(v)
      }*/
  setLevel(n2) {
    if (!this.haveLOD) return;
    if (this.lod === n2) return;
    this.lod = n2;
    this.hideAll();
    if (this.lod === 0) this.setVisible(this.ref.levelLow, true);
    else {
      this.setVisible(this.ref.levelHigh, true);
      if (this.ref.haveHair) {
        this.setVisible(this.ref.levelHair, true);
      }
    }
  }
  hideAll() {
    for (let m2 in this.mesh) this.mesh[m2].visible = false;
  }
  setVisible(names, v) {
    if (typeof names === "string") names = [names];
    let i = names.length, name;
    while (i--) {
      name = names[i];
      if (this.mesh[name]) this.mesh[name].visible = v;
    }
  }
  /*eyeControl( v ){
  
          this.setMorph('EyeBlink', v)
      
      }*/
  setMorph(name, v) {
    v = v < 0 ? 0 : v;
    if (!this.haveMorph) return;
    this.morpher("eyelash", name, v);
    this.morpher("eyebrow", name, v);
    this.morpher("tear", name, v);
    this.morpher("mouth", name, v);
    this.morpher("body", name, v);
    this.morpher("Head", name, v);
    this.morpher("body_low", name, v);
  }
  morpher(obj, name, value) {
    if (!this.mesh[obj]) return;
    if (!this.mesh[obj].morphTargetInfluences) return;
    if (this.mesh[obj].morphTargetDictionary[name] === void 0) return;
    this.mesh[obj].morphTargetInfluences[this.mesh[obj].morphTargetDictionary[name]] = value;
  }
  lerp(x2, y, t2) {
    return (1 - t2) * x2 + t2 * y;
  }
  clone(o) {
    return new this.constructor({ type: o.type }, this);
  }
  dispose() {
    if (this.exoskel) this.addExo();
    if (this.helper) this.addHelper();
    this.stop();
    this.mixer.uncacheRoot(this);
    this.remove(this.root);
    this.skeleton.dispose();
    if (this.parent) this.parent.remove(this);
    if (!this.isClone) ;
  }
  start() {
    if (this.isPreload) {
      this.callback();
      return;
    }
    if (this.done) return;
    this.done = true;
    this.onReady();
    this.play(this.startAnimation);
    if (this.ref.adjustment) {
      this.makePoseTrack("adjustment", this.ref.adjustment(), true);
    }
    if (this.randomMorph) this.setBodyMorph([this.rand(-1, 1), this.rand(-1, 1)]);
    if (this.randomSize) this.setRealSize(this.rand(1, 2));
    setTimeout((function() {
      this.add(this.root);
      this.callback();
    }).bind(this), 100);
  }
  setBodyMorph(v) {
    if (!this.haveMorph) return;
    if (v) this.bodyMorph = v;
    let vx = Number(this.bodyMorph[0]);
    let vy = Number(this.bodyMorph[1]);
    this.setMorph("MUSCLE", vy < 0 ? -vy : 0);
    this.setMorph("LOW", vy >= 0 ? vy : 0);
    this.setMorph("BIG", vx < 0 ? -vx : 0);
    this.setMorph("MONSTER", vx >= 0 ? vx : 0);
    let cx = (vx + 1) * 0.5;
    let cy = 1 - (vy + 1) * 0.5;
    this.setMaterialNormal((cy + cx) * 0.5);
  }
  setFaceMorph(v) {
    if (!this.haveMorph) return;
    if (v) this.faceMorph = v;
    let vx = Number(this.faceMorph[0]);
    let vy = Number(this.faceMorph[1]);
    this.setMorph("Shock", vy < 0 ? -vy : 0);
    this.setMorph("Frown", vy >= 0 ? vy : 0);
    this.setMorph("SmileOpen", vx < 0 ? -vx : 0);
    this.setMorph("Angry", vx >= 0 ? vx : 0);
  }
  addHelper() {
    if (this.helper) {
      this.helper.dispose();
      this.remove(this.helper);
      this.helper = null;
    } else {
      this.helper = new SkeletonHelper(this.root);
      this.helper.raycast = function() {
        return;
      };
      this.helper.matrix = this.root.matrix;
      this.add(this.helper);
    }
  }
  addExo() {
    if (this.exoskel) {
      this.exoskel.dispose();
      this.remove(this.exoskel);
      this.exoskel = null;
    } else {
      this.exoskel = new ExoSkeleton(this.root, this.skeleton);
      this.exoskel.matrix = this.root.matrix;
      this.add(this.exoskel);
    }
    return this.exoskel;
  }
  attachToBone(m2, b) {
    m2.matrix = b.matrixWorld;
    m2.matrixAutoUpdate = false;
  }
  loadAnimationJson(url2, callback) {
    const request = new XMLHttpRequest();
    request.open("GET", url2, true);
    request.onreadystatechange = (function() {
      if (request.readyState === 4) {
        if (request.status === 200 || request.status === 0) {
          let data = JSON.parse(request.responseText);
          this.urls = [];
          for (let g2 in data) {
            if (g2 === "main") this.urls.push(...data[g2]);
            else this.urls.push(...data[g2].map((x2) => g2 + "/" + x2));
          }
          this.endCallback = callback || function() {
          };
          this.loadOne();
        }
      }
    }).bind(this);
    request.send();
  }
  loadOne() {
    let name = this.urls[0];
    this.loadAnimationFbx(this.rootPath + "assets/animation/fbx/" + name + ".fbx", this.next.bind(this));
  }
  next() {
    this.urls.shift();
    if (this.urls.length === 0) this.endCallback();
    else this.loadOne();
  }
  loadCompactAnimation(url2 = "./assets/models/animations.bin") {
    var request = new XMLHttpRequest();
    request.open("GET", url2, true);
    request.responseType = "arraybuffer";
    const glb = { animations: [] };
    const self2 = this;
    request.onload = function() {
      LZMA.decompress(request.response, (result) => {
        const data = JSON.parse(result);
        for (let c in data) glb.animations.push(AnimationClip.parse(data[c]));
        self2.applydAnimation(glb);
        self2.start();
      });
    };
    request.send();
  }
  loadAnimationGlb(url2, callback) {
    let name = url2.substring(url2.lastIndexOf("/") + 1, url2.lastIndexOf("."));
    Pool.loaderGLTF().load(url2, (function(glb) {
      this.applydAnimation(glb, name);
      if (callback) callback();
    }).bind(this), null, callback);
  }
  directGlb(data, name) {
    Pool.loaderGLTF().parse(data, "", (function(glb) {
      this.stop();
      this.applydAnimation(glb, name);
    }).bind(this));
  }
  loadAnimationFbx(url2, callback) {
    let name = url2.substring(url2.lastIndexOf("/") + 1, url2.lastIndexOf("."));
    Pool.loaderFBX().load(url2, (function(node) {
      this.convertFbx(name, node.animations[0]);
      if (callback) callback();
    }).bind(this), null, callback);
  }
  directFbx(data, name) {
    try {
      let node = Pool.loaderFBX().parse(data, "");
      this.convertFbx(name, node.animations[0], true);
    } catch (e) {
      console.error("bug", e);
    }
  }
  applydAnimation(glb, name) {
    let i = glb.animations.length, autoplay = false;
    if (i === 1) {
      if (name) glb.animations[0].name = name;
      autoplay = true;
    }
    while (i--) {
      this.addClip(glb.animations[i]);
      this.addAction(glb.animations[i], autoplay);
    }
  }
  addClip(clip, additive = false) {
    if (additive) {
      AnimationUtils.makeClipAdditive(clip);
    }
    let i = Pool.clip.length, removeId = -1;
    while (i--) {
      if (Pool.clip[i].name === clip.name) removeId = i;
    }
    if (removeId !== -1) Pool.clip.slice(removeId, 1);
    Pool.clip.push(clip);
  }
  addAction(clip, play) {
    const action = this.mixer.clipAction(clip);
    action.frameMax = Math.round(clip.duration * FrameTime);
    action.play();
    action.enabled = true;
    if (clip.name.search("idle") !== -1) action.enabled = true;
    if (clip.name === "Jumping Up") action.loop = LoopPingPong;
    this.actions.set(clip.name, action);
    if (window.gui && window.gui.getAnimation) window.gui.getAnimation();
  }
  /// EXPORT
  getAnimation(toJson = false, fromPool = false) {
    let anim = [], n2 = 0;
    if (fromPool) {
      let i = Pool.clip.length;
      while (i--) {
        if (toJson) anim[n2] = Pool.clip[n2].toJSON();
        else anim[n2] = Pool.clip[n2];
        n2++;
      }
    } else {
      this.actions.forEach(function(action, key) {
        if (toJson) anim[n2] = action._clip.toJSON();
        else anim[n2] = action._clip;
        n2++;
      });
    }
    return anim;
  }
  exportAnimationLzma(callback) {
    if (!this.lzma) this.lzma = new LZMA(this.lzmaPath);
    const data = this.getAnimation(true);
    this.lzma.compress(JSON.stringify(data), 2, function(result) {
      if (callback) callback({ name: "animations", data: new Uint8Array(result), type: "bin" });
      else {
        let link = document.createElement("a");
        link.style.display = "none";
        document.body.appendChild(link);
        link.href = URL.createObjectURL(new Blob([new Uint8Array(result)], { type: "application/octet-stream" }));
        link.download = "animations.bin";
        link.click();
      }
    });
  }
  exportGLB(callback) {
    if (!this.exporter) this.exporter = new GLTFExporter();
    const animations = this.getAnimation();
    this.exporter.parse(this.root, function(gltf) {
      if (callback) callback({ name: "model", data: gltf, type: "glb" });
      else {
        let link = document.createElement("a");
        link.style.display = "none";
        document.body.appendChild(link);
        link.href = URL.createObjectURL(new Blob([gltf], { type: "application/octet-stream" }));
        link.download = "model.glb";
        link.click();
      }
    }, null, { animations, binary: true, onlyVisible: true });
  }
  armAngle() {
  }
  autoToes() {
    if (!this.fixToe) return;
    let r = this.getRot("rFoot");
    let l = this.getRot("lFoot");
    let v = this.getWorldPos("hip");
    let v0 = this.getWorldPos("rToes");
    let v1 = this.getWorldPos("lToes");
    if (r[0] > 0 && v0.z - v.z < 0) this.setRot("rToes", -r[0] * 1.5, 0, 0);
    else if (r[0] !== 0) this.setRot("rToes", 0, 0, 0);
    if (l[0] > 0 && v1.z - v.z < 0) this.setRot("lToes", -l[0] * 1.5, 0, 0);
    else if (l[0] !== 0) this.setRot("lToes", 0, 0, 0);
  }
  resetToes() {
    if (!this.fixToe) return;
    this.fixToe = false;
    this.setRot("rToes", 0, 0, 0);
    this.setRot("lToes", 0, 0, 0);
  }
  convertFbx(name, anim, autoplay) {
    const torad2 = Math.PI / 180;
    let p2 = new Vector3();
    let q = new Quaternion();
    let RX = new Quaternion().setFromAxisAngle({ x: 1, y: 0, z: 0 }, 90 * torad2);
    const baseTracks = anim.tracks;
    const tracks = [];
    let i = baseTracks.length, j, n2, t2, b, k = 0;
    while (i--) {
      t2 = baseTracks[k];
      b = t2.name.substring(0, t2.name.lastIndexOf("."));
      if (t2.name === "hip.position") {
        let rp = [];
        j = t2.values.length / 3;
        while (j--) {
          n2 = j * 3;
          p2.set(t2.values[n2], t2.values[n2 + 1], 0).multiplyScalar(0.01);
          p2.toArray(rp, n2);
        }
        tracks.push(new VectorKeyframeTrack(t2.name, t2.times, rp));
      } else {
        let rq = [];
        j = t2.values.length / 4;
        while (j--) {
          n2 = j * 4;
          if (b === "hip") q.set(t2.values[n2], t2.values[n2 + 1], t2.values[n2 + 2], t2.values[n2 + 3]).multiply(RX);
          else q.set(t2.values[n2], t2.values[n2 + 2], -t2.values[n2 + 1], t2.values[n2 + 3]);
          q.toArray(rq, n2);
        }
        tracks.push(new QuaternionKeyframeTrack(t2.name, t2.times, rq));
      }
      k++;
    }
    let clip = new AnimationClip(name, -1, tracks);
    clip.duration = anim.duration;
    this.stop();
    this.addClip(clip);
    this.addAction(clip, autoplay);
  }
  makePoseTrack(name, data, isAdd2 = false) {
    const torad2 = Math.PI / 180;
    let q = new Quaternion();
    const baseTracks = data;
    const tracks = [];
    let i = baseTracks.length, j, n2, n22, t2, k = 0;
    let numFrame = 3;
    while (i--) {
      t2 = baseTracks[i];
      t2.name;
      let rq = [];
      let tt2 = [];
      k = 0;
      j = numFrame;
      while (j--) {
        n2 = 0;
        n22 = k * 4;
        tt2.push(k * 0.03333333507180214);
        q.setFromEuler({ _x: t2.values[n2] * torad2, _y: t2.values[n2 + 1] * torad2, _z: t2.values[n2 + 2] * torad2, _order: "XYZ" });
        q.toArray(rq, n22);
        k++;
      }
      tracks.push(new QuaternionKeyframeTrack(t2.name + ".quaternion", tt2, rq));
    }
    let blendMode = isAdd2 ? AdditiveAnimationBlendMode : NormalAnimationBlendMode;
    let clip = new AnimationClip(name, -1, tracks, blendMode);
    clip.duration = numFrame * 0.03333333507180214;
    const action = this.mixer.clipAction(clip);
    action.enabled = true;
    action.setEffectiveTimeScale(1);
    action.setEffectiveWeight(1);
    action.play();
    this.actionPose = action;
  }
  //---------------------
  //
  //  ANIMATION CONTROL
  //
  //---------------------
  prepareCrossFade(startAction, endAction, duration) {
    this.isPause = false;
    this.unPause();
    if (endAction._clip.name !== "idle") {
      this.executeCrossFade(startAction, endAction, duration);
    } else {
      this.synchronizeCrossFade(startAction, endAction, duration);
    }
  }
  synchronizeCrossFade(startAction, endAction, duration) {
    this.mixer.addEventListener("loop", onLoopFinished);
    const self2 = this;
    function onLoopFinished(event) {
      if (event.action === startAction) {
        self2.mixer.removeEventListener("loop", onLoopFinished);
        self2.executeCrossFade(startAction, endAction, duration);
      }
    }
  }
  executeCrossFade(startAction, endAction, duration, warping = true) {
    this.setWeight(endAction, 1);
    endAction.time = 0;
    startAction.crossFadeTo(endAction, duration, true);
  }
  pause() {
    this.actions.forEach(function(action) {
      action.paused = true;
    });
    this.isPause = true;
  }
  unPause() {
    this.actions.forEach(function(action) {
      action.paused = false;
    });
    this.isPause = false;
  }
  playAll() {
    this.actions.forEach(function(action) {
      action.play();
    });
  }
  setTimescale(timescale) {
    this.actions.forEach(function(action) {
      action.setEffectiveTimeScale(timescale);
    });
  }
  syncro(name) {
    let action = this.getAction(name);
    if (!action) return;
    let time = action.time;
    this.actions.forEach(function(action2) {
      action2.time = time;
    });
  }
  /*setTimescale( action, timescale ) {
  
          action.enabled = true;
          action.setEffectiveTimeScale( timescale );
  
      }*/
  setWeight(action, weight) {
    action.enabled = true;
    if (weight < 0) weight = 0;
    if (weight > 1) weight = 1;
    action.setEffectiveWeight(weight);
  }
  getAnimInfo(name) {
    let action = this.getAction(name);
    if (!action) return;
    return {
      name,
      time: action.time,
      frame: Math.round(action.time * FrameTime),
      frameMax: action.frameMax,
      timeScale: action.timeScale
    };
  }
  getAction(name) {
    return this.actions.get(name);
  }
  play(name, fade = 0.5) {
    let action = this.getAction(name);
    if (!action) return false;
    if (!this.current) {
      this.stop();
      this.current = action;
      action.setEffectiveWeight(1);
    } else {
      if (this.current !== action) {
        this.old = this.current;
        this.current = action;
        let isIdle = this.current.getClip().name === "idle";
        isIdle = this.old.getClip().name === "idle";
        if (this.clipsToesFix.indexOf(name) !== -1) this.fixToe = true;
        else this.resetToes();
        let oldEff = this.old.getEffectiveWeight();
        let currentEff = this.current.getEffectiveWeight();
        let time = this.current.time;
        if (!isIdle) {
          let ratio = this.current.getClip().duration / this.old.getClip().duration;
          time = this.old.time * ratio;
        }
        this.current.reset();
        this.current.time = time;
        if (this.fixWeight) {
          this.current.weight = 1;
          this.current.stopFading();
          this.old.stopFading();
          this.old._scheduleFading(fade, oldEff, 0);
          this.current._scheduleFading(fade, currentEff, 1);
        } else {
          this.executeCrossFade(this.old, this.current, fade);
        }
      }
    }
    this.isPause = false;
    return true;
  }
  playFrame(name, frame, weight = 1) {
    let action = this.getAction(name);
    if (!action) return;
    action.time = frame * TimeFrame;
    action.setEffectiveWeight(weight);
    action.play();
    action.paused = true;
    this.isPause = true;
  }
  playOne(frame, weight = 1) {
    if (!this.current) return;
    this.current.time = frame * TimeFrame;
    this.current.setEffectiveWeight(weight);
    this.current.play();
    this.current.paused = true;
    this.isPause = true;
  }
  stop() {
    this.actions.forEach(function(action) {
      action.setEffectiveWeight(0);
    });
  }
  // bone control
  setRot(name, x2, y, z) {
    let n2 = this.bones[name];
    if (!n2) return;
    n2.rotation.set(x2 * torad$2, y * torad$2, z * torad$2, "XYZ");
    n2.updateMatrix();
  }
  setRot2(name, x2, y, z) {
    let n2 = this.bones[name];
    if (!n2) return;
    let q2 = new Quaternion().setFromEuler({ _x: x2 * todeg, _y: y * todeg, _z: z * todeg, _order: "XYZ" }).invert();
    n2.quaternion.premultiply(q2);
    n2.updateMatrix();
  }
  getRot(name) {
    let n2 = this.bones[name];
    if (!n2) return;
    let r = n2.rotation.toArray();
    return [Math.round(r[0] * todeg), Math.round(r[1] * todeg), Math.round(r[2] * todeg)];
  }
  getWorldPos(name) {
    let n2 = this.bones[name];
    if (!n2) return;
    V.set(0, 0, 0);
    n2.localToWorld(V);
    return { x: V.x, y: V.y, z: V.z };
  }
  //---------------------
  //  HIDE PART OF BODY
  //---------------------
  bodyMask(o = { arm: true, leg: true, foot: true, chest: true }) {
    let s = 0.25;
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
      this.canvas.width = this.canvas.height = 1024 * s;
    }
    const ctx = this.canvas.getContext("2d");
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, 1024 * s, 1024 * s);
    ctx.fillStyle = "black";
    if (o.arm) ctx.fillRect(784 * s, 448 * s, 236 * s, 186 * s);
    if (o.leg) ctx.fillRect(512 * s, 734 * s, 287 * s, 290 * s);
    if (o.foot) ctx.fillRect(817 * s, 822 * s, 206 * s, 200 * s);
    if (o.chest) {
      ctx.fillRect(480 * s, 576 * s, 300 * s, 160 * s);
      ctx.fillRect(553 * s, 466 * s, 228 * s, 110 * s);
      ctx.fillRect(533 * s, 531 * s, 20 * s, 45 * s);
    }
    let img = new Image();
    img.src = this.canvas.toDataURL();
    if (this.mask) this.mask.dispose();
    this.mask = new Texture(img);
    this.mask.flipY = false;
    this.mask.needsUpdate = true;
    const m2 = Pool.getMaterial("skin");
    m2.alphaTest = 0.9;
    m2.alphaMap = this.mask;
  }
  //---------------------
  //   TOOLS
  //---------------------
  zeroColor(g2) {
    if (g2.isMesh) g2 = g2.geometry;
    let lng = g2.attributes.position.array.length;
    g2.setAttribute("color", new Float32BufferAttribute(new Array(lng).fill(0), 3));
  }
  /*uv2( g, uv2 = true, tangent = true ) {
  
          if( g.isMesh ) g = g.geometry;
          g.setAttribute( 'uv2', g.attributes.uv );
  
      }*/
};
var Hero = class extends Basic3D {
  constructor(o = {}) {
    super();
    this.isCharacter = true;
    this.isPlayer = false;
    this.enable = false;
    this.useImpulse = o.useImpulse || false;
    this.useFloating = o.floating || false;
    this.waitRotation = false;
    let floatHeight = 0.3;
    let radius = o.radius || 0.3;
    let height = o.height || 1.8;
    this.realHeight = height;
    if (this.useFloating) {
      height -= floatHeight;
    }
    this.option = {
      debug: false,
      capsuleHalfHeight: height * 0.5,
      capsuleRadius: radius,
      floatHeight,
      characterInitDir: 0,
      // in rad
      //followLight: false,
      // Follow camera setups
      camInitDis: -5,
      camMaxDis: -7,
      camMinDis: -0.7,
      // Base control setups
      maxVelLimit: 5,
      //2.5,
      turnVelMultiplier: 0.2,
      turnSpeed: 15,
      sprintMult: 2,
      jumpVel: 4,
      jumpForceToGroundMult: 5,
      slopJumpMult: 0.25,
      sprintJumpMult: 1.2,
      airDragMultiplier: 0.2,
      dragDampingC: 0.15,
      accDeltaTime: 8,
      rejectVelMult: 4,
      moveImpulsePointY: 0.5,
      camFollowMult: 11,
      fallingGravityScale: 2.5,
      fallingMaxVel: -20,
      wakeUpDelay: 200,
      // Floating Ray setups
      rayOriginOffest: { x: 0, y: -height * 0.5, z: 0 },
      rayHitForgiveness: 0.1,
      rayLength: radius + 2,
      rayDir: { x: 0, y: -1, z: 0 },
      floatingDis: radius + floatHeight + 0.08,
      springK: 2,
      //1.2,
      dampingC: 0.2,
      //0.08,
      // Slope Ray setups
      showSlopeRayOrigin: false,
      slopeMaxAngle: 1,
      // in rad
      slopeRayOriginOffest: radius - 0.03,
      slopeRayLength: radius + 3,
      slopeRayDir: { x: 0, y: -1, z: 0 },
      slopeUpExtraForce: 0.1,
      slopeDownExtraForce: 0.2,
      // AutoBalance Force setups
      autoBalance: true,
      autoBalanceSpringK: 1.2,
      //0.3,
      autoBalanceDampingC: 0.04,
      autoBalanceSpringOnY: 0.7,
      autoBalanceDampingOnY: 0.05,
      // Animation temporary setups
      animated: false,
      mode: null
      //...o
    };
    this.v = {
      movingObjectVelocityInCharacterDir: new Vector3(),
      movingObjectVelocity: new Vector3(),
      standingForcePoint: new Vector3(),
      pivotPosition: new Vector3(),
      //modelEuler: new Euler(),
      modelQuat: new Quaternion(),
      moveImpulse: new Vector3(),
      impulseCenter: new Vector3(),
      movingDirection: new Vector3(),
      moveAccNeeded: new Vector3(),
      jumpVelocityVec: new Vector3(),
      jumpDirection: new Vector3(),
      currentVel: new Vector3(),
      currentPos: new Vector3(),
      dragForce: new Vector3(),
      dragAngForce: new Vector3(),
      wantToMoveVel: new Vector3(),
      rejectVel: new Vector3(),
      // Floating Ray setup
      floatingForce: null,
      springDirVec: new Vector3(),
      rayOrigin: new Vector3(),
      characterMassForce: new Vector3(),
      // slope
      slopeAngle: null,
      actualSlopeNormal: new Vector3(),
      actualSlopeAngle: null,
      actualSlopeNormalVec: new Vector3(),
      floorNormal: new Vector3(0, 1, 0),
      slopeRayOriginRef: new Vector3(),
      slopeRayorigin: new Vector3(),
      canJump: false,
      isFalling: false,
      //run:false,
      isOnMovingObject: false
    };
    this.fixWeight = o.fixWeight !== void 0 ? o.fixWeight : true;
    this.type = "character";
    this.name = o.name || "hero";
    o.name = this.name;
    this.isRay = false;
    this.ray = null;
    this.model = null;
    this.static = false;
    this.moving = false;
    this.running = false;
    this.wantJump = false;
    this.radius = radius;
    this.height = height;
    this.mass = o.mass || 0.84;
    delete o.radius;
    this.fall = false;
    this.floor = true;
    this.distance = 0;
    this.rayAngle = 0;
    this.rayStart = -(this.height * 0.5) + this.radius;
    this.rayEnd = this.rayStart - 4 * floatHeight;
    this.maxRayDistance = this.height;
    this.contact = false;
    this.tmpV1 = new Vector3();
    this.tmpV2 = new Vector3();
    this.ease = new Vector3();
    this.tmpAcc = 0;
    this.rs = 0;
    this.ts = 0;
    this.diagonal = 1 / Math.sqrt(2);
    this.jump = false;
    this.crouch = false;
    this.toggle = true;
    this.oy = 0;
    this.vy = 0;
    this.timeScale = 1.25;
    this.angle = (o.angle || 0) * torad$3;
    this.speed = {
      idle: 1,
      fight: 1,
      walk: 7.8,
      crouch: 7,
      run: 12
    };
    this.valheimStyle = true;
    this.globalRay = o.ray || false;
    this.callback = o.callback || function() {
    };
    if (o.callback) delete o.callback;
    this.initPhysic(o);
  }
  setHeight(H) {
    if (this.model) this.model.setRealSize(H);
  }
  reSizePhysics(h) {
    if (h === this.realHeight) return;
    this.realHeight = h;
    this.height = this.realHeight - (this.useFloating ? this.option.floatHeight : 0);
    let pos = this.position.toArray();
    pos[1] += this.height * 0.5 + (this.useFloating ? this.option.floatHeight : 0);
    let size = [this.radius, this.height - 2 * this.radius];
    this.phyData.pos = pos;
    this.phyData.size = size;
    root.post({ m: "add", o: this.phyData });
  }
  initPhysic(o) {
    if (!o.size) o.size = [this.radius, this.height - 2 * this.radius];
    if (!o.pos) o.pos = [0, 0, 0];
    o.pos[1] += this.height * 0.5;
    if (this.useFloating) o.pos[1] += this.option.floatHeight;
    if (this.globalRay) root.items.body.geometry({ ...o, type: "capsule", ray: true }, this, Mat.get("hide"));
    this.phyData = {
      name: this.name,
      size: o.size,
      pos: o.pos,
      type: "character",
      shapeType: o.shapeType || "capsule",
      density: 1,
      //o.density || 1,
      mass: this.mass,
      friction: o.friction !== void 0 ? o.friction : 0.5,
      angularFactor: [0, 0, 0],
      group: 16,
      regular: true,
      massInfo: o.massInfo
    };
    if (o.mask) this.phyData["mask"] = o.mask;
    root.items.character.addToWorld(this, o.id);
    root.post({ m: "add", o: this.phyData });
    if (this.useFloating) this.ray = root.motor.add({ type: "ray", name: this.name + "_ray", begin: [0, this.rayStart, 0], end: [0, this.rayEnd, 0], callback: this.selfRay.bind(this), visible: false, parent: this.name });
    if (o.gender) this.addModel(o);
    else this.showHelper(true);
    this.enable = true;
  }
  extraRemove() {
    if (this.ray) root.motor.remove(this.name + "_ray");
  }
  /*clear(){
  	root.motor.remove([this.name, this.name + '_ray']);
  }*/
  selfRay(r) {
    if (r.hit) {
      this.distance = r.distance;
      this.rayAngle = r.angle;
    } else {
      this.distance = this.option.rayLength;
      this.rayAngle = 0;
    }
  }
  hit(d) {
    this.contact = d;
  }
  showHelper(b) {
    if (b) {
      if (!this.helper) {
        this.helper = new CapsuleHelper(this.radius, this.height, true, Mat.get("line"), [1, 0.6, 0], [0.6, 0.2, 0]);
        this.helper.setDirection(this.angle);
        this.add(this.helper);
      }
    } else {
      if (this.helper) {
        this.remove(this.helper);
        this.helper.dispose();
        this.helper = null;
      }
    }
    if (this.ray) this.ray.visible = b;
  }
  addSkeleton() {
    if (this.skeletonBody) return;
    if (!this.model) return;
    this.skeletonBody = new SkeletonBody(this.name, this.model.root, this.model.skeleton.bones);
    root.scene.add(this.skeletonBody);
    this.skeletonBody.isVisible(false);
  }
  debugMode(v = false) {
    if (this.skeletonBody) this.skeletonBody.isVisible(v);
    if (this.model && this.skeletonBody) this.model.setMaterial({ transparent: v, opacity: v ? 0.8 : 1 }, !v);
    this.showHelper(v);
  }
  setMode(name) {
    if (this.skeletonBody) this.skeletonBody.setMode(name);
  }
  addModel(o) {
    this.model = new Avatar({
      type: o.gender,
      anim: o.anim !== void 0 ? o.anim : "idle",
      compact: true,
      material: !o.noMat,
      morph: o.morph || false,
      randomMorph: o.randomMorph || false,
      randomSize: o.randomSize || false,
      callback: this.callback,
      fixWeight: this.fixWeight,
      noLOD: o.noLOD || false
    });
    this.add(this.model);
    let ypos = -(this.height * 0.5);
    if (this.useFloating) ypos -= this.option.floatHeight;
    this.model.setPosition(0, this.model.decalY + ypos, 0);
    this.model.rotation.y = this.angle;
    this.model.updateMatrix();
  }
  raycast() {
    return;
  }
  /*preStep(){
  	if(this.skeletonBody) this.skeletonBody.update()
  }*/
  step(AR, n2) {
    this.position.fromArray(AR, n2 + 1);
    this.quaternion.fromArray(AR, n2 + 4);
    this.velocity.fromArray(AR, n2 + 8);
    this.angular.fromArray(AR, n2 + 11);
    this.fall = this.position.y < this.oy;
    this.floor = MathTool.nearEquals(this.position.y, this.oy, 0.1);
    this.oy = this.position.y;
    if (this.model) {
      this.model.update(root.delta);
      this.getDistanceToCamera();
    }
    if (this.useFloating && !this.isPlayer) {
      this.stopMoving();
      this.getFloating();
      root.motor.change({
        name: this.name,
        impulse: this.v.moveImpulse.toArray(),
        impulseCenter: this.v.impulseCenter.toArray()
      });
    }
    this.updateMatrix();
  }
  getDistanceToCamera() {
    if (!this.model) return;
    if (!this.model.haveLOD) return;
    const camera = root.motor.getCamera();
    this.tmpV1.copy(root.motor.getCurrentCharacterPosition());
    this.tmpV2.copy(this.position);
    const distance = this.tmpV1.distanceTo(this.tmpV2) / camera.zoom;
    let level = distance > 3 ? 0 : 1;
    this.model.setLevel(level);
  }
  set(o) {
    if (o.morph) {
      if (this.model) this.model.setMorph(o.morph, o.value);
    }
  }
  dispose() {
    this.callback = null;
    if (this.skeletonBody) this.skeletonBody.dispose();
    if (this.model) this.model.dispose();
    if (this.helper) this.showHelper();
    super.dispose();
  }
  onFrame(state, delta) {
    this.v;
    this.option;
  }
  autoBalance() {
    const v = this.v;
    const o = this.option;
    const r = this.rotation;
    v.dragAngForce.set(
      -o.autoBalanceSpringK * r.x - this.angular.x * o.autoBalanceDampingC,
      -o.autoBalanceSpringK * r.y - this.angular.y * o.autoBalanceDampingOnY,
      -o.autoBalanceSpringK * r.z - this.angular.z * o.autoBalanceDampingC
    );
  }
  moveCharacter(delta, angle = 0) {
    const v = this.v;
    const o = this.option;
    const key = root.motor.getKey();
    root.motor.getAzimut();
    v.currentPos.copy(this.position);
    v.slopeAngle = 0;
    if (v.actualSlopeAngle < o.slopeMaxAngle && Math.abs(v.slopeAngle) > 0.2 && Math.abs(v.slopeAngle) < o.slopeMaxAngle) {
      v.movingDirection.set(0, Math.sin(v.slopeAngle), Math.cos(v.slopeAngle));
    } else if (v.actualSlopeAngle >= o.slopeMaxAngle) {
      v.movingDirection.set(0, Math.sin(v.slopeAngle) > 0 ? 0 : Math.sin(v.slopeAngle), Math.sin(v.slopeAngle) > 0 ? 0.1 : 1);
    } else {
      v.movingDirection.set(0, 0, 1);
    }
    v.movingDirection.applyAxisAngle({ x: 0, y: 1, z: 0 }, angle);
    v.movingObjectVelocityInCharacterDir.copy(v.movingObjectVelocity).projectOnVector(v.movingDirection).multiply(v.movingDirection);
    const angleBetweenCharacterDirAndObjectDir = v.movingObjectVelocity.angleTo(v.movingDirection);
    const wantToMoveMeg = v.currentVel.dot(v.movingDirection);
    v.wantToMoveVel.set(v.movingDirection.x * wantToMoveMeg, 0, v.movingDirection.z * wantToMoveMeg);
    v.rejectVel.copy(v.currentVel).sub(v.wantToMoveVel);
    v.moveAccNeeded.set(
      (v.movingDirection.x * (o.maxVelLimit * (this.running ? o.sprintMult : 1) + v.movingObjectVelocityInCharacterDir.x) - (v.currentVel.x - v.movingObjectVelocity.x * Math.sin(angleBetweenCharacterDirAndObjectDir) + v.rejectVel.x * (v.isOnMovingObject ? 0 : o.rejectVelMult))) / o.accDeltaTime,
      0,
      (v.movingDirection.z * (o.maxVelLimit * (this.running ? o.sprintMult : 1) + v.movingObjectVelocityInCharacterDir.z) - (v.currentVel.z - v.movingObjectVelocity.z * Math.sin(angleBetweenCharacterDirAndObjectDir) + v.rejectVel.z * (v.isOnMovingObject ? 0 : o.rejectVelMult))) / o.accDeltaTime
    );
    const moveForceNeeded = v.moveAccNeeded.multiplyScalar(this.mass);
    let characterRotated = true;
    if (this.waitRotation) characterRotated = Math.sin(angle).toFixed(3) == Math.sin(this.rotation.y).toFixed(3);
    if (!characterRotated) {
      v.moveImpulse.set(
        moveForceNeeded.x * o.turnVelMultiplier * (v.canJump ? 1 : o.airDragMultiplier),
        // if it's in the air, give it less control
        v.slopeAngle === null || v.slopeAngle == 0 ? 0 : v.movingDirection.y * o.turnVelMultiplier * (v.movingDirection.y > 0 ? o.slopeUpExtraForce : o.slopeDownExtraForce) * (this.running ? o.sprintMult : 1),
        moveForceNeeded.z * o.turnVelMultiplier * (v.canJump ? 1 : o.airDragMultiplier)
        // if it's in the air, give it less control
      );
    } else {
      v.moveImpulse.set(
        moveForceNeeded.x * (v.canJump ? 1 : o.airDragMultiplier),
        v.slopeAngle === null || v.slopeAngle == 0 ? 0 : v.movingDirection.y * (v.movingDirection.y > 0 ? o.slopeUpExtraForce : o.slopeDownExtraForce) * (this.running ? o.sprintMult : 1),
        moveForceNeeded.z * (v.canJump ? 1 : o.airDragMultiplier)
      );
    }
    v.impulseCenter.set(v.currentPos.x, v.currentPos.y + o.moveImpulsePointY, v.currentPos.z);
    v.currentVel.copy(this.velocity);
    if (key[4] && v.canJump) {
      v.jumpVelocityVec.set(v.currentVel.x, this.running ? o.sprintJumpMult * o.jumpVel : o.jumpVel, v.currentVel.z);
      v.moveImpulse.y = v.jumpVelocityVec.y;
    }
  }
  getFloating() {
    const v = this.v;
    const o = this.option;
    const floatingForce = o.springK * (o.floatingDis - this.distance) - this.velocity.y * o.dampingC;
    v.moveImpulse.y = floatingForce * this.mass;
  }
  stopMoving() {
    this.v;
    this.option;
    this.v.moveImpulse.set(0, 0, 0);
    this.tmpV1.copy(this.velocity);
    this.tmpV1.x *= 0.9;
    this.tmpV1.z *= 0.9;
    if (this.tmpV1.x + this.tmpV1.z === 0) return;
    root.motor.change({
      name: this.name,
      //force: this.tmpV1.toArray(), forceMode:'velocity', 
      linearVelocity: this.tmpV1.toArray(),
      //angularVelocity: this.tmpV2.toArray(),
      wake: false
      //noGravity:true 
    });
  }
  move() {
    this.v;
    const key = root.motor.getKey();
    const azimut2 = root.motor.getAzimut();
    const delta = root.delta;
    let anim = key[7] !== 0 ? "run" : "walk";
    if (key[0] === 0 && key[1] === 0) anim = "idle";
    let m2 = key[0] !== 0 && key[1] !== 0 ? this.diagonal : 1;
    if (key[5] && this.toggle) {
      this.crouch = !this.crouch;
      this.toggle = false;
    }
    if (key[5] === 0) this.toggle = true;
    if ((anim === "walk" || anim === "run") && this.crouch) anim = "crouch";
    if (key[6] === 1) anim = "fight";
    if (!this.jump && key[4]) {
      this.vy = 22;
      this.jump = true;
    }
    if (this.jump) {
      this.vy -= 1;
      if (this.vy <= 0) {
        this.vy = 0;
        if (this.floor) this.jump = false;
      }
    }
    let mAnim = "idle";
    switch (anim) {
      case "idle":
        mAnim = this.crouch ? "Crouch Idle" : "idle";
        break;
      case "walk":
        mAnim = "Jog Forward";
        break;
      case "run":
        mAnim = "Standard Run";
        break;
      case "crouch":
        mAnim = "Crouch Walk";
        break;
      case "fight":
        mAnim = "Attack";
        break;
    }
    this.moving = key[0] !== 0 || key[1] !== 0;
    this.running = key[7] !== 0;
    this.wantJump = key[4] !== 0;
    let angle = MathTool.unwrapRad(Math.atan2(key[0], key[1]) + azimut2);
    if (this.useImpulse) {
      if (this.moving) this.moveCharacter(delta, angle);
      else this.stopMoving();
      if (this.useFloating) this.getFloating();
      root.motor.change({
        name: this.name,
        impulse: this.v.moveImpulse.toArray(),
        impulseCenter: this.v.impulseCenter.toArray()
      });
    } else {
      this.tmpAcc += delta * 4;
      const genSpeed = 1;
      let speed = this.speed[anim] * genSpeed;
      if (this.moving) {
        this.rs = key[0] * speed;
        this.ts = key[1] * speed;
      }
      if (key[0] === 0 && key[1] === 0) this.tmpAcc = 0;
      if (this.tmpAcc > 1) this.tmpAcc = 1;
      this.ease.set(this.rs, 0, this.ts).multiplyScalar(this.tmpAcc * m2);
      this.ease.length();
      if (this.static) this.ease.x = this.ease.z = 0;
      let g2 = this.vy - 9.81;
      this.ease.y = g2;
      this.tmpV1.copy(this.ease).applyAxisAngle({ x: 0, y: 1, z: 0 }, azimut2);
      this.tmpV2.set(0, 0, 0);
      root.motor.change({
        name: this.name,
        //force: this.tmpV1.toArray(), forceMode:'velocity', 
        linearVelocity: this.tmpV1.toArray()
        //angularVelocity: this.tmpV2.toArray(),
        //wake:true, 
        //noGravity:true 
      });
    }
    if (this.helper) {
      this.helper.updateMatrix();
      this.helper.cone.rotation.y = azimut2;
      if (anim !== "idle") this.helper.setDirection(angle);
    }
    if (!this.model) return;
    if (this.jump) {
      this.model.play("Jump", 0.5);
    } else {
      this.model.play(mAnim, 0.75);
    }
    if (anim !== "idle") {
      let pp = MathTool.unwrapRad(this.model.rotation.y);
      let aa = MathTool.nearAngle(angle, pp);
      let diff = Math.abs(Math.floor((pp - aa) * math.todeg) / 180);
      this.model.rotation.y = anim === "fight" ? azimut2 + Math.PI : MathTool.lerp(pp, aa, 0.2 - diff * 0.1);
      this.model.updateMatrix();
    }
  }
};
var Character = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "character";
    this.num = Num[this.type];
  }
  /*prestep () {
  
  		let i = this.list.length;
  		while( i-- ) this.list[i].preStep( );
  
  	}*/
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    let i = this.list.length, n2, s;
    while (i--) {
      s = this.list[i];
      n2 = N + i * this.num;
      if (s) s.step(AR, n2);
    }
  }
  add(o = {}) {
    this.setName(o);
    const hero = new Hero(o);
    return hero;
  }
  set(o = {}, b = null) {
    if (b === null) b = this.byName(o.name);
    if (b === null) return;
    b.set(o);
  }
};
var math$2 = {
  torad: Math.PI / 180,
  todeg: 180 / Math.PI,
  Pi: Math.PI,
  TwoPI: Math.PI * 2,
  PI90: Math.PI * 0.5,
  PI45: Math.PI * 0.25,
  PI270: Math.PI * 0.5 * 3,
  inv255: 3921569e-9,
  golden: 1.618033,
  epsilon: Math.pow(2, -52),
  randomSign: () => Math.random() < 0.5 ? -1 : 1,
  randSpread: (range) => range * (0.5 - Math.random()),
  rand: (low = 0, high = 1) => low + Math.random() * (high - low),
  randInt: (low, high) => low + Math.floor(Math.random() * (high - low + 1)),
  toFixed: (x2, n2 = 3) => x2.toFixed(n2) * 1,
  int: (x2) => Math.floor(x2),
  lerp: (x2, y, t2) => (1 - t2) * x2 + t2 * y,
  clamp: (v, min, max2) => Math.max(min, Math.min(max2, v)),
  nearEquals: (a, b, t2) => Math.abs(a - b) <= t2 ? true : false,
  lerpAr: (ar, arx, ary, t2) => {
    let i = ar.length;
    while (i--) ar[i] = math$2.lerp(arx[i], ary[i], t2);
  },
  unwrapDeg: (r) => r - Math.floor((r + 180) / 360) * 360,
  //unwrapRad: ( r ) => (r - (Math.floor((r + Math.PI)/(2*Math.PI)))*2*Math.PI),
  unwrapRad: (r) => Math.atan2(Math.sin(r), Math.cos(r)),
  scaleArray: (ar, scale) => {
    var i = ar.length;
    while (i--) {
      ar[i] *= scale;
    }
    return ar;
  },
  addArray: (ar, ar2) => {
    var r = [];
    var i = ar.length;
    while (i--) {
      r[i] = ar[i] + ar2[i];
    }
    return r;
  },
  angleDistance: (cur, prv) => {
    var diff = (cur - prv + 180) % 360 - 180;
    return diff < -180 ? diff + 360 : diff;
  },
  /*map: ( value, in_min, in_max, out_min, out_max ) => ( (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min ),
  	
  	smoothLerp: ( a, b, c, t, k ) => {
  
          var f = a - b + (c - b) / (k * t);
          return c - (c - b) / ( k * t ) + f * Math.exp(-k*t);
  
      },
  
      smoothLerpV: ( a, b, c, t, k ) => {
  
      	let x = math.smoothLerp( a.x, b.x, c.x, t, k );
      	let y = math.smoothLerp( a.y, b.y, c.y, t, k );
      	let z = math.smoothLerp( a.z, b.z, c.z, t, k );
  
      	return { x:x, y:y, z:z }
  
      },
  
  	minValue: ( ar ) => {
  
  		let v = ar[0];
  		for (let i = 1, l=ar.length; i<l; i++){ if( ar[i] < v ) v = ar[i]; }
  		return v;
  
  	},
  
  	clamp: function (v, min, max) {
  
  		//return Math.max( min, Math.min( max, value ) );
  	    v = v < min ? min : v;
  	    v = v > max ? max : v;
  	    return v;
  	},
  
  	autoSize: ( o ) => {
  
  		let s = o.size === undefined ? [ 1, 1, 1 ] : o.size;
  		if ( s.length === 1 ) s[ 1 ] = s[ 0 ];
  
  		let type = o.type === undefined ? 'box' : o.type;
  		let radius = o.radius === undefined ? s[0] : o.radius;
  		let height = o.height === undefined ? s[1] : o.height;
  
  		if( type === 'sphere' ) s = [ radius, radius, radius ];
  		if( type === 'cylinder' || type === 'wheel' || type === 'capsule' ) s = [ radius, height, radius ];
  		if( type === 'cone' || type === 'pyramid' ) s = [ radius, height, 0 ];
  
  	    if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
  	    return s;
  
  	},
  
  	correctSize: ( s ) => {
  
  		if ( s.length === 1 ) s[ 1 ] = s[ 0 ];
  	    if ( s.length === 2 ) s[ 2 ] = s[ 0 ];
  	    return s;
  
  	},*/
  tmpE: new Euler(),
  tmpM: new Matrix4(),
  tmpM2: new Matrix4(),
  tmpV: new Vector3(),
  tmpQ: new Quaternion(),
  fromTransformToQ: (p2, q, inv) => {
    inv = inv || false;
    math$2.tmpM.compose(math$2.tmpV.fromArray(p2), math$2.tmpQ.fromArray(q), { x: 1, y: 1, z: 1 });
    math$2.tmpM.decompose(math$2.tmpV, math$2.tmpQ, { x: 1, y: 1, z: 1 });
    if (inv) math$2.tmpQ.invert();
    return math$2.tmpQ.toArray();
  },
  fromTransform: (p2, q, p22, q2, inv) => {
    inv = inv || false;
    q2 = q2 || [0, 0, 0, 1];
    math$2.tmpM.compose(math$2.tmpV.fromArray(p2), math$2.tmpQ.fromArray(q), { x: 1, y: 1, z: 1 });
    math$2.tmpM2.compose(math$2.tmpV.fromArray(p22), math$2.tmpQ.fromArray(q2), { x: 1, y: 1, z: 1 });
    if (inv) {
      math$2.tmpM.invert();
      math$2.tmpM.multiply(math$2.tmpM2);
    } else {
      math$2.tmpM.multiply(math$2.tmpM2);
    }
    math$2.tmpM.decompose(math$2.tmpV, math$2.tmpQ, { x: 1, y: 1, z: 1 });
    return math$2.tmpV.toArray();
  },
  arCopy: (a, b) => {
    [...b];
  },
  axisToQuatArray: (r, isdeg) => {
    isdeg = isdeg || false;
    return math$2.tmpQ.setFromAxisAngle(math$2.tmpV.fromArray(r, 1), isdeg ? r[0] * math$2.torad : r[0]).normalize().toArray();
  },
  toQuatArray: (rotation) => {
    return math$2.tmpQ.setFromEuler(math$2.tmpE.fromArray(math$2.vectorad(rotation))).toArray();
  },
  vectorad: (r) => {
    let i = 3, nr = [];
    while (i--) nr[i] = r[i] * math$2.torad;
    nr[3] = r[3];
    return nr;
  },
  /*
  	directionVector: ( a, b ) => {
  
  	    var x = b.x-a.x;
  	    var y = b.y-a.y;
  	    var z = b.z-a.z;
  	    var d = math.tmpV.set( x, 0, z ).normalize().toArray();
  	    return d;
  
  	},
  
  	distanceVector: ( a, b ) => {
  
  	    var x = b.x-a.x;
  	    var y = b.y-a.y;
  	    var z = b.z-a.z;
  	    var d = Math.sqrt( x*x + y*y + z*z );
  	    return d;
  
  	},*/
  //--------------------
  //   COLORS
  //--------------------
  rgbToHex: (rgb) => {
    return "0x" + ("000000" + (rgb[0] * 255 << 16 ^ rgb[1] * 255 << 8 ^ rgb[2] * 255 << 0).toString(16)).slice(-6);
  },
  hexToRgb: (hex) => {
    hex = Math.floor(hex);
    var r = (hex >> 16 & 255) / 255;
    var g2 = (hex >> 8 & 255) / 255;
    var b = (hex & 255) / 255;
    return [r, g2, b];
  },
  htmlToHex: (v) => {
    return v.toUpperCase().replace("#", "0x");
  },
  hexToHtml: (v) => {
    v = v === void 0 ? 0 : v;
    return "#" + ("000000" + v.toString(16)).substr(-6);
  },
  rgbToHtml: (rgb) => {
    return "#" + ("000000" + (rgb[0] * 255 << 16 ^ rgb[1] * 255 << 8 ^ rgb[2] * 255 << 0).toString(16)).slice(-6);
  },
  //--------------------
  //   NOISE
  //--------------------
  perlin: null,
  resetPerlin: () => {
    if (math$2.perlin !== null) math$2.perlin = null;
  },
  noise: (v, o) => {
    if (math$2.perlin === null) math$2.perlin = new SimplexNoise();
    o = o || {};
    let level = o.level || [1, 0.2, 0.05];
    let frequency = o.frequency || [0.016, 0.05, 0.2];
    let i, f, c = 0, d = 0;
    for (i = 0; i < level.length; i++) {
      f = frequency[i];
      c += level[i] * (0.5 + math$2.perlin.noise3d(v.x * f, v.y * f, v.z * f) * 0.5);
      d += level[i];
    }
    c /= d;
    return c;
  }
  /*radArray: (arr) => {
  		var ret = [];
  		for(var i = 0; i < 3; i++)
  			ret[i] = arr[i] * math.torad;
  
  		return ret;
  	},
  
  	degArray: (arr) => {
  		var ret = [];
  		for(var i = 0; i < 3; i++)
  			ret[i] = arr[i] * math.todeg;
  
  		return ret;
  	},
  
  	angleDistance: (cur, prv) =>{
  		var diff = (cur - prv + 180) % 360 - 180;
  		return diff < -180 ? diff + 360 : diff;
  	}*/
};
var SimplexNoise = class {
  constructor(r) {
    if (r == void 0) r = Math;
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ];
    this.grad4 = [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ];
    this.p = [];
    for (var i = 0; i < 256; i++) {
      this.p[i] = Math.floor(r.random() * 256);
    }
    this.perm = [];
    for (var i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ];
  }
  dot(g2, x2, y) {
    return g2[0] * x2 + g2[1] * y;
  }
  dot3(g2, x2, y, z) {
    return g2[0] * x2 + g2[1] * y + g2[2] * z;
  }
  dot4(g2, x2, y, z, w) {
    return g2[0] * x2 + g2[1] * y + g2[2] * z + g2[3] * w;
  }
  noise(xin, yin) {
    var n0, n1, n2;
    var F2 = 0.5 * (Math.sqrt(3) - 1);
    var s = (xin + yin) * F2;
    var i = Math.floor(xin + s);
    var j = Math.floor(yin + s);
    var G2 = (3 - Math.sqrt(3)) / 6;
    var t2 = (i + j) * G2;
    var X0 = i - t2;
    var Y0 = j - t2;
    var x0 = xin - X0;
    var y0 = yin - Y0;
    var i1, j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;
    } else {
      i1 = 0;
      j1 = 1;
    }
    var x1 = x0 - i1 + G2;
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2;
    var y2 = y0 - 1 + 2 * G2;
    var ii = i & 255;
    var jj = j & 255;
    var gi0 = this.perm[ii + this.perm[jj]] % 12;
    var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
    var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
    var t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) n0 = 0;
    else {
      t0 *= t0;
      n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
    }
    var t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) n1 = 0;
    else {
      t1 *= t1;
      n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
    }
    var t22 = 0.5 - x2 * x2 - y2 * y2;
    if (t22 < 0) n2 = 0;
    else {
      t22 *= t22;
      n2 = t22 * t22 * this.dot(this.grad3[gi2], x2, y2);
    }
    return 70 * (n0 + n1 + n2);
  }
  // 3D simplex noise
  noise3d(xin, yin, zin) {
    var n0, n1, n2, n3;
    var F3 = 1 / 3;
    var s = (xin + yin + zin) * F3;
    var i = Math.floor(xin + s);
    var j = Math.floor(yin + s);
    var k = Math.floor(zin + s);
    var G3 = 1 / 6;
    var t2 = (i + j + k) * G3;
    var X0 = i - t2;
    var Y0 = j - t2;
    var Z0 = k - t2;
    var x0 = xin - X0;
    var y0 = yin - Y0;
    var z0 = zin - Z0;
    var i1, j1, k1;
    var i2, j2, k2;
    if (x0 >= y0) {
      if (y0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      } else if (x0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 1;
        j2 = 0;
        k2 = 1;
      }
    } else {
      if (y0 < z0) {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i2 = 0;
        j2 = 1;
        k2 = 1;
      } else if (x0 < z0) {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 0;
        j2 = 1;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i2 = 1;
        j2 = 1;
        k2 = 0;
      }
    }
    var x1 = x0 - i1 + G3;
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;
    var x2 = x0 - i2 + 2 * G3;
    var y2 = y0 - j2 + 2 * G3;
    var z2 = z0 - k2 + 2 * G3;
    var x3 = x0 - 1 + 3 * G3;
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;
    var ii = i & 255;
    var jj = j & 255;
    var kk = k & 255;
    var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
    var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
    var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
    var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
    var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0) n0 = 0;
    else {
      t0 *= t0;
      n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
    }
    var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0) n1 = 0;
    else {
      t1 *= t1;
      n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
    }
    var t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
    if (t22 < 0) n2 = 0;
    else {
      t22 *= t22;
      n2 = t22 * t22 * this.dot3(this.grad3[gi2], x2, y2, z2);
    }
    var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0) n3 = 0;
    else {
      t3 *= t3;
      n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
    }
    return 32 * (n0 + n1 + n2 + n3);
  }
  // 4D simplex noise
  noise4d(x2, y, z, w) {
    var grad4 = this.grad4;
    var simplex = this.simplex;
    var perm = this.perm;
    var F4 = (Math.sqrt(5) - 1) / 4;
    var G4 = (5 - Math.sqrt(5)) / 20;
    var n0, n1, n2, n3, n4;
    var s = (x2 + y + z + w) * F4;
    var i = Math.floor(x2 + s);
    var j = Math.floor(y + s);
    var k = Math.floor(z + s);
    var l = Math.floor(w + s);
    var t2 = (i + j + k + l) * G4;
    var X0 = i - t2;
    var Y0 = j - t2;
    var Z0 = k - t2;
    var W0 = l - t2;
    var x0 = x2 - X0;
    var y0 = y - Y0;
    var z0 = z - Z0;
    var w0 = w - W0;
    var c1 = x0 > y0 ? 32 : 0;
    var c2 = x0 > z0 ? 16 : 0;
    var c3 = y0 > z0 ? 8 : 0;
    var c4 = x0 > w0 ? 4 : 0;
    var c5 = y0 > w0 ? 2 : 0;
    var c6 = z0 > w0 ? 1 : 0;
    var c = c1 + c2 + c3 + c4 + c5 + c6;
    var i1, j1, k1, l1;
    var i2, j2, k2, l2;
    var i3, j3, k3, l3;
    i1 = simplex[c][0] >= 3 ? 1 : 0;
    j1 = simplex[c][1] >= 3 ? 1 : 0;
    k1 = simplex[c][2] >= 3 ? 1 : 0;
    l1 = simplex[c][3] >= 3 ? 1 : 0;
    i2 = simplex[c][0] >= 2 ? 1 : 0;
    j2 = simplex[c][1] >= 2 ? 1 : 0;
    k2 = simplex[c][2] >= 2 ? 1 : 0;
    l2 = simplex[c][3] >= 2 ? 1 : 0;
    i3 = simplex[c][0] >= 1 ? 1 : 0;
    j3 = simplex[c][1] >= 1 ? 1 : 0;
    k3 = simplex[c][2] >= 1 ? 1 : 0;
    l3 = simplex[c][3] >= 1 ? 1 : 0;
    var x1 = x0 - i1 + G4;
    var y1 = y0 - j1 + G4;
    var z1 = z0 - k1 + G4;
    var w1 = w0 - l1 + G4;
    var x22 = x0 - i2 + 2 * G4;
    var y2 = y0 - j2 + 2 * G4;
    var z2 = z0 - k2 + 2 * G4;
    var w2 = w0 - l2 + 2 * G4;
    var x3 = x0 - i3 + 3 * G4;
    var y3 = y0 - j3 + 3 * G4;
    var z3 = z0 - k3 + 3 * G4;
    var w3 = w0 - l3 + 3 * G4;
    var x4 = x0 - 1 + 4 * G4;
    var y4 = y0 - 1 + 4 * G4;
    var z4 = z0 - 1 + 4 * G4;
    var w4 = w0 - 1 + 4 * G4;
    var ii = i & 255;
    var jj = j & 255;
    var kk = k & 255;
    var ll = l & 255;
    var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
    var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
    var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
    var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
    var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
    var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
    if (t0 < 0) n0 = 0;
    else {
      t0 *= t0;
      n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
    }
    var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
    if (t1 < 0) n1 = 0;
    else {
      t1 *= t1;
      n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
    }
    var t22 = 0.6 - x22 * x22 - y2 * y2 - z2 * z2 - w2 * w2;
    if (t22 < 0) n2 = 0;
    else {
      t22 *= t22;
      n2 = t22 * t22 * this.dot4(grad4[gi2], x22, y2, z2, w2);
    }
    var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
    if (t3 < 0) n3 = 0;
    else {
      t3 *= t3;
      n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
    }
    var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
    if (t4 < 0) n4 = 0;
    else {
      t4 *= t4;
      n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
    }
    return 27 * (n0 + n1 + n2 + n3 + n4);
  }
};
var Landscape = class extends Mesh {
  constructor(o = {}) {
    super();
    this.ready = false;
    this.needUpdate = false;
    this.type = "terrain";
    this.name = o.name;
    this.folder = o.folder || "./assets/textures/terrain/";
    this.mapN = 0;
    this.mapMax = 7;
    this.ttype = o.terrainType || "terrain";
    this.callback = o.callback || function() {
    };
    this.physicsUpdate = () => {
    };
    this.uvx = [o.uv || 18, o.uv || 18];
    this.sample = o.sample == void 0 ? [128, 128] : o.sample;
    this.size = o.size === void 0 ? [100, 30, 100] : o.size;
    let sx = this.sample[0] - 1;
    let sz = this.sample[1] - 1;
    this.rx = sx / this.size[0];
    this.rz = sz / this.size[2];
    this.zone = o.zone || 1;
    let square = [this.size[0] / sx, this.size[2] / sz];
    this.sampleZ = [o.sample[0] * this.zone, o.sample[1] * this.zone];
    this.sizeZ = [(this.sampleZ[0] - 1) * square[0], o.size[1], (this.sampleZ[1] - 1) * square[1]];
    this.lng = this.sample[0] * this.sample[1];
    this.lngZ = this.sampleZ[0] * this.sampleZ[1];
    this.getZid();
    this.data = {
      level: o.level || [1, 0.2, 0.05],
      frequency: o.frequency || [0.016, 0.05, 0.2],
      expo: o.expo || 1
    };
    this.isWater = o.water || false;
    this.isIsland = o.island || false;
    this.isBorder = false;
    this.wantBorder = o.border || false;
    this.isBottom = false;
    this.wantBottom = o.bottom || false;
    this.wantBorder = o.border || false;
    this.colorBase = this.isWater ? { r: 0, g: 0.7, b: 1 } : { r: 0.25, g: 0.25, b: 0.25 };
    this.maxspeed = o.maxSpeed || 0.1;
    this.acc = o.acc == void 0 ? 0.01 : o.acc;
    this.dec = o.dec == void 0 ? 0.01 : o.dec;
    this.deep = o.deep == void 0 ? 0 : o.deep;
    this.ease = new Vector2();
    this.complexity = o.complexity == void 0 ? 30 : o.complexity;
    this.complexity2 = o.complexity2 == void 0 ? null : o.complexity2;
    this.local = new Vector3();
    if (o.local) this.local.fromArray(o.local);
    this.pp = new Vector3();
    this.ratioZ = 1 / this.sampleZ[0];
    this.ratio = 1 / this.sample[0];
    this.ruvx = 1 / (this.size[0] / this.uvx[0]);
    this.ruvy = -(1 / (this.size[2] / this.uvx[1]));
    this.is64 = o.is64 || false;
    this.isTurn = o.turn || false;
    this.heightData = new Float32Array(this.lngZ);
    this.height = [];
    this.isAbsolute = o.isAbsolute || false;
    this.isTurned = o.isTurned || false;
    this.isReverse = o.isReverse || false;
    this.changeId = this.isReverse || this.isTurned;
    if (this.changeId) this.getReverseID();
    this.colors = new Float32Array(this.lng * 3);
    this.geometry = new PlaneGeometry(this.size[0], this.size[2], this.sample[0] - 1, this.sample[1] - 1);
    this.geometry.rotateX(-math$2.PI90);
    this.geometry.setAttribute("color", new BufferAttribute(this.colors, 3));
    this.vertices = this.geometry.attributes.position.array;
    var clevels = new Quaternion(0.5, 0.5, 0.1, 0.2);
    if (o.maplevels) clevels.fromArray(o.maplevels);
    var T = TerrainShader;
    var maps = o.maps || ["sand", "grass3", "rock"], txt = {};
    var name;
    if (this.isWater) maps = ["water"];
    for (let i in maps) {
      name = maps[i];
      txt[name + "_c"] = Pool.texture({ url: this.folder + name + "_c.jpg", flip: false, repeat: this.uvx, encoding: o.encoding || true, callback: this.mapcallback.bind(this) });
      txt[name + "_n"] = Pool.texture({ url: this.folder + name + "_n.jpg", flip: false, repeat: this.uvx, callback: this.mapcallback.bind(this) });
    }
    txt["noise"] = Pool.texture({ url: this.folder + "noise.png", flip: false, repeat: [1, 1], encoding: false, callback: this.mapcallback.bind(this) });
    this.txt = txt;
    this.material = new MeshPhysicalMaterial({ name: "terrain", vertexColors: true, color: 16777215, map: txt[maps[0] + "_c"], normalMap: txt[maps[0] + "_n"] });
    if (o.envmap !== void 0) this.material.envMap = o.envmap;
    if (this.isWater) {
      this.material.transparent = true;
      this.material.opacity = o.opacity || 0.4;
      this.material.side = DoubleSide;
      this.material.alphaMap = txt[maps[0] + "_c"];
      this.material.map = null;
      this.material.metalness = 0.9;
      this.material.roughness = 0.1;
    } else {
      this.material.reflectivity = 0;
      this.material.metalness = o.metalness || 0;
      this.material.roughness = o.roughness || 0.3;
    }
    var ns = o.nScale || 0.5;
    this.material.normalScale.set(ns, -ns);
    if (!this.isWater) {
      let self2 = this;
      this.material.onBeforeCompile = function(shader) {
        let uniforms2 = shader.uniforms;
        uniforms2["clevels"] = { value: clevels };
        uniforms2["map1"] = { value: txt[maps[1] + "_c"] };
        uniforms2["map2"] = { value: txt[maps[2] + "_c"] };
        uniforms2["randomUv"] = { value: 1 };
        uniforms2["normalMap1"] = { value: txt[maps[1] + "_n"] };
        uniforms2["normalMap2"] = { value: txt[maps[2] + "_n"] };
        uniforms2["noiseMap"] = { value: txt["noise"] };
        uniforms2["useNoiseMap"] = { value: 1 };
        shader.uniforms = uniforms2;
        Shader.addParsFragment(shader, Shader.getRandomUv() + T.fragmentAdd);
        let fragment = shader.fragmentShader;
        fragment = fragment.replace("#include <map_fragment>", T.map);
        fragment = fragment.replace("#include <normal_fragment_maps>", T.normal);
        fragment = fragment.replace("#include <color_fragment>", "");
        shader.fragmentShader = fragment;
        self2.material.userData.shader = shader;
        Shader.modify(shader);
      };
      Object.defineProperty(this.material, "randomUv", {
        get() {
          return this.userData.shader.uniforms.randomUv.value ? true : false;
        },
        set(value) {
          this.userData.shader.uniforms.randomUv.value = value ? 1 : 0;
        }
      });
      Object.defineProperty(this.material, "map1", {
        get() {
          return this.userData.shader.uniforms.map1.value;
        },
        set(value) {
          this.userData.shader.uniforms.map1.value = value;
        }
      });
      Object.defineProperty(this.material, "map2", {
        get() {
          return this.userData.shader.uniforms.map2.value;
        },
        set(value) {
          this.userData.shader.uniforms.map2.value = value;
        }
      });
      Object.defineProperty(this.material, "normalMap1", {
        get() {
          return this.userData.shader.uniforms.normalMap1.value;
        },
        set(value) {
          this.userData.shader.uniforms.normalMap1.value = value;
        }
      });
      Object.defineProperty(this.material, "normalMap2", {
        get() {
          return this.userData.shader.uniforms.normalMap2.value;
        },
        set(value) {
          this.userData.shader.uniforms.normalMap2.value = value;
        }
      });
    } else {
      this.material.onBeforeCompile = function(shader) {
        var fragment = shader.fragmentShader;
        fragment = fragment.replace("#include <alphamap_fragment>", T.alphamap);
        shader.fragmentShader = fragment;
      };
    }
    if (o.debug) {
      this.debugZone(o);
    }
    if (this.wantBorder) this.addBorder(o);
    if (this.wantBottom) this.addBottom(o);
    if (o.pos) this.position.fromArray(o.pos);
    o.quat = o.quat === void 0 ? [0, 0, 0, 1] : o.quat;
    if (o.rot !== void 0) {
      o.quat = math$2.toQuatArray(o.rot);
      delete o.rot;
    }
    this.quaternion.fromArray(o.quat);
    if (o.decal) this.position.y += o.decal;
    this.castShadow = true;
    this.receiveShadow = true;
    Pool.set("terrain" + this.name, this.material, "material", true);
    this.update();
  }
  getZid() {
    this.zid = {};
    let lx = (this.sample[0] - this.sampleZ[0]) * 0.5;
    let lz = (this.sample[1] - this.sampleZ[1]) * 0.5;
    let first2 = this.sample[0] * lz + lx;
    let line = 0;
    for (let j = 0; j < this.lngZ; j++) {
      line = Math.floor(j / this.sampleZ[0]);
      this.zid[first2 + j + line * (lx * 2)] = j;
    }
  }
  debugZone(o) {
    this.geometryZ = new PlaneGeometry(this.sizeZ[0], this.sizeZ[2], this.sampleZ[0] - 1, this.sampleZ[1] - 1);
    this.geometryZ.rotateX(-math$2.PI90);
    this.verticesZ = this.geometryZ.attributes.position.array;
    const debuger = new Mesh(this.geometryZ, new MeshBasicMaterial({ color: 0, wireframe: true, transparent: true, opacity: 0.1 }));
    this.add(debuger);
  }
  mapcallback() {
    this.mapN++;
    if (this.mapN == this.mapMax) {
      this.callback();
    }
  }
  addBottom(o) {
    var geometry = new PlaneGeometry(this.size[0], this.size[2], 1, 1);
    geometry.rotateX(math$2.PI90);
    this.bottomMesh = new Mesh(geometry, this.borderMaterial);
    this.add(this.bottomMesh);
    this.isBottom = true;
  }
  addBorder(o) {
    this.borderMaterial = new MeshStandardMaterial({
      vertexColors: true,
      metalness: this.isWater ? 0.8 : 0.4,
      roughness: this.isWater ? 0.2 : 0.6,
      //envMap: view.getEnvMap(),
      //normalMap:this.wn,
      normalScale: this.isWater ? [0.25, 0.25] : [2, 2],
      transparent: this.isWater ? true : false,
      opacity: this.isWater ? o.opacity || 0.8 : 1,
      envMap: o.envmap || null
      //shadowSide : false
    });
    var front = new PlaneGeometry(this.size[0], 2, this.sample[0] - 1, 1);
    var back = new PlaneGeometry(this.size[0], 2, this.sample[0] - 1, 1);
    var left = new PlaneGeometry(this.size[2], 2, this.sample[1] - 1, 1);
    var right = new PlaneGeometry(this.size[2], 2, this.sample[1] - 1, 1);
    front.translate(0, 1, this.size[2] * 0.5);
    back.rotateY(-math$2.Pi);
    back.translate(0, 1, -this.size[2] * 0.5);
    left.rotateY(-math$2.PI90);
    left.translate(-this.size[0] * 0.5, 1, 0);
    right.rotateY(math$2.PI90);
    right.translate(this.size[0] * 0.5, 1, 0);
    this.borderGeometry = mergeVertices(mergeGeometries([front, back, left, right]));
    this.borderVertices = this.borderGeometry.attributes.position.array;
    this.lng2 = this.borderVertices.length / 3;
    this.list = new Array(this.lng2);
    this.borderColors = new Float32Array(this.lng * 3);
    this.borderGeometry.setAttribute("color", new BufferAttribute(this.borderColors, 3));
    this.borderMesh = new Mesh(this.borderGeometry, this.borderMaterial);
    var j = this.lng2, n2, i;
    while (j--) {
      n2 = j * 3;
      i = this.borderVertices[n2 + 1] > 0 ? this.findPoint(this.borderVertices[n2], this.borderVertices[n2 + 2]) : -1;
      this.list[j] = i;
    }
    this.add(this.borderMesh);
    this.borderMesh.castShadow = true;
    this.borderMesh.receiveShadow = true;
    this.isBorder = true;
  }
  dispose() {
    if (this.isBottom) {
      this.remove(this.bottomMesh);
      this.bottomMesh.geometry.dispose();
    }
    if (this.isBorder) {
      this.remove(this.borderMesh);
      this.borderMesh.geometry.dispose();
      this.borderMesh.material.dispose();
    }
    this.geometry.dispose();
    this.material.dispose();
    for (let t2 in this.txt) this.txt[t2].dispose();
  }
  easing(key, azimuthal, wait) {
    if (key[0] === 0 && key[1] === 0) return;
    var r = azimuthal || 0;
    if (key[7]) this.maxspeed = 1.5;
    else this.maxspeed = 0.25;
    this.ease.y += key[1] * this.acc;
    this.ease.x += key[0] * this.acc;
    this.ease.x = this.ease.x > this.maxspeed ? this.maxspeed : this.ease.x;
    this.ease.x = this.ease.x < -this.maxspeed ? -this.maxspeed : this.ease.x;
    this.ease.y = this.ease.y > this.maxspeed ? this.maxspeed : this.ease.y;
    this.ease.y = this.ease.y < -this.maxspeed ? -this.maxspeed : this.ease.y;
    if (!key[1]) {
      if (this.ease.y > this.dec) this.ease.y -= this.dec;
      else if (this.ease.y < -this.dec) this.ease.y += this.dec;
      else this.ease.y = 0;
    }
    if (!key[0]) {
      if (this.ease.x > this.dec) this.ease.x -= this.dec;
      else if (this.ease.x < -this.dec) this.ease.x += this.dec;
      else this.ease.x = 0;
    }
    if (!this.ease.x && !this.ease.y) return;
    this.local.z += Math.sin(r) * this.ease.x + Math.cos(r) * this.ease.y;
    this.local.x += Math.cos(r) * this.ease.x - Math.sin(r) * this.ease.y;
    this.update(wait);
  }
  getTri() {
    return this.geometry;
  }
  getHeight(x2, z) {
    x2 *= this.rx;
    z *= this.rz;
    x2 += this.sample[0] * 0.5;
    z += this.sample[1] * 0.5;
    x2 = Math.floor(x2);
    z = Math.floor(z);
    var h = this.isTurn ? this.height[this.findId2(x2, z)] : this.height[this.findId(x2, z)];
    return h * this.size[1] + this.position.y;
  }
  findIdZ(x2, z) {
    return x2 + z * this.sampleZ[1];
  }
  findId(x2, z) {
    return x2 + z * this.sample[1];
  }
  findId2(x2, z) {
    return z + -x2 * this.sample[0] || 1;
  }
  /*findId3( x, z ){
  
          return z+(x*this.sample[0]) //|| 1;
  
      }*/
  findPoint(x2, z) {
    var i = this.lng, n2;
    while (i--) {
      n2 = i * 3;
      if (this.vertices[n2] === x2 && this.vertices[n2 + 2] === z) return i;
    }
    return -1;
  }
  getReverseID() {
    this.invId = [];
    let i = this.lngZ, x2, z;
    const sz = this.sampleZ[1] - 1;
    this.sampleZ[0] - 1;
    while (i--) {
      x2 = i % this.sampleZ[0];
      z = Math.floor(i * this.ratioZ);
      if (this.isReverse) z = sz - z;
      this.invId[i] = this.isTurned ? this.lngZ - 1 - this.findIdZ(z, x2) : this.findIdZ(x2, z);
    }
  }
  set(o) {
    if (o.ease) this.easing(o.key, o.azimut);
    if (o.decal) this.decal(o.decal, true);
  }
  decal(v, wait) {
    this.local.x += v[0];
    this.local.y += v[1];
    this.local.z += v[2];
    this.update(wait);
  }
  updateUv() {
    if (this.isWater) {
      this.material.normalMap.offset.x += 2e-3;
      this.material.normalMap.offset.y += 1e-3;
    } else {
      let v = { x: this.local.x * this.ruvx, y: this.local.z * this.ruvy };
      if (this.material.map) this.material.map.offset.copy(v);
      if (this.material.normalMap) this.material.normalMap.offset.copy(v);
    }
  }
  distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  clamp(v, min = 0, max2 = 1) {
    v = v < min ? min : v;
    v = v > max2 ? max2 : v;
    return v;
  }
  update(wait) {
    let v = this.pp;
    let cc = [1, 1, 1];
    let i = this.lng, n2, x2, z, c, id, result, idz;
    let oldz, oldh, ccY, ccc;
    while (i--) {
      n2 = i * 3;
      x2 = i % this.sample[0];
      z = Math.floor(i * this.ratio);
      v.set(x2 + this.local.x * this.rx, this.local.y, z + this.local.z * this.rz);
      c = math$2.noise(v, this.data);
      if (this.isIsland) {
        let d = 1 - this.distance({ x: x2, y: z }, { x: (this.sample[0] - 1) * 0.5, y: (this.sample[1] - 1) * 0.5 }) / ((this.sample[0] - 1) * 0.5);
        d *= 4;
        d = this.clamp(d);
        c *= d;
      }
      c = Math.pow(c, this.data.expo);
      c = this.clamp(c);
      if (this.ttype === "road") {
        if (oldz === z) {
          if (x2 === 1 || x2 === 2 || x2 === 29 || x2 === 30) c = oldh + 0.1;
          else c = oldh;
        } else {
          oldz = z;
          oldh = c;
        }
      }
      this.height[i] = c;
      ccY = c * this.size[1] + this.deep;
      this.vertices[n2 + 1] = ccY;
      result = this.isAbsolute ? c : c * this.size[1];
      if (this.zid[i] !== void 0) {
        idz = this.zid[i];
        id = this.changeId ? this.invId[idz] : idz;
        this.heightData[id] = result;
        if (this.verticesZ) this.verticesZ[idz * 3 + 1] = ccY;
      }
      if (this.isWater) {
        cc = [c * this.colorBase.r, c * this.colorBase.g, c * this.colorBase.b];
      } else {
        cc = [c, 0, 0];
      }
      ccc = cc[0];
      this.colors[n2] = ccc;
      this.colors[n2 + 1] = ccc;
      this.colors[n2 + 2] = ccc;
    }
    if (this.isBorder) {
      let j = this.lng2, h;
      while (j--) {
        n2 = j * 3;
        if (this.list[j] !== -1) {
          h = this.height[this.list[j]];
          this.borderVertices[n2 + 1] = h * this.size[1] + this.deep;
          ccc = math$2.clamp(h + 0.25, 0.25, 1);
          this.borderColors[n2] = ccc;
          this.borderColors[n2 + 1] = ccc;
          this.borderColors[n2 + 2] = ccc;
        } else {
          this.borderColors[n2] = this.colorBase.r;
          this.borderColors[n2 + 1] = this.colorBase.g;
          this.borderColors[n2 + 2] = this.colorBase.b;
        }
      }
    }
    if (wait) this.needUpdate = true;
    else this.updateGeometry();
    if (this.ready) this.physicsUpdate(this.name, this.heightData);
    this.ready = true;
  }
  step(n2) {
    if (!this.needUpdate) return;
    this.updateGeometry();
    this.needUpdate = false;
  }
  updateGeometry() {
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.computeVertexNormals();
    this.updateUv();
    if (this.geometryZ) this.geometryZ.attributes.position.needsUpdate = true;
    if (this.isBorder) {
      this.borderGeometry.attributes.position.needsUpdate = true;
      this.borderGeometry.attributes.color.needsUpdate = true;
    }
  }
};
var TerrainShader = {
  fragmentAdd: (
    /* glsl */
    `
        uniform vec4 clevels;
        uniform float randomUv;

        uniform sampler2D noise;

        uniform sampler2D normalMap1;
        uniform sampler2D normalMap2;

        uniform sampler2D roughnessMap1;
        uniform sampler2D roughnessMap2;

        uniform float aoMapIntensity;
        uniform sampler2D map1;
        uniform sampler2D map2;

        vec4 textureMAP( sampler2D mapper, in vec2 uv ){
            if( randomUv == 1.0 ) return textureNoTile( mapper, uv );
            else return texture2D( mapper, uv );
        }

        vec4 MappingMix( float slope, vec4 level, vec4 rocks, vec4 grasss, vec4 sands ){
            vec4 cc = rocks;
            if (slope < level.x) cc = grasss;
            if (slope < level.z) cc = sands;
            if (slope == 0.0 ) cc = sands;
            //if (( slope < level.x ) && (slope >= level.y)) cc = mix( grasss , rocks, (slope - level.y) * (1. / (level.x - level.y)));
            //if (( slope < level.y ) && (slope >= level.z)) cc = mix( sands , grasss, (slope - level.z) * (1. / (level.y - level.z)));

            float d = level.y;
            float rx = 1.0/level.y;

            if (( slope < level.x + d ) && (slope > level.x)) cc = mix( grasss , rocks, ( slope - (level.x) ) * rx );

            d = level.w;
            rx = 1.0/level.w;
            if (( slope < level.z + d ) && (slope > level.z )) cc = mix( sands , grasss, ( slope - (level.z) ) * rx );

            //cc = mix( grasss, cc, smoothstep(0.0,1.0, slope)*20.0 );
            return cc;
        }
    `
  ),
  // map_fragment.glsl
  map: (
    /* glsl */
    `
        #ifdef USE_MAP

            vec4 sand = textureMAP( map, vMapUv );
            vec4 grass = textureMAP( map1, vMapUv );
            vec4 rock = textureMAP( map2, vMapUv ); 

            vec4 sampledDiffuseColor = MappingMix(vColor.r, clevels, rock, grass, sand);

            diffuseColor *= sampledDiffuseColor;

        #endif
    `
  ),
  // normal_fragment_maps
  normal: (
    /* glsl */
    `

        #ifdef USE_NORMALMAP_OBJECTSPACE

            normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

            #ifdef FLIP_SIDED

                normal = - normal;

            #endif

            #ifdef DOUBLE_SIDED

                normal = normal * faceDirection;

            #endif

            normal = normalize( normalMatrix * normal );

        #elif defined( USE_NORMALMAP_TANGENTSPACE )

            vec4 sandN = textureMAP( normalMap, vNormalMapUv );
            vec4 grassN = textureMAP( normalMap1, vNormalMapUv );
            vec4 rockN = textureMAP( normalMap2, vNormalMapUv );
            vec3 mapN = MappingMix(vColor.r, clevels, rockN, grassN, sandN).xyz * 2.0 - 1.0;

            ///vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;

            mapN.xy *= normalScale;
            normal = normalize( tbn * mapN );

        #elif defined( USE_BUMPMAP )

            normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

        #endif
    `
  ),
  alphamap: (
    /* glsl */
    `
        #ifdef USE_ALPHAMAP
            diffuseColor.a = opacity +( texture2D( alphaMap, vAlphaMapUv ).g * opacity) * (1.0-opacity);
        #endif
    `
  )
};
var Terrain = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "terrain";
    this.num = Num[this.type];
  }
  step() {
    root.Ar;
    root.ArPos[this.type];
    let i = this.list.length, s;
    while (i--) {
      s = this.list[i];
      s.step();
    }
  }
  add(o = {}) {
    this.setName(o);
    if (root.engine === "JOLT") {
      o.isAbsolute = true;
      o.isTurned = false;
    }
    if (root.engine === "PHYSX") {
      o.isAbsolute = true;
      o.isTurned = true;
    }
    if (root.engine === "HAVOK") {
      o.isAbsolute = true;
      o.isTurned = true;
      o.isReverse = false;
    }
    if (root.engine !== "OIMO") {
      o.zone = o.zone || 0.25;
    }
    const t2 = new Landscape(o);
    Mat.extendShader(t2.material, t2.material.onBeforeCompile);
    t2.physicsUpdate = (name, h) => {
      root.flow.tmp.push({ name, heightData: h });
    };
    this.addToWorld(t2, o.id);
    root.post({ m: "add", o: toPhysics(t2) });
    return t2;
  }
  set(o = {}, b = null) {
    if (b === null) b = this.byName(o.name);
    if (b === null) return;
    b.set(o);
  }
};
var toPhysics = function(t2) {
  const o = {
    name: t2.name,
    type: t2.type,
    pos: t2.position.toArray(),
    quat: root.engine === "PHYSX" ? [0, 0, 0, 1] : t2.quaternion.toArray()
    // physx terrain can't turn !!
  };
  if (root.engine === "PHYSX" || root.engine === "AMMO" || root.engine === "HAVOK" || root.engine === "JOLT") {
    o.type = "terrain";
    o.size = t2.sizeZ;
    o.sample = t2.sampleZ;
    o.zone = t2.zone;
    o.heightData = t2.heightData;
  } else {
    o.type = "mesh";
    o.v = MathTool.getVertex(t2.geometry, root.engine === "OIMO");
    o.index = root.engine === "OIMO" ? null : MathTool.getIndex(t2.geometry);
  }
  return o;
};
var Solver = class extends Item {
  constructor() {
    super();
    this.Utils = Utils;
    this.type = "solver";
  }
  step() {
    const AR = root.Ar;
    const N = root.ArPos[this.type];
    let i = this.list.length, n2;
    while (i--) {
      n2 = N + i * Num[this.type];
      this.list[i].update(AR, n2);
    }
  }
  ///
  add(o = {}) {
    this.setName(o);
    let solver = new Articulation(o);
    this.addToWorld(solver, o.id);
    root.post({ m: "add", o });
    return solver;
  }
  set(o = {}) {
  }
};
var Articulation = class {
  //extends Basic3D 
  constructor(o) {
    this.name = o.name;
    this.type = "solver";
    this.needData = o.needData || false;
    this.bones = [];
    this.joints = [];
    this.jid = 0;
    this.speed = 1;
  }
  addBone(name) {
    this.bones.push(name);
  }
  dispose() {
    root.motor.remove(this.bones, true);
  }
  update(AR, n2) {
    if (!this.needData) return;
    let k = this.joints.length, j, m2;
    while (k--) {
      m2 = n2 + k * 7;
      j = this.joints[k];
      j.data.target.x = AR[m2 + 0];
      j.data.target.y = AR[m2 + 1];
      j.data.target.z = AR[m2 + 2];
      j.data.target.rx = AR[m2 + 3];
      j.data.target.ry = AR[m2 + 4];
      j.data.target.rz = AR[m2 + 5];
      j.data.target.count = AR[m2 + 6];
    }
  }
  start() {
    root.post({ m: "startArticulation", o: { name: this.name } });
  }
  stop() {
    root.post({ m: "stopArticulation", o: { name: this.name } });
  }
  commonInit() {
    root.post({ m: "commonInitArticulation", o: { name: this.name } });
  }
  addJoint(o) {
    this.jid = this.joints.length;
    o.name = o.name || this.name + "_Joint_" + this.jid;
    o.solver = this.name;
    if (o.rot1 !== void 0) {
      o.quat1 = MathTool.quatFromEuler(o.rot1);
      delete o.rot1;
    }
    if (o.rot2 !== void 0) {
      o.quat2 = MathTool.quatFromEuler(o.rot2);
      delete o.rot2;
    }
    if (o.type !== "fixe") {
      this.joints.push(new SolverJoint(o, this));
    }
    root.post({ m: "addSolverJoint", o });
  }
  /*addBone ( mesh ) {
  
  		console.log('bone is add')
  
  		this.add( mesh );
  
  	}*/
  driveJoints(dt2) {
    let isInDrive = false;
    let k = this.joints.length, j, d, nup = [];
    while (k--) {
      j = this.joints[k];
      j.update(dt2);
      d = j.isDrive;
      if (j.nup) nup.push(j.nup);
      isInDrive = d ? true : isInDrive;
    }
    if (isInDrive) root.motor.change(nup);
    else {
      if (this.resolve) {
        this.resolve();
        delete this.resolve;
      }
    }
  }
  setAngles(angles, time) {
    if (!angles) return;
    let j = this.joints.length;
    while (j--) {
      this.joints[j].pose(angles[j] !== void 0 ? angles[j] : 0, time !== void 0 ? time : this.speed);
    }
    return new Promise((resolve) => this.resolve = resolve);
  }
};
var SolverJoint = class {
  constructor(o, solver) {
    this.name = o.name;
    this.solver = solver;
    this.type = "solverJoint";
    this.isDrive = false;
    this.current = 0;
    this.tmp = 0;
    this.target = 0;
    this.start = 0;
    this.time = 0;
    this.nup = null;
    this.data = {
      target: { x: 0, y: 0, z: 0, rx: 0, ry: 0, rz: 0, count: 0 }
      //target:{ x:0, y:0, z:0, twist:0, swing1:0, swing2:0, count:0 },
    };
    if (o.limits) {
      this.driveType = o.limits[0][0];
      this.min = o.limits[0][1];
      this.max = o.limits[0][2];
    }
    if (o.position) o.target = o.position;
    if (o.target) {
      let i = o.target.length, t2;
      while (i--) {
        t2 = o.target[i];
        this.data.target[t2[0]] = t2[1];
      }
    }
  }
  start() {
  }
  pose(target, time) {
    this.target = MathTool.clamp(target, this.min, this.max);
    this.current = MathTool.clamp(this.data.target[this.driveType], this.min, this.max);
    if (this.target === this.current) return;
    this.start = this.current;
    this.tmp = 0;
    this.time = time;
    this.isDrive = true;
  }
  update(dt2) {
    if (this.isDrive) {
      this.tmp += dt2 * this.time;
      let t2 = this.tmp;
      t2 = t2 > 1 ? 1 : t2;
      let move = MathTool.lerp(this.start, this.target, t2);
      this.nup = { name: this.name, drivesTarget: [[this.driveType, move]] };
      if (t2 === 1) this.isDrive = false;
    } else {
      this.nup = null;
    }
  }
};
var Textfield = class extends Mesh {
  constructor(o = {}) {
    super(new PlaneGeometry(), new MeshBasicMaterial({ polygonOffset: true, polygonOffsetFactor: -4 }));
    this.name = o.nam || "text";
    this.canvas = null;
    this.w = o.w || 0;
    this.h = o.h || 0;
    this.weight = o.weight ?? 700;
    this.font = o.font ?? "'Mulish', sans-serif";
    this.fontSize = o.fontSize ?? 32;
    this.backgroundColor = o.backgroundColor ?? "#00000000";
    this.fontColor = o.fontColor ?? "#FFFFFF";
    this.material.alphaTest = 0.5;
    this.set(o.text);
    if (o.pos) this.position.fromArray(o.pos);
    if (o.rot) this.quaternion.fromArray(MathTool.quatFromEuler(o.rot));
  }
  set(str) {
    if (!this.canvas) this.canvas = document.createElement("canvas");
    let ctx = this.canvas.getContext("2d"), w, h, r;
    ctx.font = this.weight + " " + this.fontSize + "px " + this.font;
    let metrics = ctx.measureText(str);
    w = 2 ** Math.ceil(Math.log2(metrics.width));
    h = 2 ** Math.ceil(Math.log2(ctx.measureText("M").width));
    this.canvas.width = w;
    this.canvas.height = h;
    ctx.fillStyle = this.backgroundColor;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = this.fontColor;
    ctx.font = this.weight + " " + this.fontSize + "px " + this.font;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(str, w * 0.5, h * 0.5);
    this.material.map = new CanvasTexture(this.canvas);
    if (this.h !== 0) {
      r = this.h / h;
      this.scale.set(w * r, this.h, 0);
    } else if (this.w !== 0) {
      r = this.w / h;
      this.scale.set(this.w, h * r, 0);
    } else {
      this.scale.set(w * 0.025, h * 0.025, 0);
    }
  }
  dispose() {
    this.parent.remove(this);
    this.material.map.dispose();
    this.material.dispose();
    this.geometry.dispose();
  }
};
var Nb = 0;
var Button = class {
  constructor(o = {}) {
    this.down = false;
    this.time = o.time || 250;
    this.p = o.pos || [0, 0, 0];
    this.type = o.type || "box";
    this.name = o.name || "button" + Nb++;
    this.pos = o.pos || [0, 0, 0];
    this.size = o.size || [1, 1, 1];
    this.radius = o.radius || 0;
    this.axe = o.axe !== void 0 ? o.axe : 1;
    this.fontSize = o.fontSize || 0.8;
    this.fontScale = o.fontScale || 1;
    this.extraForce = true;
    this.decal = this.type === "sphere" ? this.size[1] * 0.5 : this.size[1] * 0.5 - this.radius;
    if (this.type !== "sphere") this.pos[this.axe] += this.decal;
    this.origin = this.pos[this.axe];
    let height = this.size[this.axe] - this.radius * 2;
    this.range = [this.origin - height, this.origin];
    this.value = this.origin;
    this.target = this.origin;
    this.speed = this.size[this.axe] / 3 / this.size[this.axe];
    this.callback = function() {
      console.log("action down");
    };
    if (o.callback) {
      this.callback = o.callback;
      delete o.callback;
    }
    o.button = true;
    o.pos = this.pos;
    if (!o.material) o.material = "button";
    o.kinematic = true;
    o.mask = 1;
    this.timeout = null;
    this.b = root.motor.add(o);
    this.b.userData["action"] = this.action.bind(this);
    this.b.userData["out"] = this.out.bind(this);
    this.b.userData["direct"] = this.callback.bind(this);
    if (o.text) this.addText(o.text);
  }
  addText(txt, size) {
    this.fontSize = this.type === "box" ? this.size[this.axe] * 0.8 : this.size[0] * 0.8;
    this.fontSize *= this.fontScale;
    let dt2 = { text: txt, pos: [0, this.size[1] * 0.5, 0], rot: [-90, 0, 0], h: this.fontSize };
    if (this.axe === 2) dt2 = { text: txt, pos: [0, 0, this.size[2] * 0.5], rot: [0, 0, 0], h: this.fontSize };
    this.txt = new Textfield(dt2);
    this.b.add(this.txt);
  }
  action(p2) {
    if (this.down) return;
    this.down = true;
    this.target = this.range[0];
    if (this.extraForce) root.motor.explosion(p2 || this.p, this.size[0] * 2, 0.01);
    this.callback();
  }
  out() {
    if (!this.down) return;
    this.down = false;
    this.target = this.range[1];
    if (this.extraForce) root.motor.explosion(this.p, this.size[0] * 2, 0.01);
  }
  update() {
    if (this.value !== this.target) {
      this.value = MathTool.lerp(this.value, this.target, this.speed);
      let t2 = MathTool.nearEquals(this.value, this.target, 1e-4);
      if (!t2) {
        this.pos[this.axe] = this.value;
        root.motor.change({ name: this.b.name, pos: this.pos });
      } else {
        this.value = this.target;
      }
    }
  }
  dispose() {
    if (this.txt) this.txt.dispose();
  }
};
var _box = new Box3();
var BoxHelper = class extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    let c = new Color(color);
    let ar = [];
    let i = 8;
    while (i--) ar.push(c.r, c.g, c.b);
    const colors = new Float32Array(ar);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    geometry.setAttribute("color", new BufferAttribute(colors, 3));
    super(geometry, new LineBasicMaterial({ vertexColors: true, toneMapped: false }));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box.setFromObject(this.object);
    }
    if (_box.isEmpty()) return;
    const min = _box.min;
    const max2 = _box.max;
    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max2.x;
    array[1] = max2.y;
    array[2] = max2.z;
    array[3] = min.x;
    array[4] = max2.y;
    array[5] = max2.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max2.z;
    array[9] = max2.x;
    array[10] = min.y;
    array[11] = max2.z;
    array[12] = max2.x;
    array[13] = max2.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max2.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max2.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.object = source.object;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var Container = class {
  constructor(o = {}) {
    this.isCompound = true;
    this.remplace = o.remplace || false;
    this.init(o);
  }
  init(o = {}) {
    const intern = o.intern || false;
    let s = o.size || [5, 3, 8];
    let p2 = o.pos || [0, 2, 0];
    let w = o.wall || 0.1;
    if (o.size[3] !== void 0) w = o.size[3];
    if (w <= 0) w = 0.01;
    let mw = w * 0.5;
    let xw = w * 2;
    if (!o.face) o.face = {};
    let f = { up: 1, down: 1, left: 1, right: 1, front: 1, back: 1, ...o.face };
    delete o.face;
    const data = [];
    if (intern) {
      if (f.up === 1) data.push({ pos: [0, s[1] * 0.5 + mw, 0], size: [s[0] + xw, w, s[2] + xw] });
      if (f.down === 1) data.push({ pos: [0, -mw - s[1] * 0.5, 0], size: [s[0] + xw, w, s[2] + xw] });
      if (f.left === 1) data.push({ pos: [-mw - s[0] * 0.5, 0, 0], size: [w, s[1], s[2]] });
      if (f.right === 1) data.push({ pos: [s[0] * 0.5 + mw, 0, 0], size: [w, s[1], s[2]] });
      if (f.back === 1) data.push({ pos: [0, 0, -mw - s[2] * 0.5], size: [s[0] + xw, s[1], w] });
      if (f.front === 1) data.push({ pos: [0, 0, s[2] * 0.5 + mw], size: [s[0] + xw, s[1], w] });
    } else {
      if (f.up === 1) data.push({ pos: [0, s[1] * 0.5 - mw, 0], size: [s[0], w, s[2]] });
      if (f.down === 1) data.push({ pos: [0, mw - s[1] * 0.5, 0], size: [s[0], w, s[2]] });
      if (f.left === 1) data.push({ pos: [mw - s[0] * 0.5, 0, 0], size: [w, s[1] - xw, s[2]] });
      if (f.right === 1) data.push({ pos: [s[0] * 0.5 - mw, 0, 0], size: [w, s[1] - xw, s[2]] });
      if (f.back === 1) data.push({ pos: [0, 0, mw - s[2] * 0.5], size: [s[0] - xw, s[1] - xw, w] });
      if (f.front === 1) data.push({ pos: [0, 0, s[2] * 0.5 - mw], size: [s[0] - xw, s[1] - xw, w] });
    }
    const faces = [];
    let i = data.length, n2 = 0, pp, d;
    while (i--) {
      d = data[n2];
      pp = this.isCompound ? d.pos : MathTool.addArray(p2, d.pos);
      faces.push({ type: "box", size: d.size, pos: pp, material: o.material });
      n2++;
    }
    if (this.isCompound) {
      let mesh = null;
      if (this.remplace) {
        if (o.radius === 0) mesh = new Mesh(new BoxGeometry(s[0], s[1], s[2]));
        else mesh = new Mesh(new ChamferBox(s[0], s[1], s[2], o.radius || mw));
        if (o.material) {
          if (o.material === "debug") {
            mesh = new BoxHelper(mesh, o.color);
            o.material = "line";
          }
        }
      }
      root.motor.add({
        ...o,
        mesh,
        shapes: faces,
        type: "compound"
      });
    } else {
      root.motor.add(faces);
    }
  }
};
var MouseTool = class {
  constructor(controler, mode = "drag") {
    this.needRay = false;
    this.moveDirect = false;
    this.moveDeep = false;
    this.mode = mode;
    this.option = {};
    this.overObj = null;
    this.controler = controler;
    this.dom = this.controler.domElement;
    this.selected = null;
    this.buttonRef = null;
    this.release = false;
    this.numBullet = 0;
    this.maxBullet = 10;
    this.sticky = false;
    this.pz = 0;
    this.isActive = false;
    this.raycastTest = false;
    this.firstSelect = false;
    this.mouseDown = false;
    this.mouseDown2 = false;
    this.mouseMove = false;
    this.decal = new Vector3();
    this.tmpPos = new Vector3();
    this.tmpD = new Vector3();
    this.mouse = new Vector2();
    this.oldMouse = new Vector2();
    this.raycast = new Raycaster();
    this.raycast.far = 1e3;
    this.button = 0;
    this.pos = new Vector3();
    this.velocity = new Vector3();
    this.angle = 0;
    this.helper = null;
    this.dragPlane = null;
    this.overLock = false;
    this.activeDragMouse(true);
  }
  addDrag() {
    if (this.dragPlane) return;
    this.helper = new MoveHelper();
    this.dragPlane = new Mesh(new PlaneGeometry(1, 1), Mat.get("hide"));
    this.dragPlane.castShadow = false;
    this.dragPlane.receiveShadow = false;
    this.dragPlane.scale.set(1, 1, 1).multiplyScalar(200);
    root.scenePlus.add(this.helper);
    root.scenePlus.add(this.dragPlane);
  }
  clearDrag() {
    if (!this.dragPlane) return;
    root.scenePlus.remove(this.dragPlane);
    root.scenePlus.remove(this.helper);
    this.dragPlane.geometry.dispose();
    this.helper.geometry.dispose();
    this.dragPlane = null;
    this.helper = null;
  }
  setMode(mode, o = {}) {
    if (mode === this.mode) return;
    this.mode = mode;
    this.option = o;
    if (this.mode === "blast" && this.option.visible) root.motor.initParticle();
  }
  activeDragMouse(b) {
    if (b) {
      if (!this.isActive) {
        this.dom.addEventListener("pointermove", this.mousemove.bind(this), false);
        this.dom.addEventListener("pointerdown", this.mousedown.bind(this), false);
        document.addEventListener("pointerup", this.mouseup.bind(this), false);
        this.controler.addEventListener("end", this.controleEnd.bind(this), false);
        this.controler.addEventListener("start", this.controleStart.bind(this), false);
        this.isActive = true;
        this.raycastTest = true;
      }
    } else {
      if (this.isActive) {
        this.dom.removeEventListener("pointermove", this.mousemove.bind(this));
        this.dom.removeEventListener("pointerdown", this.mousedown.bind(this));
        document.removeEventListener("pointerup", this.mouseup.bind(this));
        this.controler.removeEventListener("end", this.controleEnd.bind(this));
        this.controler.removeEventListener("start", this.controleStart.bind(this), false);
        this.isActive = false;
      }
    }
  }
  controleEnd(e) {
    this.raycastTest = true;
    if (this.controler.getInfo) this.controler.getInfo();
  }
  controleStart(e) {
    this.raycastTest = false;
  }
  controleChange(e) {
  }
  getMouse(e) {
    if (root.viewSize) {
      this.mouse.x = e.offsetX / root.viewSize.w * 2 - 1;
      this.mouse.y = -(e.offsetY / root.viewSize.h) * 2 + 1;
    } else {
      this.mouse.x = e.offsetX / this.dom.clientWidth * 2 - 1;
      this.mouse.y = -(e.offsetY / this.dom.clientHeight) * 2 + 1;
    }
    this.button = e.pointerType !== "touch" ? e.button : 0;
  }
  contextmenu(e) {
  }
  mousedown(e) {
    if (this.sticky) {
      this.unSelect();
      console.log("unstick");
    }
    this.getMouse(e);
    switch (this.mode) {
      case "drag":
        this.drag();
        break;
      case "shoot":
        this.shoot();
        break;
      case "blast":
        this.blast();
        break;
      case "build":
        this.build();
        break;
    }
  }
  mouseup(e) {
    this.release = true;
    document.body.style.cursor = "auto";
    this.mouseMove = this.oldMouse.distanceTo(this.mouse) < 0.01 ? false : true;
    this.mouseDown = false;
    this.mouseDown2 = false;
    root.mouseDown = false;
    if (this.sticky) {
      this.controler.enabled = true;
      return;
    }
    this.unSelect();
    this.resetButton();
  }
  mousemove(e) {
    switch (this.mode) {
      case "drag":
        this.getMouse(e);
        this.needRay = true;
        break;
    }
  }
  castray() {
    let inters, m2, g2, h, id, cursor = "auto";
    if (this.selected !== null) {
      this.raycast.setFromCamera(this.mouse, this.controler.object);
      inters = this.raycast.intersectObject(this.dragPlane);
      if (inters.length && this.mouseDown) {
        this.moveSelect(inters[0].point);
      }
    } else {
      if (!this.raycastTest) return;
      this.controler.enableRotate = false;
      this.controler.enablePan = false;
      this.raycast.setFromCamera(this.mouse, this.controler.object);
      inters = this.raycast.intersectObjects(root.scene.children, true);
      this.tmpSelected = null;
      if (inters.length > 0) {
        g2 = inters[0].object;
        id = inters[0].instanceId;
        if (id !== void 0) {
          m2 = root.motor.byName(g2.getByName(id));
        } else {
          if (g2.parent !== root.scene) {
            h = g2.parent;
            if (h.parent !== root.scene) m2 = h.parent;
            else m2 = h;
          } else m2 = g2;
        }
        if (this.mouseDown2) {
          if (m2.extra) m2.extra(m2.name);
        }
        if (m2 && !m2.isButton) {
          cursor = this.select(m2, inters[0].point);
        } else cursor = this.actionButton(m2, inters[0]);
      } else {
        this.resetOver();
        this.controler.enableRotate = true;
        this.controler.enablePan = true;
      }
      if (this.release) {
        this.release = false;
        this.controler.enableRotate = true;
        this.controler.enablePan = true;
        cursor = "auto";
        this.resetOver();
      }
      document.body.style.cursor = cursor;
    }
  }
  drag() {
    if (!this.mouseDown) {
      if (this.firstSelect) this.firstSelect = false;
      this.oldMouse.copy(this.mouse);
    }
    if (this.button === 2) {
      this.mouseDown2 = true;
    }
    this.mouseDown = true;
    root.mouseDown = true;
    this.needRay = true;
  }
  blast() {
    let hit = null;
    this.raycast.setFromCamera(this.mouse, this.controler.object);
    let inters = this.raycast.intersectObjects(root.scene.children, true);
    if (inters.length > 0) {
      if (!inters[0].object.isButton) hit = inters[0];
      else inters[0].object.parent.userData.direct();
    } else {
      inters = this.raycast.intersectObjects(root.scenePlus.children, true);
      if (inters.length > 0) hit = inters[0];
    }
    const o = this.option;
    if (hit) {
      root.motor.explosion(hit.point, o.radius || 3, o.power || 0.1);
      if (o.visible) root.motor.addParticle({
        name: "blast",
        type: "cube",
        position: hit.point.toArray(),
        numParticles: 60,
        radius: 0.2,
        radiusRange: 0.1,
        //accelerationRange:[0.3,0.3,0.3],
        acceleration: [5 * 10, 5, 5 * 10],
        lifeTime: 0.5,
        endTime: 0.5,
        startTime: 0,
        gravity: [0, 0.2, 0],
        startSize: 0.5,
        endSize: 0.1,
        //spinSpeedRange:2,
        tween: "outQuad"
        //velocityRange: [ 0.6, 0.6, 0.6 ]
        //lifeTimeRange:1,
        //startTime: 0,
        //startSize: 0.1,
      });
    }
  }
  shoot() {
    this.raycast.setFromCamera(this.mouse, this.controler.object);
    this.pos.copy(this.raycast.ray.direction).add(this.raycast.ray.origin);
    this.velocity.copy(this.raycast.ray.direction).multiplyScalar(60);
    root.motor.add({
      name: "bullet_" + this.numBullet,
      type: "sphere",
      density: 20,
      size: [0.2],
      material: "chrome",
      pos: this.pos.toArray(),
      linearVelocity: this.velocity.toArray(),
      bullet: true
      /*ccdThreshold:0.0000001,
               ccdRadius:0.1,*/
    });
    this.numBullet++;
    if (this.numBullet > this.maxBullet) this.numBullet = 0;
  }
  resetButton() {
    if (this.buttonRef) {
      if (this.buttonRef.userData.out) this.buttonRef.userData.out();
      this.buttonRef = null;
    }
    this.raycastTest = true;
    this.selected = null;
    this.firstSelect = true;
    this.controler.enableRotate = true;
    this.controler.enablePan = true;
  }
  actionButton(obj, inters) {
    if (this.buttonRef) {
      if (this.buttonRef.name !== obj.name) {
        if (this.buttonRef.userData.out) this.buttonRef.userData.out();
        this.buttonRef = obj;
      }
    } else {
      if (this.mouseDown) this.buttonRef = obj;
    }
    if (this.mouseDown && this.buttonRef.userData.action) {
      let pos = inters.point;
      this.buttonRef.userData.action(pos);
    }
    return "pointer";
  }
  setOver(obj) {
    if (!obj) return;
    if (this.overObj) {
      if (obj.name !== this.overObj.name) this.resetOver();
    }
    this.overObj = obj;
    if (this.overObj.over) this.overObj.over(true);
  }
  resetOver() {
    if (!this.overObj) return;
    if (this.overObj.over) this.overObj.over(false);
    this.overObj = null;
  }
  select(obj, point) {
    if (!this.mouseDown) this.setOver(obj);
    if (!this.mouseDown || this.selected === obj) {
      return "grab";
    }
    this.pz = 0;
    let pos = point;
    let quat = [0, 0, 0, 1];
    this.selected = obj;
    this.decal.copy(pos).sub(this.selected.position);
    this.tmpPos.copy(pos).sub(this.decal);
    this.angle = this.controler.getAzimuthalAngle();
    let q = this.selected.quaternion;
    quat = [q._x, q._y, q._z, q._w];
    this.addDrag();
    this.dragPlane.rotation.set(0, this.angle, 0);
    this.dragPlane.position.copy(pos);
    this.dragPlane.position.y = 0;
    this.helper.position.copy(pos);
    let p2 = pos.toArray();
    let revert = false;
    root.motor.change({ name: this.selected.name, neverSleep: true, wake: true });
    if (this.moveDirect) {
      root.motor.change({ name: this.selected.name, kinematic: false, gravity: false, damping: [0.9, 0.9] });
    } else {
      let def = [-0.1, 0.1, 600, 1];
      let defr = [-0.1, 0.1, 600, 1];
      let notUseKinematic = root.engine === "OIMO" || root.engine === "RAPIER" || root.engine === "JOLT";
      let jtype = this.selected.link === 0 ? "fixe" : "d6";
      if (root.engine === "JOLT") jtype = "fixe";
      let limite = [["x", ...def], ["y", ...def], ["z", ...def], ["rx", ...defr], ["ry", ...defr], ["rz", ...defr]];
      if (root.engine === "HAVOK") limite = [["x", ...def], ["y", ...def], ["z", ...def]];
      if (root.engine === "OIMO") {
        revert = true;
        jtype = this.selected.link === 0 ? "fixe" : "spherical";
        limite = [["x", ...def], ["y", ...def], ["z", ...def]];
      }
      if (root.engine === "HAVOK") {
        revert = true;
        jtype = this.selected.link === 0 ? "fixe" : "spherical";
        limite = [-180, 180, 0.1, 0.1];
      }
      root.motor.add([
        {
          name: "mouse",
          type: "null",
          pos: p2,
          quat,
          kinematic: notUseKinematic ? false : true
          //mass:10,///10000000,
          //gravityFactor:0, 
        },
        {
          name: "mouseJoint",
          type: "joint",
          mode: jtype,
          lm: limite,
          sd: [4, 1],
          autoDrive: true,
          b1: revert ? this.selected.name : "mouse",
          b2: revert ? "mouse" : this.selected.name,
          worldAnchor: p2,
          //worldQuat: quat,
          /*pos1: p, 
          quat1: quat,
          pos2: [0,0,0], 
          quat2: [0,0,0,1],*/
          //worldAxis:[1,0,0],
          visible: false
        }
      ]);
    }
    return "grabbing";
  }
  moveSelect(point) {
    if (this.selected === null) return;
    if (point) {
      this.tmpPos.copy(point).sub(this.decal);
    }
    if (this.moveDeep) {
      let y = this.selected.position.y;
      let diff = y - this.tmpPos.y;
      this.tmpPos.y = y;
      this.tmpD.set(0, 0, diff).applyAxisAngle({ x: 0, y: 1, z: 0 }, this.angle);
      this.tmpPos.add(this.tmpD);
    }
    this.helper.position.copy(this.tmpPos);
    let pos = this.tmpPos.toArray();
    if (this.moveDirect) {
      root.motor.change({ name: this.selected.name, pos, reset: true });
    } else {
      root.motor.change({ name: "mouse", pos: point.toArray(), lockPos: true }, true);
    }
  }
  unSelect() {
    if (this.selected === null) return;
    this.resetOver();
    this.clearDrag();
    if (this.moveDirect) {
      root.motor.change({ name: this.selected.name, kinematic: false, wake: true, gravity: true, damping: [0, 0.1] });
    } else {
      root.motor.remove(["mouseJoint", "mouse"]);
      root.motor.change({ name: this.selected.name, neverSleep: false, wake: true });
    }
    this.raycastTest = true;
    this.selected = null;
    this.firstSelect = true;
  }
  step() {
    if (this.needRay) this.castray();
    this.needRay = false;
    if (this.selected === null) return;
    let key = root.flow.key;
    if (key[1] !== 0) {
      let pz = key[1] * 0.1;
      this.dragPlane.translateZ(pz);
      this.needRay = true;
    }
    if (this.moveDirect) this.moveSelect();
  }
};
var MoveHelper = class extends Line {
  constructor(o = {}) {
    super(new BufferGeometry(), Mat.get("line"));
    let c = 0.75;
    const positions = [0, 0, 0, 0, -100, 0];
    const colors = [c, c, c, 0, 0, 0];
    this.geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.vertices = this.geometry.attributes.position;
    this.colors = this.geometry.attributes.color;
    this.local = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.frustumCulled = false;
  }
};
var _v1 = new Vector3();
var ConvexObjectBreaker = class _ConvexObjectBreaker {
  constructor(minSizeForBreak = 1.4, smallDelta = 1e-4) {
    this.minSizeForBreak = minSizeForBreak;
    this.smallDelta = smallDelta;
    this.tempLine1 = new Line3();
    this.tempPlane1 = new Plane();
    this.tempPlane2 = new Plane();
    this.tempPlane_Cut = new Plane();
    this.tempCM1 = new Vector3();
    this.tempCM2 = new Vector3();
    this.tempVector3 = new Vector3();
    this.tempVector3_2 = new Vector3();
    this.tempVector3_3 = new Vector3();
    this.tempVector3_P0 = new Vector3();
    this.tempVector3_P1 = new Vector3();
    this.tempVector3_P2 = new Vector3();
    this.tempVector3_N0 = new Vector3();
    this.tempVector3_N1 = new Vector3();
    this.tempVector3_AB = new Vector3();
    this.tempVector3_CB = new Vector3();
    this.tempResultObjects = { object1: null, object2: null };
    this.box1 = new Box3();
    this.box2 = new Box3();
    this.sph1 = new Sphere();
    this.sph2 = new Sphere();
    this.tt = new Vector3();
    this.s1 = new Vector3();
    this.s2 = new Vector3();
    this.segments = [];
    const n2 = 30 * 30;
    for (let i = 0; i < n2; i++) this.segments[i] = false;
  }
  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {
    const userData = object.userData;
    userData.mass = mass;
    userData.velocity = velocity.clone();
    userData.angularVelocity = angularVelocity.clone();
    userData.breakable = breakable;
  }
  /*
   * @param {int} maxRadialIterations Iterations for radial cuts.
   * @param {int} maxRandomIterations Max random iterations for not-radial cuts
   *
   * Returns the array of pieces
   */
  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
    const debris = [];
    const tempPlane1 = this.tempPlane1;
    const tempPlane2 = this.tempPlane2;
    this.tempVector3.addVectors(pointOfImpact, normal);
    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
    const maxTotalIterations = maxRandomIterations + maxRadialIterations;
    const scope = this;
    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
        debris.push(subObject);
        return;
      }
      let angle = Math.PI;
      if (numIterations === 0) {
        tempPlane2.normal.copy(tempPlane1.normal);
        tempPlane2.constant = tempPlane1.constant;
      } else {
        if (numIterations <= maxRadialIterations) {
          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);
        } else {
          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
          scope.tempVector3_3.copy(normal).add(subObject.position);
          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);
        }
      }
      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);
      const obj1 = scope.tempResultObjects.object1;
      const obj2 = scope.tempResultObjects.object2;
      if (obj1) {
        subdivideRadial(obj1, startAngle, angle, numIterations + 1);
      }
      if (obj2) {
        subdivideRadial(obj2, angle, endAngle, numIterations + 1);
      }
    }
    subdivideRadial(object, 0, 2 * Math.PI, 0);
    return debris;
  }
  cutByPlane(object, plane, output) {
    let k;
    const geometry = object.geometry;
    const coords = geometry.attributes.position.array;
    const normals = geometry.attributes.normal.array;
    const numPoints = coords.length / 3;
    let numFaces = numPoints / 3;
    let indices = geometry.getIndex();
    if (indices) {
      indices = indices.array;
      numFaces = indices.length / 3;
    }
    function getVertexIndex(faceIdx, vert) {
      const idx = faceIdx * 3 + vert;
      return indices ? indices[idx] : idx;
    }
    const points1 = [];
    const points2 = [];
    const delta = this.smallDelta;
    const numPointPairs = numPoints * numPoints;
    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;
    const p0 = this.tempVector3_P0;
    const p1 = this.tempVector3_P1;
    const n0 = this.tempVector3_N0;
    const n1 = this.tempVector3_N1;
    for (let i = 0; i < numFaces - 1; i++) {
      const a1 = getVertexIndex(i, 0);
      const b1 = getVertexIndex(i, 1);
      const c1 = getVertexIndex(i, 2);
      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
      for (let j = i + 1; j < numFaces; j++) {
        const a2 = getVertexIndex(j, 0);
        const b2 = getVertexIndex(j, 1);
        const c2 = getVertexIndex(j, 2);
        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
        const coplanar = 1 - n0.dot(n1) < delta;
        if (coplanar) {
          if (a1 === a2 || a1 === b2 || a1 === c2) {
            if (b1 === a2 || b1 === b2 || b1 === c2) {
              this.segments[a1 * numPoints + b1] = true;
              this.segments[b1 * numPoints + a1] = true;
            } else {
              this.segments[c1 * numPoints + a1] = true;
              this.segments[a1 * numPoints + c1] = true;
            }
          } else if (b1 === a2 || b1 === b2 || b1 === c2) {
            this.segments[c1 * numPoints + b1] = true;
            this.segments[b1 * numPoints + c1] = true;
          }
        }
      }
    }
    const localPlane = this.tempPlane_Cut;
    object.updateMatrix();
    _ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
    for (let i = 0; i < numFaces; i++) {
      const va = getVertexIndex(i, 0);
      const vb = getVertexIndex(i, 1);
      const vc = getVertexIndex(i, 2);
      for (let segment = 0; segment < 3; segment++) {
        const i0 = segment === 0 ? va : segment === 1 ? vb : vc;
        const i1 = segment === 0 ? vb : segment === 1 ? vc : va;
        const segmentState = this.segments[i0 * numPoints + i1];
        if (segmentState) continue;
        this.segments[i0 * numPoints + i1] = true;
        this.segments[i1 * numPoints + i0] = true;
        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
        let mark0 = 0;
        let d = localPlane.distanceToPoint(p0);
        if (d > delta) {
          mark0 = 2;
          points2.push(p0.clone());
        } else if (d < -delta) {
          mark0 = 1;
          points1.push(p0.clone());
        } else {
          mark0 = 3;
          points1.push(p0.clone());
          points2.push(p0.clone());
        }
        let mark1 = 0;
        d = localPlane.distanceToPoint(p1);
        if (d > delta) {
          mark1 = 2;
          points2.push(p1.clone());
        } else if (d < -delta) {
          mark1 = 1;
          points1.push(p1.clone());
        } else {
          mark1 = 3;
          points1.push(p1.clone());
          points2.push(p1.clone());
        }
        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
          this.tempLine1.start.copy(p0);
          this.tempLine1.end.copy(p1);
          let intersection = new Vector3();
          intersection = localPlane.intersectLine(this.tempLine1, intersection);
          if (intersection === null) {
            console.error("Internal error: segment does not intersect plane.");
            output.segmentedObject1 = null;
            output.segmentedObject2 = null;
            return 0;
          }
          points1.push(intersection);
          points2.push(intersection.clone());
        }
      }
    }
    object.userData.mass * 0.5;
    let box1 = this.box1;
    let box2 = this.box2;
    let numPoints1 = points1.length;
    let numPoints2 = points2.length;
    box1.makeEmpty();
    box2.makeEmpty();
    k = numPoints1;
    while (k--) box1.expandByPoint(points1[k]);
    k = numPoints2;
    while (k--) box2.expandByPoint(points2[k]);
    box1.getBoundingSphere(this.sph1);
    box2.getBoundingSphere(this.sph2);
    this.tempCM1.copy(this.sph1.center);
    this.tempCM2.copy(this.sph2.center);
    k = numPoints1;
    while (k--) points1[k].sub(this.tempCM1);
    k = numPoints2;
    while (k--) points2[k].sub(this.tempCM2);
    this.tempCM1.add(object.position);
    this.tempCM2.add(object.position);
    box1.getSize(this.s1);
    box2.getSize(this.s2);
    if (2 * this.sph1.radius < this.minSizeForBreak) numPoints1 = 0;
    if (2 * this.sph2.radius < this.minSizeForBreak) numPoints2 = 0;
    if (this.testSize(this.s1)) numPoints1 = 0;
    if (this.testSize(this.s2)) numPoints2 = 0;
    let object1 = null;
    let object2 = null;
    let numObjects = 0;
    if (numPoints1 > 4) {
      object1 = new Mesh(new ConvexGeometry(points1), object.material);
      object1.position.copy(this.tempCM1);
      object1.quaternion.copy(object.quaternion);
      numObjects++;
    }
    if (numPoints2 > 4) {
      object2 = new Mesh(new ConvexGeometry(points2), object.material);
      object2.position.copy(this.tempCM2);
      object2.quaternion.copy(object.quaternion);
      numObjects++;
    }
    output.object1 = object1;
    output.object2 = object2;
    return numObjects;
  }
  testSize(s) {
    let n2 = 0;
    if (s.x < 0.01) n2++;
    if (s.y < 0.01) n2++;
    if (s.z < 0.01) n2++;
    return n2 > 1;
  }
  static transformFreeVector(v, m2) {
    const x2 = v.x, y = v.y, z = v.z;
    const e = m2.elements;
    v.x = e[0] * x2 + e[4] * y + e[8] * z;
    v.y = e[1] * x2 + e[5] * y + e[9] * z;
    v.z = e[2] * x2 + e[6] * y + e[10] * z;
    return v;
  }
  static transformFreeVectorInverse(v, m2) {
    const x2 = v.x, y = v.y, z = v.z;
    const e = m2.elements;
    v.x = e[0] * x2 + e[1] * y + e[2] * z;
    v.y = e[4] * x2 + e[5] * y + e[6] * z;
    v.z = e[8] * x2 + e[9] * y + e[10] * z;
    return v;
  }
  static transformTiedVectorInverse(v, m2) {
    const x2 = v.x, y = v.y, z = v.z;
    const e = m2.elements;
    v.x = e[0] * x2 + e[1] * y + e[2] * z - e[12];
    v.y = e[4] * x2 + e[5] * y + e[6] * z - e[13];
    v.z = e[8] * x2 + e[9] * y + e[10] * z - e[14];
    return v;
  }
  static transformPlaneToLocalSpace(plane, m2, resultPlane) {
    resultPlane.normal.copy(plane.normal);
    resultPlane.constant = plane.constant;
    const referencePoint = _ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m2);
    _ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m2);
    resultPlane.constant = -referencePoint.dot(resultPlane.normal);
  }
};
var Breaker = class {
  constructor() {
    this.convexBreaker = new ConvexObjectBreaker();
    this.tmpI = new THREE.Vector3();
    this.tpos = new THREE.Vector3();
    this.tnormal = new THREE.Vector3();
    this.nDebris = 0;
    this.maxDebris = 300;
    this.tt = null;
  }
  step() {
    let p2;
    for (let n2 in root.reflow.point) {
      p2 = root.reflow.point[n2];
      if (p2.distance !== 0) {
        this.makeBreak(p2.b1, p2.pos, p2.normal, p2.impulse, p2.v1);
        this.makeBreak(p2.b2, p2.pos, p2.normal, p2.impulse, p2.v2);
      }
    }
  }
  makeBreak(name, pos, normal, impulse, v) {
    let mesh = Utils.byName(name);
    if (!mesh) return;
    if (!mesh.breakable) return;
    let breakOption = mesh.breakOption;
    if (impulse < breakOption[0]) return;
    let debris = this.convexBreaker.subdivideByImpact(mesh, this.tpos.fromArray(pos), this.tnormal.fromArray(normal), breakOption[1], breakOption[2]);
    if (debris.length < 1) return;
    breakOption[3] -= 1;
    const eritage = {
      material: mesh.material,
      linearVelocity: [v[0], v[1], v[2]],
      angularVelocity: [v[3], v[4], v[5]],
      density: mesh.density
    };
    let list = [];
    let i = debris.length, n2 = 0;
    while (i--) {
      list.push(this.addDebris(debris[n2], breakOption, eritage));
      n2++;
    }
    this.tt = setTimeout(() => {
      root.motor.remove(name);
      root.motor.add(list);
    }, 0);
  }
  addDebris(mesh, breakOption, eritage) {
    let breakable = breakOption[3] > 0 ? true : false;
    let name = "debris_" + this.nDebris++;
    let deb = {
      ...eritage,
      name,
      type: "convex",
      shape: mesh.geometry,
      //size:[1,1,1],
      pos: mesh.position.toArray(),
      quat: mesh.quaternion.toArray(),
      breakable,
      breakOption
    };
    if (this.nDebris > this.maxDebris) this.nDebris = 0;
    return deb;
  }
};
new Vector3();
var SPHSystem_update_a_pressure = new Vector3();
var SPHSystem_update_a_visc = new Vector3();
var SPHSystem_update_gradW = new Vector3();
var SPHSystem_update_r_vec = new Vector3();
var SPHSystem_update_u = new Vector3();
var Particle = class {
  constructor(o = {}) {
    this.name = o.name || "ppp";
    this.particles = [];
    this.density = 0.01;
    this.smoothingRadius = 0.2;
    this.speedOfSound = 0.1;
    this.viscosity = 0.03;
    this.eps = 1e-6;
    this.group = 1 << 8;
    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
    this.tv = new Vector3();
    this.tv2 = new Vector3();
  }
  add(pos) {
    let p2 = root.motor.add({
      instance: this.name,
      type: "particle",
      //type:'sphere',
      flags: "noQuery",
      size: [0.1],
      pSize: 0.03,
      pos,
      inertia: [0, 0, 0],
      //iterations:[10,1],
      mass: 1e-3,
      //density:0.0001,
      restitution: 0,
      friction: 0.5,
      //maxVelocity:[2,100],
      damping: [0.1, 0.1],
      //group:this.group, 
      //mask:1|2,
      material: "hide"
    });
    p2.force = new Vector3();
    this.particles.push(p2);
    if (this.neighbors.length < this.particles.length) {
      this.neighbors.push([]);
    }
  }
  connect(link) {
    let i = link.length;
    console.log(i);
    let tmp = [], l, p1, p2, d = 0;
    while (i--) {
      l = link[i];
      this.name + l[0];
      this.name + l[1];
      p1 = this.particles[l[0]].position;
      p2 = this.particles[l[1]].position;
      d = this.tv.copy(p1).distanceTo(p2);
      this.tv.copy(p2).sub(p1);
      tmp.push({
        type: "distance",
        helperSize: 0.03,
        b1: this.name + l[0],
        b2: this.name + l[1],
        //limit:[d - 0.01, d + 0.01], 
        limit: [d * 0.5, d],
        spring: [20, 1],
        //spring:[0.0, 0.0],
        friction: 0
        /*visible:true, helperSize:0.02*/
      });
    }
    root.motor.add(tmp);
  }
  getPosition() {
    let ar = [];
    let i = this.particles.length, p2, n2;
    while (i--) {
      n2 = i * 3;
      p2 = this.particles[i];
      ar[n2] = p2.position.x;
      ar[n2 + 1] = p2.position.y;
      ar[n2 + 2] = p2.position.z;
    }
    return ar;
  }
  // Get neighbors within smoothing volume, save in the array neighbors
  getNeighbors(particle, neighbors) {
    const N = this.particles.length;
    const id = particle.id;
    const R2 = this.smoothingRadius * this.smoothingRadius;
    let distance = 0;
    for (let i = 0; i !== N; i++) {
      const p2 = this.particles[i];
      distance = this.distance(p2, particle);
      if (id !== p2.id && distance < R2) {
        neighbors.push(p2);
      }
    }
  }
  distance(p2, v) {
    const dx = p2.position.x - v.position.x, dy = p2.position.y - v.position.y, dz = p2.position.z - v.position.z;
    return dx * dx + dy * dy + dz * dz;
  }
  // Calculate the weight using the W(r) weightfunction
  w(r) {
    const h = this.smoothingRadius;
    return 315 / (64 * Math.PI * h ** 9) * (h * h - r * r) ** 3;
  }
  // calculate gradient of the weight function
  gradw(rVec, resultVec) {
    const r = rVec.length();
    const h = this.smoothingRadius;
    resultVec.copy(rVec).multiplyScalar(945 / (32 * Math.PI * h ** 9) * (h * h - r * r) ** 2);
  }
  // Calculate nabla(W)
  nablaw(r) {
    const h = this.smoothingRadius;
    const nabla = 945 / (32 * Math.PI * h ** 9) * (h * h - r * r) * (7 * r * r - 3 * h * h);
    return nabla;
  }
  update() {
    const TMP = [];
    const N = this.particles.length;
    const cs = this.speedOfSound;
    const eps = this.eps;
    let i = N, j;
    while (i--) {
      const p2 = this.particles[i];
      p2.force.set(0, 0, 0);
      const neighbors = this.neighbors[i];
      neighbors.length = 0;
      this.getNeighbors(p2, neighbors);
      neighbors.push(this.particles[i]);
      const numNeighbors = neighbors.length;
      let sum = 0;
      j = numNeighbors;
      while (j--) {
        const weight = this.w(this.distance(p2, neighbors[j]));
        sum += neighbors[j].mass * weight;
      }
      this.densities[i] = sum;
      this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    }
    const a_pressure = SPHSystem_update_a_pressure;
    const a_visc = SPHSystem_update_a_visc;
    const gradW = SPHSystem_update_gradW;
    const r_vec = SPHSystem_update_r_vec;
    const u = SPHSystem_update_u;
    i = N;
    while (i--) {
      const particle = this.particles[i];
      a_pressure.set(0, 0, 0);
      a_visc.set(0, 0, 0);
      let Pij;
      let nabla;
      const neighbors = this.neighbors[i];
      const numNeighbors = neighbors.length;
      j = numNeighbors;
      while (j--) {
        const neighbor = neighbors[j];
        r_vec.copy(particle.position).sub(neighbor.position);
        const r = r_vec.length();
        Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
        this.gradw(r_vec, gradW);
        gradW.multiplyScalar(Pij);
        a_pressure.add(gradW);
        u.copy(neighbor.velocity).sub(particle.velocity);
        u.multiplyScalar(1 / (1e-4 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass);
        nabla = this.nablaw(r);
        u.multiplyScalar(nabla);
        a_visc.add(u);
      }
      a_visc.multiplyScalar(particle.mass);
      a_pressure.multiplyScalar(particle.mass);
      particle.force.add(a_visc);
      particle.force.add(a_pressure);
      TMP.push({
        name: particle.name,
        force: particle.force.toArray()
      });
    }
    root.motor.change(TMP);
  }
};
var torad$1 = Math.PI / 180;
var directions = [
  new Vector3(1, 0, 0),
  new Vector3(0, 1, 0),
  new Vector3(0, 0, 1)
];
var calcRollingFriction_vel1 = new Vector3();
var calcRollingFriction_vel2 = new Vector3();
var calcRollingFriction_vel = new Vector3();
var updateFriction_surfNormalWS_scaled_proj = new Vector3();
var sideFrictionStiffness2 = 1;
var updateFriction_forwardWS = [];
var updateFriction_axle = [];
var tmpVec4 = new Vector3();
var tmpVec5 = new Vector3();
var tmpVec6 = new Vector3();
new Matrix4();
var RayCar = class {
  constructor(o = {}) {
    this.extra = {};
    this.tmp = {
      forwardForce: 0,
      steerValue: 0,
      steerDirection: 0,
      brakeForce: 0
    };
    this.localWheel = true;
    this.maxSpeed = 70;
    this.maxForce = 1500;
    this.maxBrakeForce = 45;
    this.maxSteer = 0.4;
    this.steeringIncrement = 0.15;
    this.steerRecover = 0.15;
    this.name = o.name || "car";
    this.mass = o.mass || 1e3;
    this.size = o.size || [1.5, 0.7, 3.8];
    this.pos = o.pos || [0, 4, 0];
    this.rot = o.rot || [0, 0, 0];
    this.friction = o.friction || 0.2;
    this.restitution = o.restitution || 0.3;
    this.massCenter = o.massCenter || [0, 0, 0];
    this.driveWheel = o.driveWheel || null;
    let shape = [{ type: "box", pos: this.massCenter, size: this.size, radius: 0.02 }];
    if (o.shapeMesh) {
      shape = [{ type: "convex", shape: o.shapeMesh.geometry, pos: o.shapePos || [0, 0, 0] }];
    }
    this.body = root.motor.add({
      type: "compound",
      shapes: shape,
      name: this.name,
      pos: this.pos,
      rot: this.rot,
      friction: this.friction,
      restitution: this.restitution,
      mass: this.mass,
      //neverSleep:true,
      //massInfo:true,
      //shadow:false,
      mesh: o.bodyMesh || null,
      //noClone: true,
      meshPos: o.meshPos || [0, -1.1, 0],
      material: o.material,
      damping: [0.05, 0.05],
      debug: false
    });
    this.body.inertia.set(283.33331298828125, 333.33331298828125, 83.33332824707031);
    this.vehicle = new RaycastVehicle({
      chassis: this.body
    });
    let wp = o.wheelPosition || [0.61, 0, 1.2];
    const wheelPositions = [
      new Vector3(-wp[0], wp[1], -wp[2]),
      new Vector3(wp[0], wp[1], -wp[2]),
      new Vector3(-wp[0], wp[1], wp[2]),
      new Vector3(wp[0], wp[1], wp[2])
    ];
    const options = {
      radius: o.wheelRadius || 0.31,
      //0.32,//0.5,
      directionLocal: new Vector3(0, -1, 0),
      suspensionStiffness: 100,
      //30
      suspensionRestLength: 0.5,
      //0.8
      suspensionMaxLength: 1,
      //2,//2
      maxSuspensionTravel: 0.3,
      //0.8//0.3,
      frictionSlip: 4,
      dampingRelaxation: 2.3,
      dampingCompression: 4.4,
      maxSuspensionForce: 1e5,
      rollInfluence: 1e-3,
      //0.001,
      axleLocal: new Vector3(1, 0, 0),
      chassisConnectionPointLocal: new Vector3(1, 1, 0)
    };
    this.addParametre("frictionSlip", 4);
    this.addParametre("maxSuspensionTravel", 0.3);
    this.addParametre("suspensionRestLength", 0.5);
    this.addParametre("suspensionMaxLength", 1);
    wheelPositions.forEach((positionLocal) => {
      options.chassisConnectionPointLocal.copy(positionLocal);
      this.vehicle.addWheel(options);
    });
    let wgeo;
    let m1, m2;
    let mat2 = root.motor.getMat("debug");
    if (o.wheelMesh) {
      m1 = o.wheelMesh;
      m2 = o.wheelMesh2 ? o.wheelMesh2 : null;
      if (o.material) {
        mat2 = o.material || mat2;
        m1.material = mat2;
        if (m2) m2.material = mat2;
      }
    } else {
      wgeo = new CylinderGeometry(options.radius, options.radius, o.wheelDepth || 0.2);
      wgeo.rotateZ(Math.PI * 0.5);
      m1 = new Mesh(wgeo, mat2);
      m2 = null;
    }
    this.vehicle.localWheel = this.localWheel;
    if (this.localWheel) {
      this.vehicle.wheelMeshes = [m2 ? m2 : m1.clone(), m1, m2 ? m2.clone() : m1.clone(), m1.clone()];
      let k = this.vehicle.wheelMeshes.length, n2 = 0;
      while (k--) this.body.add(this.vehicle.wheelMeshes[n2++]);
    } else {
      m.matrixAutoUpdate = false;
      if (m2) m2.matrixAutoUpdate = false;
      this.vehicle.wheelMeshes = [
        root.motor.add(m2 ? m2 : m.clone()),
        root.motor.add(m),
        root.motor.add(m2 ? m2.clone() : m.clone()),
        root.motor.add(m.clone())
      ];
    }
  }
  step() {
    this.tmp.forwardForce = 0;
    this.tmp.brakeForce = 0;
    this.tmp.steerDirection = 0;
    let delta = root.motor.getDelta();
    root.motor.getAzimut();
    let key = root.motor.getKey();
    this.tmp.forwardForce = key[1];
    this.tmp.steerDirection = key[0] * -1;
    this.tmp.brakeForce = key[4] === 1 ? this.maxBrakeForce : 0;
    this.tmp.steerValue += this.tmp.steerDirection * this.steeringIncrement;
    this.tmp.steerValue = Math.min(Math.max(this.tmp.steerValue, -this.maxSteer), this.maxSteer);
    this.tmp.steerValue *= 1 - (1 - Math.abs(this.tmp.steerDirection)) * this.steerRecover;
    let speed = Math.abs(this.vehicle.currentVehicleSpeedKmHour);
    speed = Math.min(speed, this.maxSpeed);
    speed / this.maxSpeed * 100;
    const acceleration = 1;
    const force = acceleration * this.tmp.forwardForce * this.maxForce;
    const slipForce = 8;
    this.vehicle.applyEngineForce(force, 0);
    this.vehicle.applyEngineForce(force, 1);
    this.vehicle.applyEngineForce(force, 2);
    this.vehicle.applyEngineForce(force, 3);
    this.vehicle.setSteeringValue(this.tmp.steerValue, 2);
    this.vehicle.setSteeringValue(this.tmp.steerValue, 3);
    this.vehicle.setBrake(this.tmp.brakeForce, 0);
    this.vehicle.setBrake(this.tmp.brakeForce, 1);
    this.vehicle.setBrake(0, 2);
    this.vehicle.setBrake(0, 3);
    this.vehicle.wheelInfos[0].frictionSlip = slipForce;
    this.vehicle.wheelInfos[1].frictionSlip = slipForce;
    this.vehicle.wheelInfos[2].frictionSlip = slipForce;
    this.vehicle.wheelInfos[3].frictionSlip = slipForce;
    this.vehicle.updateVehicle(delta);
    if (this.driveWheel) {
      this.driveWheel.rotation.y = this.tmp.steerValue * 180 * torad$1;
    }
  }
  /*get frictionSlip (){
          return this._frictionSlip
      }
  
      set frictionSlip (v){
          this._frictionSlip = v
          this.vehicle.setWheels({frictionSlip:this._frictionSlip})
      }*/
  addParametre(name, value) {
    this.extra[name] = value;
    Object.defineProperty(this, name, {
      get: () => this.extra[name],
      set: (v) => {
        this.extra[name] = v;
        if (this.vehicle) this.vehicle.setWheels(name, this.extra[name]);
      }
    });
  }
};
var RaycastVehicle = class {
  constructor(o) {
    this.chassisBody = o.chassis;
    this.wheelInfos = [];
    this.sliding = false;
    this.world = null;
    this.indexRightAxis = typeof o.indexRightAxis !== "undefined" ? o.indexRightAxis : 0;
    this.indexForwardAxis = typeof o.indexForwardAxis !== "undefined" ? o.indexForwardAxis : 2;
    this.indexUpAxis = typeof o.indexUpAxis !== "undefined" ? o.indexUpAxis : 1;
    this.wheelMeshes = [];
    this.brakeMeshs = null;
    this.localWheel = false;
  }
  addWheel(o = {}) {
    let info = new WheelInfo(o);
    let index = this.wheelInfos.length - 1;
    info.chassisBody = this.chassisBody;
    let raylen = info.suspensionRestLength + info.radius;
    info.ray = root.motor.add({
      type: "ray",
      name: this.chassisBody.name + "_wheel_" + index,
      begin: info.chassisConnectionPointLocal.toArray(),
      end: [info.chassisConnectionPointLocal.x, -raylen, info.chassisConnectionPointLocal.z],
      callback: function(r) {
        info.castRay(r);
      },
      visible: false,
      parent: this.chassisBody
    });
    this.wheelInfos.push(info);
    return index;
  }
  setWheels(name, value) {
    let i = this.wheelInfos.length, w;
    while (i--) {
      w = this.wheelInfos[i];
      if (w[name]) w[name] = value;
    }
  }
  setSteeringValue(value, wheelIndex) {
    let wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
  }
  applyEngineForce(value, wheelIndex) {
    this.wheelInfos[wheelIndex].engineForce = value;
  }
  setBrake(brake, wheelIndex) {
    this.wheelInfos[wheelIndex].brake = brake;
  }
  getVehicleAxisWorld(axisIndex, result) {
    result.set(
      axisIndex === 0 ? 1 : 0,
      axisIndex === 1 ? 1 : 0,
      axisIndex === 2 ? 1 : 0
    );
    TransformCoordinatesToRef(result, bodyTransform(this.chassisBody, new Matrix4()), result);
    return result;
  }
  updateVehicle(timeStep) {
    let wheelInfos = this.wheelInfos;
    let numWheels = wheelInfos.length;
    let chassisBody = this.chassisBody;
    let i = numWheels;
    while (i--) {
      this.updateWheelTransform(i);
    }
    const cVel = bodyLinearVelocity(chassisBody, new Vector3());
    const cVelLocal = TransformNormalToRef(cVel, bodyTransform(chassisBody, new Matrix4()).invert(), new Vector3());
    this.currentVehicleSpeedKmHour = cVelLocal.z;
    let forwardWorld = new Vector3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);
    if (forwardWorld.dot(chassisBody.velocity) < 0) {
      this.currentVehicleSpeedKmHour *= -1;
    }
    this.updateSuspension(timeStep);
    let impulse = new Vector3();
    new Vector3();
    for (i = 0; i < numWheels; i++) {
      let wheel = wheelInfos[i];
      let suspensionForce = wheel.suspensionForce;
      if (suspensionForce > wheel.maxSuspensionForce) {
        suspensionForce = wheel.maxSuspensionForce;
      }
      impulse.copy(wheel.raycastResult.hitNormalWorld).multiplyScalar(suspensionForce * timeStep);
      addImpulseAt(chassisBody, impulse, wheel.raycastResult.hitPointWorld);
    }
    this.updateFriction(timeStep);
    let hitNormalWorldScaledWithProj = new Vector3();
    let fwd = new Vector3();
    let vel = new Vector3();
    for (i = 0; i < numWheels; i++) {
      let wheel = wheelInfos[i];
      velocityAt(chassisBody, wheel.chassisConnectionPointWorld, vel);
      let m2 = 1;
      switch (this.indexUpAxis) {
        case 1:
          m2 = -1;
          break;
      }
      if (wheel.isInContact) {
        this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
        let proj = Dot(fwd, wheel.raycastResult.hitNormalWorld);
        hitNormalWorldScaledWithProj.copy(wheel.raycastResult.hitNormalWorld).multiplyScalar(proj);
        fwd.sub(hitNormalWorldScaledWithProj);
        let proj2 = Dot(fwd, vel);
        wheel.deltaRotation = m2 * proj2 * timeStep / wheel.radius;
      }
      if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
        wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
      }
      if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
        wheel.deltaRotation = 0;
      }
      wheel.rotation -= wheel.deltaRotation;
      wheel.deltaRotation *= 0.99;
    }
  }
  updateSuspension(deltaTime) {
    let chassisBody = this.chassisBody;
    let chassisMass = bodyMass(chassisBody);
    let wheelInfos = this.wheelInfos;
    let numWheels = wheelInfos.length;
    for (let w_it = 0; w_it < numWheels; w_it++) {
      let wheel = wheelInfos[w_it];
      if (wheel.isInContact) {
        let force;
        let susp_length = wheel.suspensionRestLength;
        let current_length = wheel.suspensionLength;
        let length_diff = susp_length - current_length;
        force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;
        let projected_rel_vel = wheel.suspensionRelativeVelocity;
        let susp_damping;
        if (projected_rel_vel < 0) {
          susp_damping = wheel.dampingCompression;
        } else {
          susp_damping = wheel.dampingRelaxation;
        }
        force -= susp_damping * projected_rel_vel;
        wheel.suspensionForce = force * chassisMass;
        if (wheel.suspensionForce < 0) {
          wheel.suspensionForce = 0;
        }
      } else {
        wheel.suspensionForce = 0;
      }
    }
  }
  updateFriction(timeStep) {
    let surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;
    let wheelInfos = this.wheelInfos;
    let numWheels = wheelInfos.length;
    let chassisBody = this.chassisBody;
    let forwardWS = updateFriction_forwardWS;
    let axle = updateFriction_axle;
    let i, wheel, groundObject;
    for (i = 0; i < numWheels; i++) {
      wheel = wheelInfos[i];
      groundObject = wheel.raycastResult.body;
      wheel.sideImpulse = 0;
      wheel.forwardImpulse = 0;
      if (!forwardWS[i]) forwardWS[i] = new Vector3();
      if (!axle[i]) axle[i] = new Vector3();
      if (groundObject) {
        let axlei = axle[i];
        let wheelTrans = this.getWheelTransformWorld(i);
        TransformNormalToRef(directions[this.indexRightAxis], wheelTrans, axlei);
        let surfNormalWS = wheel.raycastResult.hitNormalWorld;
        let proj = Dot(axlei, surfNormalWS);
        surfNormalWS_scaled_proj.copy(surfNormalWS).multiplyScalar(proj);
        axlei.sub(surfNormalWS_scaled_proj).normalize();
        CrossToRef(surfNormalWS, axlei, forwardWS[i]);
        forwardWS[i].normalize();
        wheel.sideImpulse = resolveSingleBilateral(
          chassisBody,
          wheel.raycastResult.hitPointWorld,
          groundObject,
          wheel.raycastResult.hitPointWorld,
          axlei
        );
        wheel.sideImpulse *= sideFrictionStiffness2;
      }
    }
    let sideFactor = 1;
    let fwdFactor = 0.5;
    this.sliding = false;
    for (i = 0; i < numWheels; i++) {
      wheel = wheelInfos[i];
      groundObject = wheel.raycastResult.body;
      let rollingFriction = 0;
      wheel.slipInfo = 1;
      if (groundObject) {
        let defaultRollingFrictionImpulse = 0;
        let maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;
        rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
        rollingFriction += wheel.engineForce * timeStep;
        let factor = maxImpulse / rollingFriction;
        wheel.slipInfo *= factor;
      }
      wheel.forwardImpulse = 0;
      wheel.skidInfo = 1;
      if (groundObject) {
        wheel.skidInfo = 1;
        let maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
        let maximpSide = maximp;
        let maximpSquared = maximp * maximpSide;
        wheel.forwardImpulse = rollingFriction;
        let x2 = wheel.forwardImpulse * fwdFactor / wheel.forwardAcceleration;
        let y = wheel.sideImpulse * sideFactor / wheel.sideAcceleration;
        let impulseSquared = x2 * x2 + y * y;
        wheel.sliding = false;
        if (impulseSquared > maximpSquared) {
          this.sliding = true;
          wheel.sliding = true;
          let factor = maximp / Math.sqrt(impulseSquared);
          wheel.skidInfo *= factor;
        }
      }
    }
    if (this.sliding) {
      for (let i2 = 0; i2 < numWheels; i2++) {
        wheel = wheelInfos[i2];
        if (wheel.sideImpulse !== 0) {
          if (wheel.skidInfo < 1) {
            wheel.forwardImpulse *= wheel.skidInfo;
            wheel.sideImpulse *= wheel.skidInfo;
          }
        }
      }
    }
    for (i = 0; i < numWheels; i++) {
      wheel = wheelInfos[i];
      let rel_pos = new Vector3();
      rel_pos.copy(wheel.raycastResult.hitPointWorld).sub(bodyPosition(chassisBody, new Vector3()));
      if (wheel.forwardImpulse !== 0) {
        let impulse = new Vector3();
        impulse.copy(forwardWS[i]).multiplyScalar(wheel.forwardImpulse);
        addImpulseAt(chassisBody, impulse, wheel.raycastResult.hitPointWorld);
      }
      if (wheel.sideImpulse !== 0) {
        groundObject = wheel.raycastResult.body;
        let rel_pos2 = new Vector3();
        rel_pos2.copy(wheel.raycastResult.hitPointWorld).sub(bodyPosition(groundObject, new Vector3()));
        let sideImp = new Vector3();
        sideImp.copy(axle[i]).multiplyScalar(wheel.sideImpulse);
        TransformNormalToRef(rel_pos, bodyTransform(chassisBody, new Matrix4()).invert(), rel_pos);
        rel_pos["xyz"[this.indexUpAxis]] *= wheel.rollInfluence;
        TransformNormalToRef(rel_pos, bodyTransform(chassisBody, new Matrix4()), rel_pos);
        addImpulseAt(chassisBody, sideImp, bodyPosition(chassisBody, new Vector3()).add(rel_pos));
        sideImp.multiplyScalar(-1);
        addImpulseAt(groundObject, sideImp, wheel.raycastResult.hitPointWorld);
      }
    }
  }
  updateWheelTransformWorld(wheel) {
    let chassisBody = this.chassisBody;
    const transform = chassisBody.matrixWorld;
    TransformCoordinatesToRef(wheel.chassisConnectionPointLocal, transform, wheel.chassisConnectionPointWorld);
    TransformNormalToRef(wheel.directionLocal, transform, wheel.directionWorld);
  }
  updateWheelTransform(wheelIndex) {
    let up = tmpVec4;
    let right = tmpVec5;
    let fwd = tmpVec6;
    let wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);
    up.copy(wheel.directionLocal).multiplyScalar(-1);
    right.copy(wheel.axleLocal);
    CrossToRef(up, right, fwd);
    fwd.normalize();
    right.normalize();
    let steering = wheel.steering;
    let steeringOrn = new Quaternion();
    RotationAxisToRef(up, steering, steeringOrn);
    let rotatingOrn = new Quaternion();
    RotationAxisToRef(right, wheel.rotation, rotatingOrn);
    let q = wheel.quaternion;
    bodyOrientation(this.chassisBody, q);
    q.multiply(steeringOrn).multiply(rotatingOrn).normalize();
    let p2 = wheel.position;
    p2.copy(wheel.directionWorld);
    p2.multiplyScalar(wheel.suspensionLength);
    let locP = p2.clone();
    p2.add(wheel.chassisConnectionPointWorld);
    wheel.matrix.compose(wheel.position, wheel.quaternion, { x: 1, y: 1, z: 1 });
    if (this.localWheel) {
      locP.add(wheel.chassisConnectionPointLocal);
      this.wheelMeshes[wheelIndex].quaternion.copy(steeringOrn).multiply(rotatingOrn).normalize();
      this.wheelMeshes[wheelIndex].position.copy(locP);
      if (this.brakeMeshs) {
        if (wheelIndex === 2 || wheelIndex === 3) this.brakeMeshs[wheelIndex].quaternion.copy(steeringOrn).normalize();
        this.brakeMeshs[wheelIndex].position.copy(locP);
        this.brakeMeshs[wheelIndex].updateMatrix();
      }
    } else {
      this.wheelMeshes[wheelIndex].position.copy(wheel.position);
      this.wheelMeshes[wheelIndex].quaternion.copy(wheel.quaternion);
      this.wheelMeshes[wheelIndex].updateMatrix();
    }
  }
  getWheelTransformWorld(id) {
    return this.wheelInfos[id].matrix;
  }
};
var Utilsdefaults = (options, defaults) => {
  options = options || {};
  for (var key in defaults) {
    if (!(key in options)) {
      options[key] = defaults[key];
    }
  }
  return options;
};
var chassis_velocity_at_contactPoint = new Vector3();
var relpos = new Vector3();
var WheelInfo = class {
  constructor(options) {
    options = Utilsdefaults(options, {
      chassisConnectionPointLocal: new Vector3(),
      chassisConnectionPointWorld: new Vector3(),
      directionLocal: new Vector3(),
      directionWorld: new Vector3(),
      axleLocal: new Vector3(),
      //axleWorld: new Vector3(),
      suspensionRestLength: 1,
      suspensionMaxLength: 2,
      radius: 1,
      suspensionStiffness: 100,
      dampingCompression: 10,
      dampingRelaxation: 10,
      frictionSlip: 1e4,
      forwardAcceleration: 1,
      sideAcceleration: 1,
      steering: 0,
      rotation: 0,
      deltaRotation: 0,
      rollInfluence: 0.01,
      maxSuspensionForce: Number.MAX_VALUE,
      isFrontWheel: true,
      clippedInvContactDotSuspension: 1,
      suspensionRelativeVelocity: 0,
      suspensionForce: 0,
      skidInfo: 0,
      suspensionLength: 0,
      maxSuspensionTravel: 1,
      useCustomSlidingRotationalSpeed: false,
      customSlidingRotationalSpeed: -0.1
    });
    this.maxSuspensionTravel = options.maxSuspensionTravel;
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
    this.sliding = false;
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
    this.chassisConnectionPointWorld = options.chassisConnectionPointLocal.clone();
    this.directionLocal = options.directionLocal.clone();
    this.directionWorld = options.directionLocal.clone();
    this.axleLocal = options.axleLocal.clone();
    this.suspensionRestLength = options.suspensionRestLength;
    this.suspensionMaxLength = options.suspensionMaxLength;
    this.radius = options.radius;
    this.suspensionStiffness = options.suspensionStiffness;
    this.dampingCompression = options.dampingCompression;
    this.dampingRelaxation = options.dampingRelaxation;
    this.frictionSlip = options.frictionSlip;
    this.forwardAcceleration = options.forwardAcceleration;
    this.sideAcceleration = options.sideAcceleration;
    this.steering = 0;
    this.rotation = 0;
    this.deltaRotation = 0;
    this.rollInfluence = options.rollInfluence;
    this.maxSuspensionForce = options.maxSuspensionForce;
    this.engineForce = 0;
    this.brake = 0;
    this.isFrontWheel = options.isFrontWheel;
    this.clippedInvContactDotSuspension = 1;
    this.suspensionRelativeVelocity = 0;
    this.suspensionForce = 0;
    this.skidInfo = 0;
    this.suspensionLength = 0;
    this.sideImpulse = 0;
    this.forwardImpulse = 0;
    this.raycastResult = new RaycastResult();
    this.position = new Vector3().copy(this.chassisConnectionPointLocal);
    this.quaternion = new Quaternion();
    this.isInContact = false;
    this.chassisBody = null;
    this.ray = null;
    this.matrix = new Matrix4();
  }
  castRay(r) {
    if (r.hit) {
      this.isInContact = true;
      let hitDistance = r.distance;
      this.raycastResult.hitPointWorld.fromArray(r.point);
      this.raycastResult.hitNormalWorld.fromArray(r.normal);
      this.raycastResult.body = root.motor.byName(r.body);
      this.suspensionLength = hitDistance - this.radius;
      let minSuspensionLength = this.suspensionRestLength - this.maxSuspensionTravel;
      let maxSuspensionLength = this.suspensionRestLength + this.maxSuspensionTravel;
      if (this.suspensionLength < minSuspensionLength) {
        this.suspensionLength = minSuspensionLength;
      }
      if (this.suspensionLength > maxSuspensionLength) {
        this.suspensionLength = maxSuspensionLength;
        this.raycastResult.reset();
      }
      let denominator = Dot(this.raycastResult.hitNormalWorld, this.directionWorld);
      velocityAt(this.chassisBody, this.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
      var projVel = Dot(this.raycastResult.hitNormalWorld, chassis_velocity_at_contactPoint);
      if (denominator >= -0.1) {
        this.suspensionRelativeVelocity = 0;
        this.clippedInvContactDotSuspension = 1 / 0.1;
      } else {
        let inv = -1 / denominator;
        this.suspensionRelativeVelocity = projVel * inv;
        this.clippedInvContactDotSuspension = inv;
      }
    } else {
      this.isInContact = false;
      this.suspensionLength = this.suspensionRestLength + 0 * this.maxSuspensionTravel;
      this.suspensionRelativeVelocity = 0;
      this.raycastResult.hitNormalWorld.copy(this.directionWorld).multiplyScalar(-1);
      this.clippedInvContactDotSuspension = 1;
    }
  }
  updateWheel(chassis) {
    let raycastResult = this.raycastResult;
    if (this.isInContact) {
      let project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
      relpos.copy(raycastResult.hitPointWorld).sub(chassis.position);
      velocityAt(chassis, relpos, chassis_velocity_at_contactPoint);
      let projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
      if (project >= -0.1) {
        this.suspensionRelativeVelocity = 0;
        this.clippedInvContactDotSuspension = 1 / 0.1;
      } else {
        let inv = -1 / project;
        this.suspensionRelativeVelocity = projVel * inv;
        this.clippedInvContactDotSuspension = inv;
      }
    } else {
      raycastResult.suspensionLength = this.suspensionRestLength;
      this.suspensionRelativeVelocity = 0;
      raycastResult.hitNormalWorld.copy(raycastResult.directionWorld).scaleInPlace(-1);
      this.clippedInvContactDotSuspension = 1;
    }
  }
};
var RaycastResult = class {
  constructor() {
    this.body = null;
    this.hitPointWorld = new Vector3();
    this.hitNormalWorld = new Vector3();
    this.directionWorld = new Vector3();
  }
  reset() {
    this.body = null;
    this.hitPointWorld = new Vector3();
    this.hitNormalWorld = new Vector3();
    this.directionWorld = new Vector3();
  }
};
var bodyMass = (body) => body.mass;
var bodyInvMass = (body) => body.mass > 0 ? 1 / body.mass : 0;
var bodyPosition = (body, res) => res.copy(body.position);
var bodyLinearVelocity = (body, res) => res.copy(body.velocity);
var bodyTransform = (body, res) => res.copy(body.matrixWorld);
var bodyOrientation = (body, res) => res.copy(body.quaternion);
var addImpulseAt = (body, impulse, point) => {
  root.motor.change({ name: body.name, impulse: impulse.toArray(), impulseCenter: point.toArray() });
};
var velocityAt = (body, pos, res) => {
  res.copy(pos).sub(body.position);
  res.crossVectors(body.angular, res);
  res.add(body.velocity);
  return res;
};
var bodyInertiaWorld = (body, res) => {
  res.copy(body.inertia);
  TransformNormalToRef(res, body.matrixWorld, res);
  res.x = res.x > 0 ? 1 / res.x : 0;
  res.y = res.y > 0 ? 1 / res.y : 0;
  res.z = res.z > 0 ? 1 / res.z : 0;
  return res;
};
var Dot = (v, w) => v.x * w.x + v.y * w.y + v.z * w.z;
var CrossToRef = (left, right, result) => {
  const x2 = left.y * right.z - left.z * right.y;
  const y = left.z * right.x - left.x * right.z;
  const z = left.x * right.y - left.y * right.x;
  result.set(x2, y, z);
  return result;
};
var TransformCoordinatesToRef = (v, t2, result) => {
  const x2 = v.x, y = v.y, z = v.z;
  const m2 = t2.elements;
  const rx = x2 * m2[0] + y * m2[4] + z * m2[8] + m2[12];
  const ry = x2 * m2[1] + y * m2[5] + z * m2[9] + m2[13];
  const rz = x2 * m2[2] + y * m2[6] + z * m2[10] + m2[14];
  const rw = 1 / (x2 * m2[3] + y * m2[7] + z * m2[11] + m2[15]);
  result.x = rx * rw;
  result.y = ry * rw;
  result.z = rz * rw;
  return result;
};
var TransformNormalToRef = (v, t2, result) => {
  const x2 = v.x, y = v.y, z = v.z;
  const m2 = t2.elements;
  result.x = x2 * m2[0] + y * m2[4] + z * m2[8];
  result.y = x2 * m2[1] + y * m2[5] + z * m2[9];
  result.z = x2 * m2[2] + y * m2[6] + z * m2[10];
  return result;
};
var RotationAxisToRef = (axis, angle, result) => {
  const sin = Math.sin(angle / 2);
  axis.normalize();
  result.w = Math.cos(angle / 2);
  result.x = axis.x * sin;
  result.y = axis.y * sin;
  result.z = axis.z * sin;
  return result;
};
function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
  var j1 = 0;
  var contactPosWorld = frictionPosWorld;
  var vel1 = calcRollingFriction_vel1;
  var vel2 = calcRollingFriction_vel2;
  var vel = calcRollingFriction_vel;
  velocityAt(body0, contactPosWorld, vel1);
  velocityAt(body1, contactPosWorld, vel2);
  vel.copy(vel1).sub(vel2);
  var vrel = Dot(frictionDirectionWorld, vel);
  var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
  var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
  var relaxation = 1;
  var jacDiagABInv = relaxation / (denom0 + denom1);
  j1 = -vrel * jacDiagABInv;
  if (maxImpulse < j1) {
    j1 = maxImpulse;
  }
  if (j1 < -maxImpulse) {
    j1 = -maxImpulse;
  }
  return j1;
}
var computeImpulseDenominator_r0 = new Vector3();
var computeImpulseDenominator_c0 = new Vector3();
var computeImpulseDenominator_vec = new Vector3();
var computeImpulseDenominator_m = new Vector3();
function computeImpulseDenominator(body, pos, normal) {
  var r0 = computeImpulseDenominator_r0;
  var c0 = computeImpulseDenominator_c0;
  var vec = computeImpulseDenominator_vec;
  var m2 = computeImpulseDenominator_m;
  r0.copy(pos).sub(bodyPosition(body, new Vector3()));
  CrossToRef(r0, normal, c0);
  m2.copy(bodyInertiaWorld(body, new Vector3())).multiply(c0);
  CrossToRef(m2, r0, vec);
  return bodyInvMass(body) + Dot(normal, vec);
}
var resolveSingleBilateral_vel1 = new Vector3();
var resolveSingleBilateral_vel2 = new Vector3();
var resolveSingleBilateral_vel = new Vector3();
function resolveSingleBilateral(body1, pos1, body2, pos2, normal) {
  var normalLenSqr = normal.lengthSq();
  if (normalLenSqr > 1.1) {
    return 0;
  }
  let vel1 = resolveSingleBilateral_vel1;
  let vel2 = resolveSingleBilateral_vel2;
  let vel = resolveSingleBilateral_vel;
  velocityAt(body1, pos1, vel1);
  velocityAt(body2, pos2, vel2);
  vel.copy(vel1).sub(vel2);
  let rel_vel = Dot(normal, vel);
  let massTerm = 1 / (bodyInvMass(body1) + bodyInvMass(body2));
  let impulse = -0.1 * rel_vel * massTerm;
  return impulse;
}
var vertexShader = (
  /* glsl */
  `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`
);
var fragmentShader = (
  /* glsl */
  `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`
);
var GainMapDecoderMaterial = class extends ShaderMaterial {
  /**
   *
   * @param params
   */
  constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {
    super({
      name: "GainMapDecoderMaterial",
      vertexShader,
      fragmentShader,
      uniforms: {
        sdr: { value: sdr },
        gainMap: { value: gainMap },
        gamma: { value: new Vector3(1 / gamma[0], 1 / gamma[1], 1 / gamma[2]) },
        offsetHdr: { value: new Vector3().fromArray(offsetHdr) },
        offsetSdr: { value: new Vector3().fromArray(offsetSdr) },
        gainMapMin: { value: new Vector3().fromArray(gainMapMin) },
        gainMapMax: { value: new Vector3().fromArray(gainMapMax) },
        weightFactor: {
          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)
        }
      },
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    this._maxDisplayBoost = maxDisplayBoost;
    this._hdrCapacityMin = hdrCapacityMin;
    this._hdrCapacityMax = hdrCapacityMax;
    this.needsUpdate = true;
    this.uniformsNeedUpdate = true;
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(value) {
    this.uniforms.sdr.value = value;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(value) {
    this.uniforms.gainMap.value = value;
  }
  /**
   * @see {@link GainMapMetadata.offsetHdr}
   */
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(value) {
    this.uniforms.offsetHdr.value.fromArray(value);
  }
  /**
   * @see {@link GainMapMetadata.offsetSdr}
   */
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(value) {
    this.uniforms.offsetSdr.value.fromArray(value);
  }
  /**
   * @see {@link GainMapMetadata.gainMapMin}
   */
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(value) {
    this.uniforms.gainMapMin.value.fromArray(value);
  }
  /**
   * @see {@link GainMapMetadata.gainMapMax}
   */
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(value) {
    this.uniforms.gainMapMax.value.fromArray(value);
  }
  /**
   * @see {@link GainMapMetadata.gamma}
   */
  get gamma() {
    const g2 = this.uniforms.gamma.value;
    return [1 / g2.x, 1 / g2.y, 1 / g2.z];
  }
  set gamma(value) {
    const g2 = this.uniforms.gamma.value;
    g2.x = 1 / value[0];
    g2.y = 1 / value[1];
    g2.z = 1 / value[2];
  }
  /**
   * @see {@link GainMapMetadata.hdrCapacityMin}
   * @remarks Logarithmic space
   */
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(value) {
    this._hdrCapacityMin = value;
    this.calculateWeight();
  }
  /**
   * @see {@link GainMapMetadata.hdrCapacityMin}
   * @remarks Logarithmic space
   */
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(value) {
    this._hdrCapacityMax = value;
    this.calculateWeight();
  }
  /**
   * @see {@link GainmapDecodingParameters.maxDisplayBoost}
   * @remarks Non Logarithmic space
   */
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(value) {
    this._maxDisplayBoost = Math.max(1, Math.min(65504, value));
    this.calculateWeight();
  }
  calculateWeight() {
    const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));
  }
};
var GainMapNotFoundError = class extends Error {
};
var XMPMetadataNotFoundError = class extends Error {
};
var getAttribute = (description, name, defaultValue) => {
  var _a2;
  let returnValue;
  const parsedValue = (_a2 = description.attributes.getNamedItem(name)) === null || _a2 === void 0 ? void 0 : _a2.nodeValue;
  if (!parsedValue) {
    const node = description.getElementsByTagName(name)[0];
    if (node) {
      const values = node.getElementsByTagName("rdf:li");
      if (values.length === 3) {
        returnValue = Array.from(values).map((v) => v.innerHTML);
      } else {
        throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);
      }
    } else {
      if (defaultValue)
        return defaultValue;
      else
        throw new Error(`Can't find ${name} in gainmap metadata`);
    }
  } else {
    returnValue = parsedValue;
  }
  return returnValue;
};
var extractXMP = (input) => {
  var _a2, _b2;
  let str;
  if (typeof TextDecoder !== "undefined")
    str = new TextDecoder().decode(input);
  else
    str = input.toString();
  let start = str.indexOf("<x:xmpmeta");
  const parser = new DOMParser();
  while (start !== -1) {
    const end = str.indexOf("x:xmpmeta>", start);
    str.slice(start, end + 10);
    const xmpBlock = str.slice(start, end + 10);
    try {
      const xmlDocument = parser.parseFromString(xmpBlock, "text/xml");
      const description = xmlDocument.getElementsByTagName("rdf:Description")[0];
      const gainMapMin = getAttribute(description, "hdrgm:GainMapMin", "0");
      const gainMapMax = getAttribute(description, "hdrgm:GainMapMax");
      const gamma = getAttribute(description, "hdrgm:Gamma", "1");
      const offsetSDR = getAttribute(description, "hdrgm:OffsetSDR", "0.015625");
      const offsetHDR = getAttribute(description, "hdrgm:OffsetHDR", "0.015625");
      let hdrCapacityMin = (_a2 = description.attributes.getNamedItem("hdrgm:HDRCapacityMin")) === null || _a2 === void 0 ? void 0 : _a2.nodeValue;
      if (!hdrCapacityMin)
        hdrCapacityMin = "0";
      const hdrCapacityMax = (_b2 = description.attributes.getNamedItem("hdrgm:HDRCapacityMax")) === null || _b2 === void 0 ? void 0 : _b2.nodeValue;
      if (!hdrCapacityMax)
        throw new Error("Incomplete gainmap metadata");
      return {
        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map((v) => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],
        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map((v) => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],
        gamma: Array.isArray(gamma) ? gamma.map((v) => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],
        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map((v) => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],
        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map((v) => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],
        hdrCapacityMin: parseFloat(hdrCapacityMin),
        hdrCapacityMax: parseFloat(hdrCapacityMax)
      };
    } catch (e) {
    }
    start = str.indexOf("<x:xmpmeta", end);
  }
};
var MPFExtractor = class {
  constructor(options) {
    this.options = {
      debug: options && options.debug !== void 0 ? options.debug : false,
      extractFII: options && options.extractFII !== void 0 ? options.extractFII : true,
      extractNonFII: options && options.extractNonFII !== void 0 ? options.extractNonFII : true
    };
  }
  extract(imageArrayBuffer) {
    return new Promise((resolve, reject) => {
      const debug = this.options.debug;
      const dataView = new DataView(imageArrayBuffer.buffer);
      if (dataView.getUint16(0) !== 65496) {
        reject(new Error("Not a valid jpeg"));
        return;
      }
      const length = dataView.byteLength;
      let offset = 2;
      let loops = 0;
      let marker;
      while (offset < length) {
        if (++loops > 250) {
          reject(new Error(`Found no marker after ${loops} loops 😵`));
          return;
        }
        if (dataView.getUint8(offset) !== 255) {
          reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));
          return;
        }
        marker = dataView.getUint8(offset + 1);
        if (debug)
          console.log(`Marker: ${marker.toString(16)}`);
        if (marker === 226) {
          if (debug)
            console.log("Found APP2 marker (0xffe2)");
          const formatPt = offset + 4;
          if (dataView.getUint32(formatPt) === 1297106432) {
            const tiffOffset = formatPt + 4;
            let bigEnd;
            if (dataView.getUint16(tiffOffset) === 18761) {
              bigEnd = false;
            } else if (dataView.getUint16(tiffOffset) === 19789) {
              bigEnd = true;
            } else {
              reject(new Error("No valid endianness marker found in TIFF header"));
              return;
            }
            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 42) {
              reject(new Error("Not valid TIFF data! (no 0x002A marker)"));
              return;
            }
            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);
            if (firstIFDOffset < 8) {
              reject(new Error("Not valid TIFF data! (First offset less than 8)"));
              return;
            }
            const dirStart = tiffOffset + firstIFDOffset;
            const count = dataView.getUint16(dirStart, !bigEnd);
            const entriesStart = dirStart + 2;
            let numberOfImages = 0;
            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {
              if (dataView.getUint16(i, !bigEnd) === 45057) {
                numberOfImages = dataView.getUint32(i + 8, !bigEnd);
              }
            }
            const nextIFDOffsetLen = 4;
            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;
            const images = [];
            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {
              const image = {
                MPType: dataView.getUint32(i, !bigEnd),
                size: dataView.getUint32(i + 4, !bigEnd),
                // This offset is specified relative to the address of the MP Endian
                // field in the MP Header, unless the image is a First Individual Image,
                // in which case the value of the offset shall be NULL (0x00000000).
                dataOffset: dataView.getUint32(i + 8, !bigEnd),
                dependantImages: dataView.getUint32(i + 12, !bigEnd),
                start: -1,
                end: -1,
                isFII: false
              };
              if (!image.dataOffset) {
                image.start = 0;
                image.isFII = true;
              } else {
                image.start = tiffOffset + image.dataOffset;
                image.isFII = false;
              }
              image.end = image.start + image.size;
              images.push(image);
            }
            if (this.options.extractNonFII && images.length) {
              const bufferBlob = new Blob([dataView]);
              const imgs = [];
              for (const image of images) {
                if (image.isFII && !this.options.extractFII) {
                  continue;
                }
                const imageBlob = bufferBlob.slice(image.start, image.end + 1, "image/jpeg");
                imgs.push(imageBlob);
              }
              resolve(imgs);
            }
          }
        }
        offset += 2 + dataView.getUint16(offset + 2);
      }
    });
  }
};
var extractGainmapFromJPEG = async (jpegFile) => {
  const metadata = extractXMP(jpegFile);
  if (!metadata)
    throw new XMPMetadataNotFoundError("Gain map XMP metadata not found");
  const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });
  const images = await mpfExtractor.extract(jpegFile);
  if (images.length !== 2)
    throw new GainMapNotFoundError("Gain map recovery image not found");
  return {
    sdr: new Uint8Array(await images[0].arrayBuffer()),
    gainMap: new Uint8Array(await images[1].arrayBuffer()),
    metadata
  };
};
var getHTMLImageFromBlob = (blob) => {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");
    img.onload = () => {
      resolve(img);
    };
    img.onerror = (e) => {
      reject(e);
    };
    img.src = URL.createObjectURL(blob);
  });
};
var LoaderBase = class extends Loader {
  /**
   *
   * @param renderer
   * @param manager
   */
  constructor(renderer2, manager) {
    super(manager);
    this._renderer = renderer2;
    this._internalLoadingManager = new LoadingManager();
  }
  /**
   * Specify the renderTarget options to use when rendering the gain map
   *
   * @param options
   * @returns
   */
  setRenderTargetOptions(options) {
    this._renderTargetOptions = options;
    return this;
  }
  /**
   * @private
   * @returns
   */
  prepareQuadRenderer() {
    const material = new GainMapDecoderMaterial({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Texture(),
      sdr: new Texture()
    });
    return new QuadRenderer({
      width: 16,
      height: 16,
      type: HalfFloatType,
      colorSpace: LinearSRGBColorSpace,
      material,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions
    });
  }
  /**
  * @private
  * @param quadRenderer
  * @param metadata
  * @param sdrBuffer
  * @param gainMapBuffer
  */
  async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {
    const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: "image/jpeg" }) : void 0;
    const sdrBlob = new Blob([sdrBuffer], { type: "image/jpeg" });
    let sdrImage;
    let gainMapImage;
    let needsFlip = false;
    if (typeof createImageBitmap === "undefined") {
      const res = await Promise.all([
        gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(void 0),
        getHTMLImageFromBlob(sdrBlob)
      ]);
      gainMapImage = res[0];
      sdrImage = res[1];
      needsFlip = true;
    } else {
      const res = await Promise.all([
        gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: "flipY" }) : Promise.resolve(void 0),
        createImageBitmap(sdrBlob, { imageOrientation: "flipY" })
      ]);
      gainMapImage = res[0];
      sdrImage = res[1];
    }
    const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);
    gainMap.flipY = needsFlip;
    gainMap.needsUpdate = true;
    const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);
    sdr.flipY = needsFlip;
    sdr.needsUpdate = true;
    quadRenderer.width = sdrImage.width;
    quadRenderer.height = sdrImage.height;
    quadRenderer.material.gainMap = gainMap;
    quadRenderer.material.sdr = sdr;
    quadRenderer.material.gainMapMin = metadata.gainMapMin;
    quadRenderer.material.gainMapMax = metadata.gainMapMax;
    quadRenderer.material.offsetHdr = metadata.offsetHdr;
    quadRenderer.material.offsetSdr = metadata.offsetSdr;
    quadRenderer.material.gamma = metadata.gamma;
    quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;
    quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;
    quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);
    quadRenderer.material.needsUpdate = true;
    quadRenderer.render();
  }
};
var HDRJPGLoader = class extends LoaderBase {
  /**
   * Loads a JPEG containing gain map metadata
   * Renders a normal SDR image if gainmap data is not found
   *
   * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]
   * @param onLoad Load complete callback, will receive the result
   * @param onProgress Progress callback, will receive a {@link ProgressEvent}
   * @param onError Error callback
   * @returns
   */
  load(url2, onLoad, onProgress, onError) {
    const quadRenderer = this.prepareQuadRenderer();
    const loader = new FileLoader(this._internalLoadingManager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(this.withCredentials);
    this.manager.itemStart(url2);
    loader.load(url2, async (jpeg) => {
      if (typeof jpeg === "string")
        throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");
      const jpegBuffer = new Uint8Array(jpeg);
      let sdrJPEG;
      let gainMapJPEG;
      let metadata;
      try {
        const extractionResult = await extractGainmapFromJPEG(jpegBuffer);
        sdrJPEG = extractionResult.sdr;
        gainMapJPEG = extractionResult.gainMap;
        metadata = extractionResult.metadata;
      } catch (e) {
        if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {
          console.warn(`Failure to reconstruct an HDR image from ${url2}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);
          metadata = {
            gainMapMin: [0, 0, 0],
            gainMapMax: [1, 1, 1],
            gamma: [1, 1, 1],
            hdrCapacityMin: 0,
            hdrCapacityMax: 1,
            offsetHdr: [0, 0, 0],
            offsetSdr: [0, 0, 0]
          };
          sdrJPEG = jpegBuffer;
        } else {
          throw e;
        }
      }
      try {
        await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);
      } catch (error) {
        this.manager.itemError(url2);
        if (typeof onError === "function")
          onError(error);
        quadRenderer.disposeOnDemandRenderer();
        return;
      }
      if (typeof onLoad === "function")
        onLoad(quadRenderer);
      this.manager.itemEnd(url2);
      quadRenderer.disposeOnDemandRenderer();
    }, onProgress, (error) => {
      this.manager.itemError(url2);
      if (typeof onError === "function")
        onError(error);
    });
    return quadRenderer;
  }
};
var getBufferForType = (type, width, height) => {
  let out;
  switch (type) {
    case UnsignedByteType:
      out = new Uint8ClampedArray(width * height * 4);
      break;
    case HalfFloatType:
      out = new Uint16Array(width * height * 4);
      break;
    case UnsignedIntType:
      out = new Uint32Array(width * height * 4);
      break;
    case ByteType:
      out = new Int8Array(width * height * 4);
      break;
    case ShortType:
      out = new Int16Array(width * height * 4);
      break;
    case IntType:
      out = new Int32Array(width * height * 4);
      break;
    case FloatType:
      out = new Float32Array(width * height * 4);
      break;
    default:
      throw new Error("Unsupported data type");
  }
  return out;
};
var _canReadPixelsResult;
var canReadPixels = (type, renderer2, camera, renderTargetOptions) => {
  if (_canReadPixelsResult !== void 0)
    return _canReadPixelsResult;
  const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);
  renderer2.setRenderTarget(testRT);
  const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 16777215 }));
  renderer2.render(mesh, camera);
  renderer2.setRenderTarget(null);
  const out = getBufferForType(type, testRT.width, testRT.height);
  renderer2.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);
  testRT.dispose();
  mesh.geometry.dispose();
  mesh.material.dispose();
  _canReadPixelsResult = out[0] !== 0;
  return _canReadPixelsResult;
};
var QuadRenderer = class _QuadRenderer {
  /**
   *
   * @param sourceTexture
   * @param renderer
   */
  constructor(options) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p2, _q2, _r;
    this._rendererIsDisposable = false;
    this._supportsReadPixels = true;
    this.render = () => {
      this._renderer.setRenderTarget(this._renderTarget);
      try {
        this._renderer.render(this._scene, this._camera);
      } catch (e) {
        this._renderer.setRenderTarget(null);
        throw e;
      }
      this._renderer.setRenderTarget(null);
    };
    this._width = options.width;
    this._height = options.height;
    this._type = options.type;
    this._colorSpace = options.colorSpace;
    const rtOptions = {
      // fixed options
      format: RGBAFormat,
      depthBuffer: false,
      stencilBuffer: false,
      // user options
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy: ((_a2 = options.renderTargetOptions) === null || _a2 === void 0 ? void 0 : _a2.anisotropy) !== void 0 ? (_b2 = options.renderTargetOptions) === null || _b2 === void 0 ? void 0 : _b2.anisotropy : 1,
      generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== void 0 ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,
      magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== void 0 ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,
      minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== void 0 ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,
      samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== void 0 ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : void 0,
      wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== void 0 ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,
      wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== void 0 ? (_p2 = options.renderTargetOptions) === null || _p2 === void 0 ? void 0 : _p2.wrapT : ClampToEdgeWrapping
    };
    this._material = options.material;
    if (options.renderer) {
      this._renderer = options.renderer;
    } else {
      this._renderer = _QuadRenderer.instantiateRenderer();
      this._rendererIsDisposable = true;
    }
    this._scene = new Scene();
    this._camera = new OrthographicCamera();
    this._camera.position.set(0, 0, 10);
    this._camera.left = -0.5;
    this._camera.right = 0.5;
    this._camera.top = 0.5;
    this._camera.bottom = -0.5;
    this._camera.updateProjectionMatrix();
    if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {
      let alternativeType;
      switch (this._type) {
        case HalfFloatType:
          alternativeType = this._renderer.extensions.has("EXT_color_buffer_float") ? FloatType : void 0;
          break;
      }
      if (alternativeType !== void 0) {
        console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);
        this._type = alternativeType;
      } else {
        this._supportsReadPixels = false;
        console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown");
      }
    }
    this._quad = new Mesh(new PlaneGeometry(), this._material);
    this._quad.geometry.computeBoundingBox();
    this._scene.add(this._quad);
    this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);
    this._renderTarget.texture.mapping = ((_q2 = options.renderTargetOptions) === null || _q2 === void 0 ? void 0 : _q2.mapping) !== void 0 ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;
  }
  /**
   * Instantiates a temporary renderer
   *
   * @returns
   */
  static instantiateRenderer() {
    const renderer2 = new WebGLRenderer();
    renderer2.setSize(128, 128);
    return renderer2;
  }
  /**
   * Obtains a Buffer containing the rendered texture.
   *
   * @throws Error if the browser cannot read pixels from this RenderTarget type.
   * @returns a TypedArray containing RGBA values from this renderer
   */
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const out = getBufferForType(this._type, this._width, this._height);
    this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);
    return out;
  }
  /**
   * Performs a readPixel operation in the renderTarget
   * and returns a DataTexture containing the read data
   *
   * @params options
   * @returns
   */
  toDataTexture(options) {
    const returnValue = new DataTexture(
      // fixed values
      this.toArray(),
      this.width,
      this.height,
      RGBAFormat,
      this._type,
      // user values
      (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping,
      (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping,
      (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping,
      (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter,
      (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter,
      (options === null || options === void 0 ? void 0 : options.anisotropy) || 1,
      // fixed value
      LinearSRGBColorSpace
    );
    returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== void 0 ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;
    return returnValue;
  }
  /**
   * If using a disposable renderer, it will dispose it.
   */
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null);
    if (this._rendererIsDisposable) {
      this._renderer.dispose();
      this._renderer.forceContextLoss();
    }
  }
  /**
   * Will dispose of **all** assets used by this renderer.
   *
   *
   * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later
   * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`
   * or are otherwise done with it.
   *
   * @example
   * ```js
   * const loader = new HDRJPGLoader(renderer)
   * const result = await loader.loadAsync('gainmap.jpeg')
   * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )
   * // DO NOT dispose the renderTarget here,
   * // it is used directly in the material
   * result.dispose()
   * ```
   *
   * @example
   * ```js
   * const loader = new HDRJPGLoader(renderer)
   * const pmremGenerator = new PMREMGenerator( renderer );
   * const result = await loader.loadAsync('gainmap.jpeg')
   * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)
   * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )
   * // renderTarget can be disposed here
   * // because it was used to generate a PMREM texture
   * result.dispose(true)
   * ```
   */
  dispose(disposeRenderTarget) {
    this.disposeOnDemandRenderer();
    if (disposeRenderTarget) {
      this.renderTarget.dispose();
    }
    if (this.material instanceof ShaderMaterial) {
      Object.values(this.material.uniforms).forEach((v) => {
        if (v.value instanceof Texture)
          v.value.dispose();
      });
    }
    Object.values(this.material).forEach((value) => {
      if (value instanceof Texture)
        value.dispose();
    });
    this.material.dispose();
    this._quad.geometry.dispose();
  }
  /**
   * Width of the texture
   */
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._renderTarget.setSize(this._width, this._height);
  }
  /**
   * Height of the texture
   */
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._renderTarget.setSize(this._width, this._height);
  }
  /**
   * The renderer used
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * The `WebGLRenderTarget` used.
   */
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(value) {
    this._renderTarget = value;
    this._width = value.width;
    this._height = value.height;
  }
  /**
   * The `Material` used.
   */
  get material() {
    return this._material;
  }
  /**
   *
   */
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
};
var skyOption = {
  sunPosition: new Vector3(0.27, 1, 0.5),
  sunTop: new Vector3(0, 0.99, 0),
  saturation: 1,
  noiseMap: null,
  //shadow:1.0,
  //sunIntensity:100,//1.26,
  //hemiIntensity:1,//2,//2.79,
  nightLuminosity: 0.03,
  //HOUR:12,
  //AZIMUTH:0,
  cloud_size: 0.29,
  cloud_covr: 0.1,
  //0.56,
  cloud_dens: 0.4,
  cloud_dist: 0.64,
  haze: 0.1,
  mixRatio: 0.76,
  SAMPLE: 64,
  //128*0.5,
  STEP: 4,
  //16
  cloudColor: new Color(16777209).multiplyScalar(1),
  skyColor: new Color(4348022),
  fogColor: new Color(11253184),
  groundColor: new Color(8421504),
  sunColor: new Color(16777215).multiplyScalar(3)
};
var SkyShader = {
  defines: {
    "USE_NOISE_MAP": false
  },
  uniforms: {
    lightdir: { value: skyOption.sunPosition },
    sunTop: { value: skyOption.sunTop },
    noiseMap: { value: skyOption.noiseMap },
    mixRatio: { value: skyOption.mixRatio },
    cloud_size: { value: skyOption.cloud_size },
    cloud_covr: { value: skyOption.cloud_covr },
    cloud_dens: { value: skyOption.cloud_dens },
    cloud_dist: { value: skyOption.cloud_dist },
    nightLuminosity: { value: skyOption.nightLuminosity },
    haze: { value: skyOption.haze },
    saturation: { value: skyOption.saturation },
    SAMPLE: { value: skyOption.SAMPLE },
    STEP: { value: skyOption.STEP },
    fogy: { value: skyOption.fogy },
    t: { value: 1 },
    // extra color
    fogColor: { value: skyOption.fogColor },
    groundColor: { value: skyOption.groundColor },
    cloudColor: { value: skyOption.cloudColor },
    skyColor: { value: skyOption.skyColor },
    sunColor: { value: skyOption.sunColor }
  },
  vertexShader: (
    /* glsl */
    `
varying vec3 worldPosition;
void main()	{
	worldPosition = ( modelMatrix * vec4( position, 1.0 )).xyz;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}
`
  ),
  fragmentShader: (
    /* glsl */
    `
//precision highp float;
varying vec3 worldPosition;

uniform vec3 fogColor;
uniform vec3 groundColor;
uniform vec3 cloudColor;
uniform vec3 skyColor;
uniform vec3 sunColor;

uniform float saturation;

uniform float hue;
uniform float mixRatio;
uniform float fogy;

uniform vec3 sunTop;

uniform sampler2D noiseMap;
uniform vec3 lightdir;

uniform float cloud_size;
uniform float cloud_covr;
uniform float cloud_dens;
uniform float cloud_dist;

uniform float nightLuminosity;
uniform float haze;
uniform float t;

uniform int SAMPLE;
uniform int STEP;

//const float c = 6.36e6;
//const float d = 6.38e6;
const float c = 6.407e6;
const float d = 6.416e6;

//const float g = 0.76; // mix ratio
//const float h = g*g;
const float icc = 1.0/8e3;
const float jcc = 1.0/1200.0;
const float pi = 3.141592653589793;

const vec3 vm = vec3( 0,-c,0 );
//const vec3 vn = vec3( 2.1e-5 );
//const vec3 vo = vec3( 5.8e-6, 1.35e-5, 3.31e-5 );

//const vec3 vn = vec3( 0.000021 );
//const vec3 vo = vec3( 0.0000058, 0.0000135, 0.0000331 );// sky base color

//const vec3 vo = vec3( 0.000021 );// sky base color


#ifdef USE_NOISE_MAP

float noise( in vec3 x ){
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
    vec2 rg = texture2D( noiseMap, (uv+0.5)/256.0, -16.0 ).yx;
    return mix( rg.x, rg.y, f.z );
}

#else

float hash( float n ) { return fract(sin(n)*753.5453123); }
float noise( in vec3 x ){
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*157.0 + 113.0*p.z;
    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),
               mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}

#endif

float NOISE( vec3 r )
{
	r.xz += t;
	r *= 0.5;
	float s;
	s = 0.5 * noise(r);
	r = r * 2.52;
	s += 0.25 * noise(r);
	r = r * 2.53;
	s += 0.125 * noise(r);
	r = r * 2.51;
	s += 0.0625 * noise(r);
	r = r * 2.53;
	s += 0.03125 * noise(r);
	r = r * 2.52;
	s += 0.015625 * noise(r);
	return s;
}

float MakeNoise( vec3 r )
{
	float s,tt;
	s = NOISE( r * 2e-4 * ( 1.0 - cloud_size ) );
	tt = ( 1.0 - cloud_covr ) * 0.5 + 0.2;
	s = smoothstep( tt, tt+.2 , s );
	s *= 0.5*(cloud_dens*100.0);
	return s;
}

void clouds( in vec3 r, out vec3 u )
{
	float v,w;
	v = length( r-vm ) - c;
	w = 0.0;
	if( 5e3 < v && v < 1e4 ) w = MakeNoise( r ) * (sin( pi*(v-5e3)/5e3 ));
	u = vec3( exp(-v*icc), exp(-v*jcc), w );
}

float ca( in vec3 r, in vec3 s, in float t )
{
	vec3 u = r - vm;
	float v,w,x,y,z,A;
	v = dot(u,s);
	w = dot(u,u)-t*t;
	x = v*v-w;
	if( x < 0.0 ) return -1.0;
	y = sqrt(x);
	z = -v-y;
	A = -v+y;
	return z >= 0.0 ? z : A;
}

vec3 czm_saturation(vec3 rgb, float adjustment)
{
    vec3 W = vec3(0.2125, 0.7154, 0.0721);
    vec3 intensity = vec3(dot(rgb, W));
    return mix(intensity, rgb, adjustment);
}


vec3 makeSky( in vec3 lightpos, in vec3 r, in vec3 world, out float mask )
{

	vec3 vn = vec3( 0.000021 );
	vec3 vo = skyColor;
	vo *= 0.00005;

	float u,v,w,x,y,z,m, M, N, S, H, F;
	vec3 p = lightpos;
	u = ca(r,world,d);
	v = dot(world,p);
	w = 1.0+v*v;

	float gg = mixRatio;
	float hh = gg*gg;

	x = 0.0596831*w;
	y = 0.0253662*(1.0-hh)*w/((2.0+hh)*pow(abs(1.0+hh-2.0*gg*v),1.5));
	z = 50.*pow(abs(1.+dot(world,-p)),2.0)*dot(vec3(0.,1.,0.),p)*(1.0-cloud_covr)*(1.0-min(fogy,1.0));

	m = 0.0;
	vec3 D,E, CB, CM, BB, BM, SX;

	F = u / float( SAMPLE );

	BB = vec3(0.0);
	BM = vec3(0.0);

	float count = 0.0;

	for( int G=0; G<SAMPLE; ++G ){

		H = float(G)*F;
		vec3 I = r + world * H;
		//CB = vec3(1.0);
		//BB = vec3(0.0);
		clouds( I, CB );
		CB += fogy;// add fog
		CB.y += CB.z;// add clound
		CB.xy *= F;
		BB += CB;

		M = ca(I,p,d);

		if( M > 0.0 ){

			N = M/float(STEP);
			BM = vec3(0.0);

			for( int R=0; R<STEP; ++R ){

				S = float(R)*N;
				vec3 T=I+p*S;
				clouds( T, CM );
				CM += fogy;// add fog
				CM.y += CM.z;// add clound
				BM += CM * N;

			}

			SX = exp(-(vo*(BM.x+BB.x)+vn*(BM.y+BB.y)* cloud_dist));

			m += CB.z;
			count += 1.0;
			D += SX*CB.x;
			E += (SX*CB.y)+z*m;
		}
		else return vec3(0.0);
	}
	//mask = m * 0.0125;
	//mask = m / count;
	mask = m / float( SAMPLE );

	return ((D * vo * x ) + (E * vn * y * sunColor)) * 15.0;
}


void main()
{
	vec3 light = normalize( lightdir );
	vec3 world = normalize( worldPosition.xyz );

	float uvy = acos( world.y ) / pi;

	//float luma = smoothstep(0.0, 4.0,  1.0-(abs(world.y)/0.8) );
    //float mid = smoothstep(0.0, 1.0,  abs(world.y) < haze ? 1.0-(abs(world.y)/(haze*1.0)) : 0.0 );
    //mid *= nightLuminosity;//pow(  mid, 1.0 );

    // ground reapeat sky
	//if( world.y < -0.15) world.y = -0.15+((-world.y-0.15)*0.1);
	if( world.y < 0.0) world.y = -world.y;

	float high = smoothstep(1.0, 0.0, (uvy)*10000.0);
	float top =  smoothstep(1.0, 0.0, (uvy-0.5)*50.0);
	float middle = uvy > 0.5 ? high : smoothstep(0.0, 1.0, (0.5-uvy)*((1.0-haze)*100.0));

	float middle2 = uvy > 0.5 ? smoothstep(0.0, 1.0, (0.5-uvy)*((1.0-haze)*100.0)) : smoothstep(0.0, 1.0, (0.5-uvy)*((1.0-haze)*100.0));

	vec3 s = sunTop;
	float lm = dot( s, light );
	float day = clamp((lm*4.0), 0.0, (1.0-nightLuminosity) )+nightLuminosity;

	if(lm <= 0.0) light *= -1.0;
	light.y = abs(light.y);

	//if(light.y < 0.1) light.y = 0.1;
	light.y = clamp(light.y, 0.1, 1.0 );
	//light.y += 0.5;

	float mask = 0.0;

	vec3 sky = makeSky( light, s, world, mask );
	mask = clamp(mask, 0.0, 1.0 );
	sky = mix( sky, cloudColor, mask ); //apply cloud color
	

	//sky = mix( sky, groundColor, 1.0-middle ); // apply ground color
	sky = mix( sky, fogColor, 1.0-middle2 ); // apply fog color
	
    //float dd = clamp(day+(nightLuminosity*0.5), 0.0, 1.0);
	//luma *= 1.0-dd;
	//clear = mix( clear, clear+skyColor, luma ); // extra luminosity on night

	sky *= day;
	//sky = czm_saturation(sky, saturation);
    //sky = clamp(sky, 0.0, 1.0 );


 	gl_FragColor = vec4( sky, 1.0 );

}
`
  ),
  depthWrite: false,
  depthTest: false,
  side: 1,
  toneMapped: false,
  fog: false
};
var torad = Math.PI / 180;
var Envmap = class {
  constructor(o = {}) {
    this.mainScene = o.scene;
    this.renderer = o.renderer;
    this.usePrem = o.usePmrem !== void 0 ? o.usePmrem : false;
    this.useBackground = o.useBackground !== void 0 ? o.useBackground : true;
    this.envBlur = o.envBlur !== void 0 ? o.envBlur : 0;
    this.callback = o.callback || null;
    this.isSky = false;
    if (this.usePrem) {
      this.pmremGenerator = new PMREMGenerator(this.renderer);
      this.pmremGenerator.compileEquirectangularShader();
    }
    if (o.cube) this.initCubeEnv(o);
    if (o.url) this.load(o.url);
  }
  initCubeEnv(o = {}) {
    this.isCubeEnv = true;
    this._quality = o.quality || 1;
    this.scene = new Scene();
    if (o.color) this.scene.background = new Color(o.color);
    this.target = new WebGLCubeRenderTarget(256 * this._quality, {
      //magFilter: LinearFilter,
      minFilter: LinearFilter,
      type: HalfFloatType,
      //format: RGBAFormat,
      //colorSpace: LinearSRGBColorSpace,
      colorSpace: SRGBColorSpace,
      //generateMipmaps: false,
      //depthBuffer: false,
      //generateMipmaps:true,
      anisotropy: 1
    });
    this.camera = new CubeCamera(o.near || 0.1, o.far || 100, this.target);
    this.mainScene.environment = this.target.texture;
    if (this.useBackground) this.mainScene.background = this.target.texture;
  }
  addSky() {
    let g2 = new IcosahedronGeometry(20, 1);
    const mat2 = new ShaderMaterial(SkyShader);
    this.sky = new Mesh(g2, mat2);
    this.scene.add(this.sky);
    this.render();
    this.isSky = true;
  }
  getSkyOtion() {
    if (!this.isSky) return;
    return skyOption;
  }
  setSkyOtion(o) {
    if (!this.isSky) return;
    let u = this.sky.material.uniforms;
    for (let k in o) {
      if (u[k]) u[k].value = o[k];
    }
    if (this.timeout) clearTimeout(this.timeout);
    this.timeout = setTimeout(this.render.bind(this), 0);
  }
  render() {
    if (!this.isCubeEnv) return;
    const renderer2 = this.renderer;
    const lastToneMapping = renderer2.toneMapping;
    renderer2.toneMapping = NoToneMapping;
    this.camera.update(renderer2, this.scene);
    renderer2.toneMapping = lastToneMapping;
  }
  load(url2) {
    this.name = url2.substring(url2.lastIndexOf("/") + 1, url2.lastIndexOf("."));
    this.type = url2.substring(url2.lastIndexOf(".") + 1).toLowerCase();
    this.loader = null;
    switch (this.type) {
      case "hdr":
        this.loader = new RGBELoader().load(url2, this.end.bind(this), null, this.bug.bind(this));
        break;
      case "exr":
        this.loader = new EXRLoader().load(url2, this.end.bind(this), null, this.bug.bind(this));
        break;
      case "jpg":
        this.loader = new HDRJPGLoader(this.renderer).load(url2, this.end.bind(this), null, this.bug.bind(this));
        break;
    }
  }
  bug() {
    console.log("Envmap is not find :", this.name);
    if (this.callback) this.callback();
  }
  end() {
    let env;
    switch (this.type) {
      case "hdr":
      case "exr":
        env = this.loader;
        env.mapping = EquirectangularReflectionMapping;
        break;
      case "jpg":
        env = this.loader.renderTarget.texture;
        env.mapping = EquirectangularReflectionMapping;
        break;
    }
    if (this.usePrem) {
      env = this.pmremGenerator.fromEquirectangular(env).texture;
      this.pmremGenerator.dispose();
    }
    env.needsUpdate = true;
    const scene2 = this.isCubeEnv ? this.scene : this.mainScene;
    if (this.isCubeEnv || this.useBackground) scene2.background = env;
    if (this.envBlur) scene2.backgroundBlurriness = this.envBlur;
    scene2.environment = env;
    this.loader.dispose();
    if (this.callback) this.callback();
  }
  get intensity() {
    return this.mainScene.environmentIntensity;
  }
  set intensity(value) {
    this.mainScene.environmentIntensity = value;
  }
  get bgIntensity() {
    return this.mainScene.backgroundIntensity;
  }
  set bgIntensity(value) {
    this.mainScene.backgroundIntensity = value;
  }
  get blur() {
    return this.mainScene.backgroundBlurriness;
  }
  set blur(value) {
    this.mainScene.backgroundBlurriness = value;
  }
  rotate(x2 = 0, y = 0, z = 0) {
    if (x2 !== 0) x2 *= torad;
    if (y !== 0) y *= torad;
    if (z !== 0) z *= torad;
    this.mainScene.environmentRotation.set(x2, y, z);
    this.mainScene.backgroundRotation.set(x2, y, z);
  }
};
var AutoRagdoll = class {
  constructor(o = {}) {
    this.id = 0;
    this.type = "autoRagdoll";
    this.name = o.name || this.type + this.id++;
    let b = Utils.byName(this.name);
    if (b) Utils.remove(b);
    this._mode = o.mode || "follow";
    this._size = o.size || 1;
    this._debug = o.debug || false;
    const model2 = clone(o.model);
    model2.scale.set(1, 1, 1).multiplyScalar(this._size);
    if (o.pos) model2.position.fromArray(o.pos);
    model2.raycast = function() {
      return;
    };
    model2.name = this.name;
    let bones;
    model2.traverse((child) => {
      if (child.isMesh) {
        child.frustumCulled = false;
      }
      if (child.isSkinnedMesh) {
        child.raycast = function() {
          return;
        };
        child.frustumCulled = false;
        child.matrixAutoUpdate = false;
        child.receiveShadow = true;
        child.castShadow = true;
        if (o.material) child.material = o.material;
        child.skeleton.resetScalling();
        bones = child.skeleton.bones;
      }
    });
    let mass = o.mass || null;
    this.skeletonBody = new SkeletonBody(model2.name, model2, bones, mass, o.option);
    this.debug = this._debug;
    this.mode = this._mode;
    model2.add(this.skeletonBody);
    root.scene.add(model2);
    this.model = model2;
    Utils.add(this);
    return this;
  }
  getRealPosition() {
    let node = Utils.byName(this.skeletonBody.nodes[0].name);
    return node.position;
  }
  dispose() {
    if (this.skeletonBody) this.skeletonBody.dispose();
    if (this.model) this.model.parent.remove(this.model);
  }
  //
  get position() {
    return model.position;
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
    this.model.scale.set(1, 1, 1).multiplyScalar(this._size);
  }
  //
  get debug() {
    return this._debug;
  }
  set debug(value) {
    this._debug = value;
    this.skeletonBody.isVisible(this._debug);
  }
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
    this.skeletonBody.setMode(this._mode);
  }
};
var _offsetMatrix = new Matrix4();
var _identityMatrix = new Matrix4();
new Vector3();
var K = Skeleton.prototype;
K.byName = function(name) {
  let i = this.bones.length;
  while (i--) if (this.bones[i].name === name) return this.bones[i];
  return null;
};
K.getId = function(name) {
  let i = this.bones.length;
  while (i--) if (this.bones[i].name === name) return i;
  return null;
};
K.setExtraRotation = function(b, x2, y, z) {
  let bone = b.isBone ? b : this.byName(b);
  if (!bone) return;
  MathUtils.DEG2RAD;
};
K.setScalling = function(b, x2, y, z) {
  let bone = b.isBone ? b : this.byName(b);
  if (!bone) return;
  bone.scalling = new Vector3(x2, y, z);
};
K.resetScalling = function(b) {
  this.pose();
  this.scalled = true;
  for (let i = 0, il = this.bones.length; i < il; i++) {
    this.bones[i].isPhysics = false;
    this.bones[i].phyMtx = new Matrix4();
  }
  if (!b) this.applyScalling();
};
K.childScale = function(bone, matrix) {
  if (!this.scalled) return;
  if (bone.scalling) matrix.scale(bone.scalling);
  let j = bone.children.length, child, k = 0;
  while (j--) {
    child = bone.children[k];
    k++;
    if (child.isBone) {
      child.matrixWorld.multiplyMatrices(matrix, child.matrix);
    } else {
      child.matrixWorld.multiplyMatrices(matrix, child.matrix);
    }
  }
};
K.applyScalling = function(fingerPos) {
  let b, i, lng = this.bones.length;
  let parent;
  for (i = 0; i < lng; i++) {
    b = this.bones[i];
    parent = b.parent || null;
    if (parent !== null && parent.scalling && b.name !== "root") {
      b.position.multiply(parent.scalling);
      b.updateMatrixWorld(true);
    }
  }
  this.calculateInverses();
};
K.update = function() {
  const bones = this.bones;
  const boneInverses = this.boneInverses;
  const boneMatrices = this.boneMatrices;
  const boneTexture = this.boneTexture;
  let i = bones.length, bone, n2 = 0;
  while (i--) {
    bone = bones[n2];
    const matrix = bone ? bone.isPhysics ? bone.phyMtx : bone.matrixWorld : _identityMatrix;
    this.childScale(bone, matrix);
    _offsetMatrix.multiplyMatrices(matrix, boneInverses[n2]);
    _offsetMatrix.toArray(boneMatrices, n2 * 16);
    n2++;
  }
  if (boneTexture !== null) {
    boneTexture.needsUpdate = true;
  }
};
var Version = {
  PHY: "0.2.9",
  PHYSX: "5.05.10",
  HAVOK: "1.2.1",
  JOLT: "0.32.0",
  RAPIER: "0.14.0",
  OIMO: "1.2.4",
  AMMO: "3.2.6"
};
var items = {};
var currentControle = null;
var callbackReady = null;
var worker = null;
var isWorker = false;
var isBuffer = false;
var isTimeout = false;
var outsideStep = true;
var engineReady = false;
var breaker = null;
var isAdd = false;
var timetest = { t1: 0, t2: 0, t3: 0, t4: 0 };
var mouseTool = null;
var directMessage = null;
var controls = null;
var isPause = false;
var first = true;
var timout = null;
var timoutFunction = null;
var timoutTime = 0;
var elapsedTime = 0;
var envmapUrl = "";
var _envmap = null;
var renderer = null;
var scene = null;
var user = new User();
var timer = new Timer(60);
var tt = { start: 0, end: 0, startTime: "" };
var azimut = () => 0;
var endReset = () => {
};
var postUpdate = () => {
};
var addControl = () => {
};
var buttons = [];
var textfields = [];
var particles = [];
var settings = {
  fps: 60,
  fixe: true,
  full: false,
  substep: 2,
  gravity: [0, -9.81, 0]
};
var _Motor = class _Motor {
  /*get onFrame() {
         return this._name;
     }*/
  //static version( f ) { return Version.PHY; }
  static set onStep(f) {
    postUpdate = f;
  }
  static debugMode(b) {
    _Motor.setDebugMode(b);
  }
  static setDebugMode(b) {
    root.debug = b;
  }
  static useRealLight(o) {
    Mat.useRealLight(o);
  }
  static getSetting() {
    return settings;
  }
  static getRoot() {
    return root;
  }
  static setGravity(v) {
    if (v) settings.gravity = v;
    root.post({ m: "setGravity", o: { gravity: settings.gravity } });
  }
  static set(o = {}) {
    settings.fixe = o.fixe !== void 0 ? o.fixe : true;
    settings.full = o.full !== void 0 ? o.full : false;
    settings.gravity = o.gravity ? o.gravity : [0, -9.81, 0];
    settings.substep = o.substep ? o.substep : 2;
    settings.fps = o.fps ? o.fps : 60;
    if (o.key) addControl();
    items.body.setFull(settings.full);
    _Motor.initArray(settings.full);
    elapsedTime = 0;
    isTimeout = isWorker;
    outsideStep = !isTimeout;
    root.jointVisible = o.jointVisible || false;
    if (outsideStep) timer.setFramerate(settings.fps);
    const data = {
      ...settings,
      ArPos: root.ArPos,
      isTimeout,
      outsideStep
    };
    root.post({ m: "set", o: data });
  }
  static activeMouse(controler, mode) {
    if (!mouseTool) mouseTool = new MouseTool(controler, mode);
  }
  static mouseMode(mode, o) {
    if (mouseTool) mouseTool.setMode(mode, o);
  }
  static getTime() {
    return Timer.now();
  }
  static readTime(t2) {
    return Timer.format_time(t2);
  }
  static startTime() {
    return tt.startTime;
  }
  static getTimeTest() {
    return timetest;
  }
  static setMaxFps(v) {
  }
  static getMouse() {
    return mouseTool ? mouseTool.mouse : null;
  }
  static setMaxAnisotropy(f) {
    Pool.maxAnisotropy = f;
  }
  static setAddControl(f) {
    addControl = f;
  }
  static setPrevUpdate(f) {
  }
  static setPostUpdate(f) {
    postUpdate = f !== null ? f : () => {
    };
  }
  static setAzimut(f) {
    azimut = f;
  }
  static setRenderer(f) {
    renderer = f;
    Pool.renderer = renderer;
  }
  static setKey(i, v) {
    return user.setKey(i, v);
  }
  static getKey() {
    return user.key;
  }
  static getKey2() {
    return user.key2;
  }
  static getAzimut() {
    return azimut();
  }
  static setContent(Scene2) {
    if (isAdd) return;
    scene = Scene2;
    scene.add(root.scene);
    scene.add(root.scenePlus);
    isAdd = true;
  }
  //static autoRagdoll ( o ) { return new AutoRagdoll( o ); }
  //static getScene () { return root.scene; }
  //static byName ( name ){ return Utils.byName( name ); }
  static makeView() {
  }
  static resize(size) {
    root.viewSize = size;
  }
  static init(o = {}) {
    typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    tt.start = Timer.now();
    const compact = o.compact || false;
    let url2 = document.location.href.replace(/\/[^/]*$/, "/");
    let arr = url2.split("/");
    url2 = arr[0] + "//" + arr[2] + "/";
    if (url2 === "https://lo-th.github.io/") url2 = "https://lo-th.github.io/phy/";
    let path = o.path || "";
    path += compact ? "compact/" : "build/";
    let type = o.type || "PHYSX";
    let name = type.toLowerCase();
    let mini = name.charAt(0).toUpperCase() + name.slice(1);
    root.engine = type;
    _Motor.initItems();
    Pool.materialRoot = Mat.set;
    Mat.initExtandShader();
    if (o.callback) {
      callbackReady = o.callback;
      delete o.callback;
    }
    isWorker = o.worker || false;
    root.scene = new Group();
    root.scene.name = "phy_scene";
    root.scenePlus = new Group();
    root.scenePlus.name = "phy_scenePlus";
    if (o.scene) {
      _Motor.setContent(o.scene);
      delete o.scene;
    }
    if (o.renderer) {
      _Motor.setRenderer(o.renderer);
      delete o.renderer;
    }
    envmapUrl = o.envmap || "";
    root.post = _Motor.post;
    root.motor = _Motor;
    if (compact) {
      Pool.load(url2 + path + mini + ".hex", function() {
        _Motor.onCompactDone(o);
      });
    } else {
      if (isWorker) {
        worker = new Worker(url2 + path + mini + ".min.js");
        worker.postMessage = worker.webkitPostMessage || worker.postMessage;
        worker.onmessage = _Motor.message;
        let ab = new ArrayBuffer(1);
        worker.postMessage({ m: "test", ab }, [ab]);
        isBuffer = ab.byteLength ? false : true;
        o.isBuffer = isBuffer;
        _Motor.initPhysics(o);
      } else {
        if (o.devMode) _Motor.preLoad(mini, o, url2);
        else _Motor.preLoadMin(mini, o, url2);
      }
    }
  }
  static onCompactDone(o) {
    let name = root.engine.toLowerCase();
    let mini = name.charAt(0).toUpperCase() + name.slice(1);
    let code = Pool.get(mini, "H");
    if (isWorker) {
      let blob;
      try {
        blob = new Blob([code], { type: "application/javascript" });
      } catch (e) {
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(code);
        blob = blob.getBlob();
      }
      worker = new Worker(URL.createObjectURL(blob));
      worker.postMessage = worker.webkitPostMessage || worker.postMessage;
      worker.onmessage = _Motor.message;
      let ab = new ArrayBuffer(1);
      worker.postMessage({ m: "test", ab }, [ab]);
      isBuffer = ab.byteLength ? false : true;
      o.isBuffer = isBuffer;
      _Motor.initPhysics(o);
    } else {
      let type = name.toUpperCase();
      if (type === "RAPIER") type = "RAPIER3D";
      let n2 = document.createElement("script");
      n2.language = "javascript";
      n2.type = "text/javascript";
      n2.charset = "utf-8";
      n2.async = true;
      n2.innerHTML = code;
      document.getElementsByTagName("head")[0].appendChild(n2);
      directMessage = window[type].engine.message;
      o.message = _Motor.message;
      _Motor.initPhysics(o);
    }
  }
  static loadWasmDirect(link, o, name, url2) {
    let s = document.createElement("script");
    s.src = url2 + link;
    document.body.appendChild(s);
    s.onload = () => {
      _Motor.preLoad(name, o, url2);
    };
  }
  static preLoadMin(name, o, url2) {
    let link = url2 + "build/" + name + ".min.js";
    let type = name.toUpperCase();
    if (type === "RAPIER") type = "RAPIER3D";
    var xml = new XMLHttpRequest();
    xml.open("GET", link);
    xml.overrideMimeType("text/javascript");
    xml.onreadystatechange = (function() {
      if (xml.readyState === 4) {
        if (xml.status === 200 || xml.status === 0) {
          let n2 = document.createElement("script");
          n2.language = "javascript";
          n2.type = "text/javascript";
          n2.charset = "utf-8";
          n2.async = true;
          n2.innerHTML = xml.responseText;
          document.getElementsByTagName("head")[0].appendChild(n2);
          directMessage = window[type].engine.message;
          o.message = _Motor.message;
          _Motor.initPhysics(o);
        } else console.error("Couldn't load [" + name + "] [" + xml.status + "]");
      }
    }).bind(this);
    xml.send(null);
  }
  static async preLoad(name, o, url2) {
    let link = url2 + "build/" + name + ".module.js";
    if (o.devMode) link = url2 + "src/" + name + ".js";
    let M2 = await import(link);
    directMessage = M2.engine.message;
    o.message = _Motor.message;
    _Motor.initPhysics(o);
  }
  ////
  static initPhysics(o) {
    if (envmapUrl !== "") {
      _Motor.preloadEnvmap(o);
      return;
    }
    root.post({ m: "init", o });
    engineReady = true;
  }
  static addEnvmap(o) {
    if (!_envmap) _envmap = new Envmap({ renderer, scene, ...o });
    return _envmap;
  }
  static preloadEnvmap(o) {
    _envmap = new Envmap({
      url: envmapUrl,
      renderer,
      scene,
      usePmrem: o.usePmrem,
      useBackground: o.useBackground !== void 0 ? o.useBackground : true,
      envBlur: o.envBlur !== void 0 ? o.envBlur : 0,
      callback: () => {
        envmapUrl = "";
        _Motor.initPhysics(o);
      }
    });
  }
  static getPause() {
    return isPause;
  }
  static pause(v) {
    if (v === isPause) return;
    isPause = v;
    if (isPause) _Motor.pausetimout();
    else _Motor.playtimout();
    root.post({ m: "pause", o: { value: isPause } });
  }
  static flowReset() {
    root.flow = {
      stamp: 0,
      current: "",
      key: [],
      tmp: [],
      add: [],
      remove: []
      //point:[]
    };
  }
  static reset(callback) {
    if (first) {
      first = false;
      callback();
      return;
    }
    buttons = [];
    currentControle = null;
    if (controls) controls.resetAll();
    if (mouseTool) mouseTool.unSelect();
    endReset = callback;
    postUpdate = function() {
    };
    _Motor.clearText();
    _Motor.clearParticleSolver();
    _Motor.cleartimout();
    _Motor.flowReset();
    _Motor.clearInstance();
    _Motor.resetItems();
    Geo.dispose();
    Mat.dispose();
    root.disposeTmp();
    root.garbage = [];
    if (breaker !== null) breaker = null;
    root.tmpTex = [];
    root.scenePlus.children = [];
    root.scene.children = [];
    root.post({ m: "reset" });
  }
  static clearGarbage() {
    _Motor.remove(root.garbage);
    _Motor.clearInstance();
    root.garbage = [];
  }
  static clear(callback) {
    _Motor.reset(callback);
  }
  static resetCallback() {
    endReset();
  }
  static dispose() {
    _Motor.reset(() => {
      if (worker) {
        worker.terminate();
        worker = null;
      }
      if (isAdd) {
        root.scene.parent.remove(root.scene);
        root.scenePlus.parent.remove(root.scenePlus);
        isAdd = false;
      }
    });
  }
  static ready() {
    tt.end = Timer.now();
    tt.startTime = Timer.format_time(tt.end - tt.start);
    console.log(
      "%c" + root.engine + " %c" + Version[root.engine] + "%c | " + (isWorker ? "Worker" : "Direct") + " " + tt.startTime,
      "font-size:16px",
      "font-size:12px",
      "font-size:12px"
    );
    if (callbackReady) callbackReady();
  }
  static start(o = {}) {
    root.post({ m: "start", o });
  }
  static morph(obj, name, value) {
    Utils.morph(obj, name, value);
  }
  static getFps() {
    return root.reflow.stat.fps;
  }
  static getDelta2() {
    return root.delta;
  }
  static getElapsedTime2() {
    return elapsedTime;
  }
  static setDelta(v) {
    timer.delta = v;
  }
  static getDelta() {
    return timer.delta;
  }
  static getElapsedTime() {
    return timer.elapsedTime;
  }
  static doStep(stamp) {
    if (!engineReady) return;
    if (!outsideStep) return;
    if (timer.up(stamp)) {
      root.post({ m: "step", o: stamp });
    }
  }
  static step() {
    root.delta = root.reflow.stat.delta;
    root.flow.key = user.update();
    root.flow.current = currentControle !== null ? currentControle.name : "";
    _Motor.stepItems();
    if (breaker !== null) breaker.step();
    if (currentControle !== null) currentControle.move();
    if (mouseTool) mouseTool.step();
    let dd = outsideStep ? timer.delta : root.delta;
    postUpdate(dd);
    _Motor.changes(root.flow.tmp);
    if (isBuffer) root.post({ m: "poststep", flow: root.flow, Ar: root.Ar }, [root.Ar.buffer]);
    else root.post({ m: "poststep", flow: root.flow });
    _Motor.flowReset();
  }
  static initArray(full = false) {
    root.ArPos = getArray(root.engine, full);
  }
  static takeControl(name = null) {
    _Motor.control(name);
  }
  static control(name = null) {
    if (currentControle !== null) {
      if (name === null) {
        if (currentControle.isPlayer) currentControle.isPlayer = false;
        currentControle = null;
      } else {
        if (name !== currentControle.name) {
          currentControle = _Motor.byName(name);
          if (currentControle) currentControle.isPlayer = true;
        }
      }
    } else if (name !== null) {
      currentControle = _Motor.byName(name);
      if (currentControle) currentControle.isPlayer = true;
    }
  }
  static getAllBody(name) {
    return items.body.list;
  }
  //-----------------------
  //  ITEMS
  //-----------------------
  static initItems() {
    items["body"] = new Body();
    items["ray"] = new Ray();
    items["joint"] = new Joint();
    items["solid"] = new Solid();
    items["contact"] = new Contact();
    items["terrain"] = new Terrain();
    items["character"] = new Character();
    if (root.engine === "PHYSX" || root.engine === "AMMO") {
      items["vehicle"] = new Vehicle();
    }
    if (root.engine === "PHYSX") items["solver"] = new Solver();
    root.items = items;
  }
  static getBodyRef() {
    return items.body;
  }
  static clearBody() {
    items.body.reset();
  }
  static resetItems() {
    Object.values(items).forEach((v) => v.reset());
  }
  static stepItems() {
    Object.values(items).forEach((v) => v.step());
    _Motor.upInstance();
    _Motor.upButton();
  }
  //-----------------------
  //  INSTANCE
  //-----------------------
  static upInstance() {
    Object.values(root.instanceMesh).forEach((value) => value.update());
  }
  static clearInstance() {
    Object.values(root.instanceMesh).forEach((value) => value.dispose());
    root.instanceMesh = {};
  }
  //-----------------------
  //  ADD
  //-----------------------
  static adds(r = [], direct = false) {
    let i = r.length, n2 = 0;
    while (i--) _Motor.add(r[n2++], direct);
  }
  static add(o = {}, direct = false) {
    if (o.isObject3D) return _Motor.addDirect(o);
    if (o.constructor === Array) return _Motor.adds(o, direct);
    if (o.type === "container") return new Container(o);
    if (o.bounce !== void 0) o.restitution = o.bounce;
    if (o.type === void 0) o.type = "box";
    if (o.mode !== void 0) o.type = "joint";
    let type = getType(o);
    if (type === "joint" && o.mode === void 0) {
      o.mode = o.type;
      o.type = "joint";
    }
    let m2 = items[type].add(o);
    root.garbage.push(m2.name);
    return m2;
  }
  static addDirect(b) {
    root.scenePlus.add(b);
    root.tmpMesh.push(b);
    return b;
  }
  //-----------------------
  //  REMOVE
  //-----------------------
  static removes(r = [], direct) {
    let i = r.length, n2 = 0;
    while (i--) _Motor.remove(r[n2++], direct);
  }
  static remove(name, direct = false) {
    if (name.constructor === Array) return _Motor.removes(name, direct);
    let b = _Motor.byName(name);
    if (b === null) {
      if (root.instanceMesh[name]) items.body.clearInstance(name);
      return;
    }
    if (b.type === "autoRagdoll") {
      Utils.remove(b);
      return;
    }
    if (b.extraRemove) b.extraRemove();
    items[b.type].clear(b);
    root.post({ m: "remove", o: { name, type: b.type } }, null, direct);
  }
  //-----------------------
  //  CHANGE
  //-----------------------
  static changes(r = [], direct = false) {
    let i = r.length, n2 = 0;
    while (i--) _Motor.changeOne(r[n2++], direct);
  }
  static change(o, direct = false) {
    if (direct) {
      if (o instanceof Array) _Motor.changes(o, true);
      else _Motor.changeOne(o, true);
    } else {
      if (o instanceof Array) root.flow.tmp.push(...o);
      else root.flow.tmp.push(o);
    }
  }
  static changeOne(o = {}, direct = false) {
    if (o.heightData) return;
    let b = _Motor.byName(o.name);
    if (b === null) return null;
    let type = b.type;
    if (o.drivePosition) {
      if (o.drivePosition.rot !== void 0) {
        o.drivePosition.quat = MathTool.quatFromEuler(o.drivePosition.rot);
        delete o.drivePosition.rot;
      }
    }
    if (o.rot !== void 0) {
      o.quat = MathTool.quatFromEuler(o.rot);
      delete o.rot;
    }
    if (o.localRot !== void 0) {
      o.quat = MathTool.toLocalQuatArray(o.localRot, b);
      delete o.localRot;
    }
    switch (type) {
      case "terrain":
        b = items.terrain.set(o, b);
        direct = false;
        break;
      case "ray":
        b = items.ray.set(o, b);
        direct = false;
        break;
      case "character":
        b = items.character.set(o, b);
        break;
      case "solid":
        b = items.solid.set(o, b);
        break;
      case "joint":
        b = items.joint.set(o, b);
        break;
      case "body":
        if (b.isKinematic) items.body.set(o, b);
        break;
    }
    if (direct) {
      root.post({ m: "change", o }, null, direct);
    }
  }
  //-----------------------
  //  CAMERA CONTROLS
  //-----------------------
  static setControl(Controls) {
    controls = Controls;
    azimut = controls.getAzimuthalAngle;
  }
  static getCurrentCharacterPosition() {
    return controls.followGroup.position;
  }
  static getCamera(o = {}) {
    return controls.object;
  }
  static setCamera(o = {}) {
    controls.moveCam(o);
  }
  static follow(m2 = "", o = {}) {
    let mesh = null;
    if (typeof m2 === "string" || m2 instanceof String) mesh = m2 === "" ? null : _Motor.byName(m2);
    else if (m2.isObject3D) mesh = m2;
    if (mesh === null) controls.resetFollow();
    else controls.startFollow(mesh, o);
  }
  //-----------------------
  //  INTERN timout
  //-----------------------
  static setTimeout(f, time = 0, single = false) {
    if (single) timout = setTimeout(f, time);
    else {
      timoutFunction = f;
      timoutTime = time;
      timout = setTimeout(timoutFunction, timoutTime);
    }
  }
  static playtimout() {
    if (timoutFunction === null) return;
    timout = setTimeout(timoutFunction, timoutTime);
  }
  static pausetimout() {
    if (timout === null) return;
    clearTimeout(timout);
  }
  static cleartimout(f, time) {
    if (timout === null) return;
    timoutFunction = null;
    timoutTime = 0;
    clearTimeout(timout);
    timout = null;
  }
  //static texture( o = {} ) { return Pool.texture( o );}
  //-----------------------
  //  MATERIAL
  //-----------------------
  static setExtendShader(f) {
    Mat.extendShader = f;
  }
  static addMaterial(m2, direct) {
    Mat.set(m2, direct);
  }
  static directIntensity(v) {
    Mat.directIntensity(v);
  }
  static setEnvmapIntensity(v) {
    Mat.setEnvmapIntensity(v);
  }
  static preload(Urls, Callback) {
    preloadAvatar.add(Urls, Callback);
  }
  /*static load ( Urls, Callback, Path = '', msg = '' ){
  	Pool.load( Urls, Callback, Path, msg );
  }*/
  // TODO ?? 
  static async loadAsync(Urls, Path2 = "", msg = "") {
    await Pool.loadAsync(Urls, Path2, msg);
  }
  static applyMorph(modelName, meshs = null, normal = true, relative = true) {
    Pool.applyMorph(modelName, meshs = null, normal = true, relative = true);
  }
  static getMesh(obj, keepMaterial, multyMaterialGroup) {
    if (keepMaterial) {
      let mm = Pool.getMaterials(obj);
      for (let m2 in mm) {
        _Motor.addMaterial(mm[m2]);
      }
    }
    return Pool.getMesh(obj, multyMaterialGroup);
  }
  static getGlbMaterial(obj) {
    let ms = Pool.getMaterials(obj);
    Mat.addToMat(ms);
    return ms;
  }
  static poolDispose() {
    return Pool.dispose();
  }
  static setDracoPath(src) {
    return Pool.dracoPath = src;
  }
  //-----------------------
  //  PARTICLE
  //-----------------------
  static initParticle() {
  }
  static addParticle() {
  }
  static getParticle() {
  }
  static addParticleSolver(o) {
    let s = new Particle(o);
    particles.push(s);
    return s;
  }
  static updateParticleSolver() {
    let i = particles.length;
    while (i--) particles[i].update();
  }
  static clearParticleSolver() {
    particles.length;
    particles = [];
  }
  //-----------------------
  //  BUTTON
  //-----------------------
  static addButton(o) {
    let b = new Button(o);
    buttons.push(b);
    return b;
  }
  static upButton(o) {
    for (const key in buttons) buttons[key].update();
  }
  //-----------------------
  //  TEXT
  //-----------------------
  static addText(o) {
    let t2 = new Textfield(o);
    if (o.parent) o.parent.add(t2);
    else root.scenePlus.add(t2);
    textfields.push(t2);
    return t2;
  }
  static clearText() {
    let i = textfields.length;
    while (i--) textfields[i].dispose();
    textfields = [];
  }
  //-----------------------
  // BREAK
  //-----------------------
  static screenshot() {
    var w = window.open("", "");
    w.document.title = "Screenshot";
    w.document.body.style.cssText = "margin:0; padding:0; overflow:hidden;";
    var img = new Image();
    renderer.render(scene, _Motor.getCamera());
    img.src = renderer.domElement.toDataURL();
    w.document.body.appendChild(img);
  }
  //-----------------------
  // BREAK
  //-----------------------
  static addBreaker() {
    if (breaker !== null) return;
    breaker = new Breaker();
  }
  //-----------------------
  //  EXPLOSION
  //-----------------------
  static explosion(position = [0, 0, 0], radius = 10, force = 1) {
    let r = [];
    let pos = new Vector3();
    if (position) {
      if (position.isVector3) pos.copy(position);
      else pos.fromArray(position);
    }
    let dir = new Vector3();
    let i = items.body.list.length, b, scaling;
    while (i--) {
      b = items.body.list[i];
      dir.copy(b.position).sub(pos);
      scaling = 1 - dir.length() / radius;
      if (b.isKinematic) continue;
      if (scaling < 0) continue;
      dir.setLength(scaling);
      dir.multiplyScalar(force);
      r.push({ name: b.name, impulse: dir.toArray(), wake: true });
    }
    _Motor.change(r);
  }
};
__publicField(_Motor, "math", MathTool);
__publicField(_Motor, "pool", Pool);
__publicField(_Motor, "RayCar", RayCar);
__publicField(_Motor, "version", Version.PHY);
__publicField(_Motor, "Version", Version);
__publicField(_Motor, "message", (m2) => {
  let e = m2.data;
  if (e.Ar) root.Ar = e.Ar;
  if (e.reflow) {
    root.reflow = e.reflow;
    if (root.reflow.stat.delta) elapsedTime += root.reflow.stat.delta;
  }
  _Motor[e.m](e.o);
});
// Typically, on a Flame, the transfer speed is 80 kB/ms for postMessage 
// This means that if you want your message to fit in a single frame, 
// you should keep it under 1,300 kB
__publicField(_Motor, "post", (e, buffer = null, direct = false) => {
  if (!isWorker) {
    directMessage({ data: e });
    return;
  }
  {
    if (e.o) {
      if (e.o.type === "solver") direct = true;
      if (e.o.solver !== void 0) direct = true;
    }
    if (direct) {
      worker.postMessage(e, buffer);
    } else {
      if (e.m === "add") root.flow.add.push(e.o);
      else if (e.m === "remove") root.flow.remove.push(e.o);
      else worker.postMessage(e, buffer);
    }
  }
});
// return
__publicField(_Motor, "autoRagdoll", (o) => new AutoRagdoll(o));
__publicField(_Motor, "byName", (name) => Utils.byName(name));
__publicField(_Motor, "getScene", () => root.scene);
//-----------------------
//  TEXTURE
//-----------------------
__publicField(_Motor, "texture", (o = {}) => Pool.texture(o));
__publicField(_Motor, "getTexture", (name, o = {}) => Pool.getTexture(name, o));
// return
__publicField(_Motor, "getMatRef", () => Mat);
__publicField(_Motor, "getMat", (name) => Mat.get(name));
__publicField(_Motor, "getMaterial", (name) => Mat.get(name));
__publicField(_Motor, "getMaterialList", () => Mat.getList());
__publicField(_Motor, "material", (o = {}) => Mat.create(o));
__publicField(_Motor, "changeRenderMode", (n2) => Mat.changeRenderMode(n2));
//static changeRenderMode( n ){ return Mat.changeRenderMode( n ) }
//static getMatRef(){ return Mat }
//static material ( o = {} ){ return Mat.create( o ) }
//static getMaterialList(){ return Mat.getList(); }
//static getMat( name ){ return Mat.get( name ) }
//static getMaterial( name ){ return Mat.get( name ) }
//-----------------------
//
//  POOL
//
//-----------------------
__publicField(_Motor, "load", Pool.load);
// ( Urls, Callback, Path = '', msg = '' )
__publicField(_Motor, "get", Pool.get);
// ( name, type )
__publicField(_Motor, "getGlb", Pool.getGLB);
__publicField(_Motor, "getGroup", Pool.getGroup);
__publicField(_Motor, "getScript", Pool.getScript);
var Motor = _Motor;
var Solid = class extends Body {
  constructor() {
    super();
    this.type = "solid";
  }
  step() {
  }
};
var phy = Motor;
var math$1 = Motor.math;
var pool = Motor.pool;
export {
  math$1 as math,
  phy,
  pool
};
/*! Bundled license information:

phy-engine/build/Phy.module.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.6.9
  *)
  (*!Human.haveLOD; *)
*/
//# sourceMappingURL=phy-engine.js.map
